<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vim编辑器</title>
    <url>/2020/03/24/vim-bian-ji-qi/</url>
    <content><![CDATA[<h4 id="七、Vim编辑器"><a href="#七、Vim编辑器" class="headerlink" title="七、Vim编辑器"></a>七、Vim编辑器</h4><h5 id="（一）打开文件"><a href="#（一）打开文件" class="headerlink" title="（一）打开文件"></a>（一）打开文件</h5><pre><code># vim [OPTION]...FILE...
</code></pre><a id="more"></a>
<ol>
<li><p>+#：打开文件后，让光标处于第#行的行首，+默认行尾；</p>
</li>
<li><p>+/PATTERN：打开文件后，直接让光标处于第一个被PATTERN匹配到的行首；</p>
</li>
<li>-b file：二进制方式打开文件；</li>
<li>-d file1 file2…：比较多个文件；</li>
<li>-m file：打开只读文件；</li>
<li>ex file或vim -e 直接进入ex模式；</li>
<li>如果改文件存在，文件被打开并显示内容；如果不存在，当编辑后第一次存盘时创建它。</li>
</ol>
<h5 id="（二）vim模式"><a href="#（二）vim模式" class="headerlink" title="（二）vim模式"></a>（二）vim模式</h5><p><img src="/2020/03/24/vim-bian-ji-qi/图片二.png" alt></p>
<h5 id="（三）模式转换"><a href="#（三）模式转换" class="headerlink" title="（三）模式转换"></a>（三）模式转换</h5><ol>
<li><p>命令模式 —&gt; 插入模式</p>
<p>​    i：insert，当光标所在处输入；</p>
<p>​    I：在当前光标所在行的行首输入；</p>
<p>​    a：append，在光标所在处后面输入；</p>
<p>​    A：在当前光标所在行的行尾输入；</p>
<p>​    o：在当前光标所在行的下方打开一个新行；</p>
<p>​    O：在当前光标所在行的上方打开一个新行。</p>
</li>
<li><p>插入模式 —&gt; 命令模式：ESC</p>
</li>
<li>命令模式 —&gt; 扩展命令模式：：</li>
<li>扩展命令模式 —&gt; 命令模式：ESC，enter</li>
</ol>
<h5 id="（四）关闭文件"><a href="#（四）关闭文件" class="headerlink" title="（四）关闭文件"></a>（四）关闭文件</h5><h6 id="1-扩展模式："><a href="#1-扩展模式：" class="headerlink" title="1.扩展模式："></a>1.扩展模式：</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出，丢弃你做出的修改</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:x</td>
<td>保存退出</td>
</tr>
<tr>
<td>:w</td>
<td>写（存）磁盘文件</td>
</tr>
<tr>
<td>:r filename</td>
<td>读文件内容到当前文件中</td>
</tr>
<tr>
<td>:w filename</td>
<td>读当前文件内容写入另一个文件</td>
</tr>
<tr>
<td>:r!command</td>
<td>读入命令的输出</td>
</tr>
<tr>
<td>:!command</td>
<td>执行命令</td>
</tr>
</tbody>
</table>
</div>
<h6 id="2-命令模式："><a href="#2-命令模式：" class="headerlink" title="2.命令模式："></a>2.命令模式：</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
<tr>
<td>ZQ</td>
<td>不保存退出</td>
</tr>
</tbody>
</table>
</div>
<h6 id="3-命令模式光标跳转"><a href="#3-命令模式光标跳转" class="headerlink" title="3.命令模式光标跳转"></a>3.命令模式光标跳转</h6><p>（1）字符间跳转：</p>
<p>​        h：左；    l：右；    j：下；    k：上；</p>
<p>​        #COMMAND：跳转由#指定的个数的字符。</p>
<p>（2）单词间跳转</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>下一个单词的词首</td>
</tr>
<tr>
<td>e</td>
<td>当前或下一单词的词尾</td>
</tr>
<tr>
<td>b</td>
<td>当前或前一个单词的词首</td>
</tr>
<tr>
<td>#COMMAND</td>
<td>由#指定一次跳转的单词数</td>
</tr>
</tbody>
</table>
</div>
<p>（3）当前页跳转</p>
<p>​        H：页首；    M：页中间行；    L：页底。</p>
<p>（4）行首行尾跳转</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>跳转至行首的第一个非空白符</td>
</tr>
<tr>
<td>0</td>
<td>跳转至行首</td>
</tr>
<tr>
<td>$</td>
<td>跳转至行尾</td>
</tr>
</tbody>
</table>
</div>
<p>（5）行间移动</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>最后一行</td>
</tr>
<tr>
<td>1G/gg</td>
<td>第一行</td>
</tr>
</tbody>
</table>
</div>
<p>（6）句间移动</p>
<p>​        )：下一句；    （：上一句</p>
<p>（7）段落间移动</p>
<p>​        }：下一段；    {：上一段</p>
<h6 id="4-字符编辑"><a href="#4-字符编辑" class="headerlink" title="4.字符编辑"></a>4.字符编辑</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标处的字符</td>
</tr>
<tr>
<td>#x</td>
<td>删除光标处起始的#个字符</td>
</tr>
<tr>
<td>xp</td>
<td>交换光标所在处的字符及其后面的字符的位置</td>
</tr>
<tr>
<td>~</td>
<td>转换大小写</td>
</tr>
<tr>
<td>J</td>
<td>删除当前行后的换行符</td>
</tr>
</tbody>
</table>
</div>
<h6 id="5-替换命令"><a href="#5-替换命令" class="headerlink" title="5.替换命令"></a>5.替换命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>替换光标所在处的字符</td>
</tr>
<tr>
<td>R</td>
<td>切换成REPLACE模式</td>
</tr>
</tbody>
</table>
</div>
<h6 id="6-删除命令"><a href="#6-删除命令" class="headerlink" title="6.删除命令"></a>6.删除命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>删除命令，可结合光标跳转字符，实现范围删除</td>
</tr>
<tr>
<td>d$</td>
<td>删除到行尾</td>
</tr>
<tr>
<td>d^</td>
<td>删除到非空行首</td>
</tr>
<tr>
<td>d0</td>
<td>删除到行首</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的行</td>
</tr>
<tr>
<td>#dd</td>
<td>多行删除</td>
</tr>
<tr>
<td>D</td>
<td>从当前光标位置一直删除到行尾，留空行，等同于d$</td>
</tr>
</tbody>
</table>
</div>
<h6 id="7-复制命令"><a href="#7-复制命令" class="headerlink" title="7.复制命令"></a>7.复制命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>复制，行为相似于d命令</td>
</tr>
<tr>
<td>yy</td>
<td>复制行</td>
</tr>
<tr>
<td>Y</td>
<td>复制整行</td>
</tr>
</tbody>
</table>
</div>
<h6 id="8-粘贴命令"><a href="#8-粘贴命令" class="headerlink" title="8.粘贴命令"></a>8.粘贴命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，粘贴至当前光标所在处的后面；</td>
</tr>
<tr>
<td>P</td>
<td>缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，粘贴至当前光标所在处的前面；</td>
</tr>
</tbody>
</table>
</div>
<h6 id="9-改变命令"><a href="#9-改变命令" class="headerlink" title="9.改变命令"></a>9.改变命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>修改后切换成插入模式</td>
</tr>
<tr>
<td>cc</td>
<td>删除当前行并输入新内容，相当于S</td>
</tr>
<tr>
<td>C</td>
<td>删除当前光标到行尾，并切换成插入模式</td>
</tr>
</tbody>
</table>
</div>
<h6 id="10-地址定界"><a href="#10-地址定界" class="headerlink" title="10.地址定界"></a>10.地址定界</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>具体第#行，例如2表示第2行</td>
</tr>
<tr>
<td>#，#</td>
<td>从左侧#表示起始行，到右侧#表示结尾行</td>
</tr>
<tr>
<td>#，+#</td>
<td>从左侧#表示的起始行，加上右侧#表示的行数：2，+3   表示2到5行</td>
</tr>
<tr>
<td>.</td>
<td>当前行</td>
</tr>
<tr>
<td>$</td>
<td>最后一行</td>
</tr>
<tr>
<td>%</td>
<td>全文，相当于1，$</td>
</tr>
</tbody>
</table>
</div>
<h6 id="11-查找"><a href="#11-查找" class="headerlink" title="11.查找"></a>11.查找</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PATTERN</td>
<td>从当前光标所在处向文件尾部查找</td>
</tr>
<tr>
<td>?PATTERN</td>
<td>从当前光标所在处向文件首部查找</td>
</tr>
<tr>
<td>n</td>
<td>与命令同方向</td>
</tr>
<tr>
<td>N</td>
<td>与命令反方向</td>
</tr>
</tbody>
</table>
</div>
<h6 id="12-查找并替换"><a href="#12-查找并替换" class="headerlink" title="12.查找并替换"></a>12.查找并替换</h6><p>​        s：在扩展模式下完成查找替换操作</p>
<p>​                格式：s/要查找的内容/替换为的内容/修饰符</p>
<p>​                可以使用”&amp;“引用前面查找是查找到的整个内容</p>
<h6 id="13-撤销更改"><a href="#13-撤销更改" class="headerlink" title="13.撤销更改"></a>13.撤销更改</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤销最近的更改</td>
</tr>
<tr>
<td>#u</td>
<td>撤销之前的多次更改</td>
</tr>
<tr>
<td>U</td>
<td>撤销光标落在这行后所有此行的更改</td>
</tr>
<tr>
<td>Ctrl -r</td>
<td>重做最后的“撤销”更改</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个操作</td>
</tr>
<tr>
<td>n.</td>
<td>重复前一个操作n次</td>
</tr>
</tbody>
</table>
</div>
<h6 id="14-可视化模式"><a href="#14-可视化模式" class="headerlink" title="14.可视化模式"></a>14.可视化模式</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>面向字符</td>
</tr>
<tr>
<td>V</td>
<td>面向行</td>
</tr>
<tr>
<td>ctrl -v</td>
<td>面向块</td>
</tr>
</tbody>
</table>
</div>
<h6 id="15-多窗口"><a href="#15-多窗口" class="headerlink" title="15.多窗口"></a>15.多窗口</h6><p>​    （1）多文件分割</p>
<p>​                vim -o|-O FILE1 FILE2…</p>
<p>​                -o：水平分割；    -O：垂直分割。</p>
<p>​    （2）单文件窗口分割</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+w,s</td>
<td>水平分割</td>
</tr>
<tr>
<td>Ctrl+w,v</td>
<td>垂直分割</td>
</tr>
<tr>
<td>Ctrl+w,q</td>
<td>取消相邻窗口</td>
</tr>
<tr>
<td>Ctrl+w,o</td>
<td>取消全部窗口</td>
</tr>
<tr>
<td>:wqall</td>
<td>退出</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统的用户接口以及SQL语言</title>
    <url>/2020/03/18/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan/</url>
    <content><![CDATA[<h4 id="一、DBMS的用户数据接口"><a href="#一、DBMS的用户数据接口" class="headerlink" title="一、DBMS的用户数据接口"></a>一、DBMS的用户数据接口</h4><h5 id="（一）查询语言；"><a href="#（一）查询语言；" class="headerlink" title="（一）查询语言；"></a>（一）查询语言；</h5><p>​        形式化查询语言 Formal Query Language</p>
<a id="more"></a>
<p>​        表格式查询语言 Tabular Query Language</p>
<p>​        图形化查询语言 Graphic Query Language</p>
<p>​        受限的自然语言 Limited Natural Language Query Language</p>
<h5 id="（二）图形化用户工具（GUI）"><a href="#（二）图形化用户工具（GUI）" class="headerlink" title="（二）图形化用户工具（GUI）"></a>（二）图形化用户工具（GUI）</h5><h5 id="（三）APIs：应用程序的访问接口"><a href="#（三）APIs：应用程序的访问接口" class="headerlink" title="（三）APIs：应用程序的访问接口"></a>（三）APIs：应用程序的访问接口</h5><h5 id="（四）Class-Library：类库"><a href="#（四）Class-Library：类库" class="headerlink" title="（四）Class Library：类库"></a>（四）Class Library：类库</h5><h4 id="二、SQL-Language"><a href="#二、SQL-Language" class="headerlink" title="二、SQL Language"></a>二、SQL Language</h4><h5 id="（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询-，插入，更新和删除等操作"><a href="#（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询-，插入，更新和删除等操作" class="headerlink" title="（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询 ，插入，更新和删除等操作"></a>（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询 ，插入，更新和删除等操作</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DML语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>从表或视图中检索数据行</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据到表或视图</td>
</tr>
<tr>
<td>UPDATE</td>
<td>更新数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>CALL</td>
<td>调用过程</td>
</tr>
<tr>
<td>MERGE</td>
<td>合并（插入或修改）</td>
</tr>
<tr>
<td>COMMIT</td>
<td>将当前事务所做的更改永久化（写入数据库）</td>
</tr>
<tr>
<td>ROLLBACK</td>
<td>取消上次提交以来的所有操作</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（二）数据定义语言（DDL）-是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。"><a href="#（二）数据定义语言（DDL）-是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。" class="headerlink" title="（二）数据定义语言（DDL）:是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。"></a>（二）数据定义语言（DDL）:是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DDL语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>创建数据库结构</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改数据库结构</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库结构</td>
</tr>
<tr>
<td>RENAME</td>
<td>更改数据库对象的名称</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>删除表的全部内容</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种："><a href="#（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种：" class="headerlink" title="（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种："></a>（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种：</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DCL语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRANT</td>
<td>授予其他用户对数据库结构的访问权限</td>
</tr>
<tr>
<td>REVOKE</td>
<td>收回用户访问数据库结构的权限</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三、基本SQL查询"><a href="#三、基本SQL查询" class="headerlink" title="三、基本SQL查询"></a>三、基本SQL查询</h4><p>​    SELECT        [DISTINCT（用来消除重复元组）] target-list</p>
<p>​    FROM          relation-list</p>
<p>​    WHERE        qualification（结果应该满足的条件）</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">嵌套查询实例1：查询订了103号船的水手
SELECT S.name
FROM Sailors
WHERE EXISTS（SELECT *
                FROM Reserves R
                WHERE R.bid=103 AND S.sid=R.sid）
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">嵌套查询实例2：查询比名字叫Horatio水手级别高的所有人
SELECT *
FROM Sailors S
WHERE S.rating > ANY（SELECT S2.rating
                        FROM Sailors S2
                        WHERE S2.sname='Horatio'）
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础（二）</title>
    <url>/2020/03/17/linux-ji-chu-er/</url>
    <content><![CDATA[<h4 id="一、用户user"><a href="#一、用户user" class="headerlink" title="一、用户user"></a>一、用户user</h4><h5 id="（一）令牌-token-identity"><a href="#（一）令牌-token-identity" class="headerlink" title="（一）令牌 token , identity"></a>（一）令牌 token , identity</h5><h5 id="（二）Linux用户：Username-UID"><a href="#（二）Linux用户：Username-UID" class="headerlink" title="（二）Linux用户：Username/UID"></a>（二）Linux用户：Username/UID</h5><a id="more"></a>
<p>​    管理员：root，0</p>
<p>​    普通用户：1-65535</p>
<p>​        系统用户：1-499（centos6）,1-999（centos7）——对守护进程获取资源进行权限分配</p>
<p>​        登录用户：500+（centos6），1000+（centos7）——交互式登录</p>
<h4 id="二、组group"><a href="#二、组group" class="headerlink" title="二、组group"></a>二、组group</h4><h5 id="（一）Linux组：Groupname-GID"><a href="#（一）Linux组：Groupname-GID" class="headerlink" title="（一）Linux组：Groupname/GID"></a>（一）Linux组：Groupname/GID</h5><p>​    1.管理员组：root，0</p>
<p>​    2.普通组：</p>
<p>​            系统组：1-499（centos6）,1-999（centos7）</p>
<p>​            普通组：500+（centos6），1000+（centos7）</p>
<h5 id="（二）Linux组的类别"><a href="#（二）Linux组的类别" class="headerlink" title="（二）Linux组的类别"></a>（二）Linux组的类别</h5><p>​    1.用户的主要组：用户必须属于一个且只有一个主组；</p>
<p>​                               组名同用户名，且仅包含一个用户，私有组。</p>
<p>​    2.用户的附加组：一个用户可以属于零个或多个辅助组。</p>
<h5 id="（三）Linux用户和组的主要配置文件"><a href="#（三）Linux用户和组的主要配置文件" class="headerlink" title="（三）Linux用户和组的主要配置文件"></a>（三）Linux用户和组的主要配置文件</h5><div class="table-container">
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/passwd</td>
<td>用户及其属性信息</td>
</tr>
<tr>
<td>/etc/group</td>
<td>组及其属性信息</td>
</tr>
<tr>
<td>/etc/shadow</td>
<td>用户密码及其相关属性</td>
</tr>
<tr>
<td>/etc/gshadow</td>
<td>组密码及其相关属性</td>
</tr>
</tbody>
</table>
</div>
<h6 id="passwd文件格式："><a href="#passwd文件格式：" class="headerlink" title="passwd文件格式："></a>passwd文件格式：</h6><p>1.login name：登录用名；</p>
<p>2.passwd：密码；</p>
<p>3.UID：用户身份编号；</p>
<p>4.GID：登录默认所在组编号；</p>
<p>5.GECOS：用户全名或注释；</p>
<p>6.home directory：用户主目录；</p>
<p>7.shell：用户默认使用shell。</p>
<h5 id="（四）group文件格式"><a href="#（四）group文件格式" class="headerlink" title="（四）group文件格式"></a>（四）group文件格式</h5><p>1.群组名称：就是群组名称；</p>
<p>2.群组密码：通常不需要设定，密码是记录在/etc/shadow</p>
<p>3.GID：就是群组的GID；</p>
<p>4.以当前组为附加组的用户列表（分隔符为逗号）</p>
<h4 id="三、用户和组管理命令"><a href="#三、用户和组管理命令" class="headerlink" title="三、用户和组管理命令"></a>三、用户和组管理命令</h4><p>1.用户管理命令：useradd（创建）；usermod（修改）；userdel（删除）</p>
<p>2.组账号维护命令：groupadd；groupmod；groupdel</p>
<p>3.切换身份：su username（不改变目录环境）</p>
<p>​                      su - username</p>
<p>​                      退回原来身份：exit</p>
<p>4.修改用户密码：passwd [OPTIONS] username</p>
<p>   修改组密码：gpasswd [OPTIONS] group</p>
<h4 id="四、文件权限"><a href="#四、文件权限" class="headerlink" title="四、文件权限"></a>四、文件权限</h4><h5 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h5><p><img src="/2020/03/17/linux-ji-chu-er/图片一.png" alt></p>
<p>​    r：读权限；w：写权限；x：执行权限</p>
<h5 id="（二）文件属性操作"><a href="#（二）文件属性操作" class="headerlink" title="（二）文件属性操作"></a>（二）文件属性操作</h5><p>​    chown：设置文件的所有者；</p>
<p>​    chgrp：设置文件的属组信息；</p>
<p>​    chmod：修改文件权限</p>
<h5 id="（三）默认权限"><a href="#（三）默认权限" class="headerlink" title="（三）默认权限"></a>（三）默认权限</h5><p>​    1.umask值：可以用来保留在创建文件权限；</p>
<p>​    2.非特权用户umask是002；root的umask是022；</p>
<p>​    3.全局设置：/etc/bashrc    用户设置：~/.bashrc。</p>
<h5 id="（四）特殊权限"><a href="#（四）特殊权限" class="headerlink" title="（四）特殊权限"></a>（四）特殊权限</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUID</td>
<td>当s这个标志出现在<strong>文件所有者的x权限上</strong>时，例如文件权限状态“-rwsr-xr-x”，此时就称为 Set UID，简称为SUID的特殊权限。</td>
<td>（1）SUID权限仅对<strong>二进制程序</strong>有效；（2）执行者对于该程序需要<strong>具有x的可执行权限</strong>；（3）本权限仅在<strong>执行该程序的过程中</strong>有效；（4）执行者将具有该程序所有者的权限。</td>
</tr>
<tr>
<td>SGID</td>
<td>当s标志出现在文件所有者的x权限时称为SUID，那么s出现在用户组的x权限时称为SGID。</td>
<td>（1）SGID对二进制程序有用；（2）程序执行者对该程序需具备x权限；（3）执行者在执行过程中会获得该程序用户组的支持；（4）一旦<strong>某目录</strong>被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组。</td>
</tr>
<tr>
<td>SBIT</td>
<td>SBIT目前只对目录有效。</td>
<td>（1）当用户对此目录具有w和x权限时，即具有<strong>写入权限</strong>时；（2）当用户在该目录下创建新文件或目录时，<strong>仅有自己和root</strong>才有权力删除。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（五）访问控制列表"><a href="#（五）访问控制列表" class="headerlink" title="（五）访问控制列表"></a>（五）访问控制列表</h5><p>​    1.ACL：Access Control List，实现灵活的权限管理；</p>
<p>​    2.除了文件的所有者，所属组和其他人，可以对更多的用户设置权限；</p>
<p>​    3.CentOS7默认创建的xfs和ext4文件系统具有ACL功能；</p>
<p>​    4.ACL生效顺序：所有者，自定义用户，自定义组，其他人</p>
<h4 id="五、文件查看"><a href="#五、文件查看" class="headerlink" title="五、文件查看"></a>五、文件查看</h4><h5 id="（一）文件查看命令"><a href="#（一）文件查看命令" class="headerlink" title="（一）文件查看命令"></a>（一）文件查看命令</h5><p>​        cat，tac，rev</p>
<h5 id="（二）分页查看文件内容"><a href="#（二）分页查看文件内容" class="headerlink" title="（二）分页查看文件内容"></a>（二）分页查看文件内容</h5><p>​        more：分页查看文件；-d：显示翻页及退出提示；</p>
<p>​        less：一页一页地查看文件或STDIN输出；</p>
<h5 id="（三）显示文本前或后行内容"><a href="#（三）显示文本前或后行内容" class="headerlink" title="（三）显示文本前或后行内容"></a>（三）显示文本前或后行内容</h5><p>​        head：-c #:指定获取前#字节；-n #:指定获取前#行（默认前十行）；-#:指定行数</p>
<p>​        tail：-f:跟踪显示文件fd新追加的内容，常用日志监控；</p>
<p>​        tailf：类似tail -f，当文件不增长时并不访问文件。</p>
<h5 id="（四）文本处理"><a href="#（四）文本处理" class="headerlink" title="（四）文本处理"></a>（四）文本处理</h5><p>​        grep：文本过滤（模式：pattern）工具</p>
<p>​        sed：stream editor，文本编辑工具</p>
<p>​        awk：Linux上的实现gawk，文本报告生成器。</p>
<h4 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h4><h5 id="（一）REGEXP"><a href="#（一）REGEXP" class="headerlink" title="（一）REGEXP"></a>（一）REGEXP</h5><p>由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能。</p>
<h5 id="（二）程序支持"><a href="#（二）程序支持" class="headerlink" title="（二）程序支持"></a>（二）程序支持</h5><p>grep    sed    awk    vim    less    ngnix    varnish等。</p>
<h5 id="（三）分类"><a href="#（三）分类" class="headerlink" title="（三）分类"></a>（三）分类</h5><p>基本正则表达式：BRE</p>
<p>扩展正则表达式：ERE</p>
<h5 id="（四）正则表达式引擎"><a href="#（四）正则表达式引擎" class="headerlink" title="（四）正则表达式引擎"></a>（四）正则表达式引擎</h5><p>采用不同算法，检查处理正则表达式的软件模式    PCRE（Perl Compatible Expressions）</p>
<h5 id="（五）元字符分类"><a href="#（五）元字符分类" class="headerlink" title="（五）元字符分类"></a>（五）元字符分类</h5><h6 id="1-字符通配"><a href="#1-字符通配" class="headerlink" title="1.字符通配"></a>1.字符通配</h6><p>“ . “：匹配任意单个字符</p>
<p>“ []”：匹配指定范围内的任意单个字符</p>
<p>“ ^”：匹配指定范围外的任意单个字符</p>
<p>[:digit:]：数字</p>
<p>[:alpha:]：字母</p>
<p>[:alnum:]：数字和字母</p>
<p>[[:digit:]]：匹配任意数字，</p>
<p>[[:lower:]]：匹配小写字母，</p>
<p>[[:upper:]]：匹配大写字母</p>
<h6 id="2-匹配次数"><a href="#2-匹配次数" class="headerlink" title="2.匹配次数"></a>2.匹配次数</h6><p><em>（星）：匹配 </em> 前面字符任意次数</p>
<p>.*:匹配任意长度的任意字符</p>
<p>\？：匹配前面的字符0次或1次</p>
<p>\ *：匹配一次或者多次</p>
<p>\ {m,n\ }：匹配 其前面的字符至少 m 次，至多 n 次</p>
<p>\ {0,n\ }：匹配至多n次</p>
<p>\ {m,\ }：至少m次</p>
<h6 id="3-位置锚定"><a href="#3-位置锚定" class="headerlink" title="3.位置锚定"></a>3.位置锚定</h6><p>^：行首锚定，用于模式的最左侧</p>
<p>$：行尾锚定，用于模式的最右侧</p>
<p>^$：空行</p>
<p>^ [[:space:]]*$：空行或包括空白字符的行</p>
<p>词首锚定：\ &lt; 或 \b，用于单词模式的左侧</p>
<p>词尾锚定：\ &gt; 或 \b，用于单词模式的右侧</p>
<p>匹配完整单词：\ &lt;索要匹配的单词\ &gt;</p>
<h6 id="4-分组"><a href="#4-分组" class="headerlink" title="4.分组"></a>4.分组</h6><p> \ (\ )：将一个或者多个字符捆绑在一起，当做一个整体进行处理</p>
<p> \（xy\）\ (zd\ )ab\1：把xy当做第一组，把zd当做第二组，取第一组</p>
<p> \1：引用第一个分组</p>
<pre><code>#查看分区利用率
[root@localhost ~]# df -h |grep &quot;^/dev/sd&quot; |grep -o &#39;[[:digit:]]\+%&#39; |grep -o &#39;[[:digit:]]\+&#39;
</code></pre><h5 id="（六）egrep及扩展的正则表达式（基本不用加-）"><a href="#（六）egrep及扩展的正则表达式（基本不用加-）" class="headerlink" title="（六）egrep及扩展的正则表达式（基本不用加 \）"></a>（六）egrep及扩展的正则表达式（基本不用加 \）</h5><p>egrep = grep = -E</p>
<p>egrep [OPTIONS] PATTERN [FILE]</p>
<p>字符匹配：    . 任意单个字符</p>
<p>​                        [] 指定范围的字符</p>
<p>​                        <sup><a href="#fn_" id="reffn_"></a></sup> 不在指定范围的字符</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据模型</title>
    <url>/2020/03/15/shu-ju-mo-xing/</url>
    <content><![CDATA[<h4 id="一、层次模型"><a href="#一、层次模型" class="headerlink" title="一、层次模型"></a>一、层次模型</h4><h5 id="（一）PCR关系（Parent-Child-relationship）："><a href="#（一）PCR关系（Parent-Child-relationship）：" class="headerlink" title="（一）PCR关系（Parent-Child relationship）："></a>（一）PCR关系（Parent-Child relationship）：</h5><p>现实世界中的一对多的关系，是层次模型最基本的数据关系，例如：</p>
<a id="more"></a>
<pre class="mermaid">graph TB;
　　院系-->班级;
　　院系-->教研组;
　　班级-->学生1;
　　班级-->学生n;
　　教研组-->老师1;
　　教研组-->老师n;</pre>

<h5 id="（二）虚记录"><a href="#（二）虚记录" class="headerlink" title="（二）虚记录"></a>（二）虚记录</h5><p>为了避免数据的冗余，又维持数据PCR结构，引入虚记录概念。</p>
<p>例：student-v通过指针指向真正的student：</p>
<pre class="mermaid">graph LR   
    course-v-.->course
    student-v-.->student
    course-->student-v
    student-->course-v</pre>

<h4 id="二、网状数据模型"><a href="#二、网状数据模型" class="headerlink" title="二、网状数据模型"></a>二、网状数据模型</h4><h5 id="（一）基本结构："><a href="#（一）基本结构：" class="headerlink" title="（一）基本结构："></a>（一）基本结构：</h5><p>系（set）表示现实世界中一对多的关系。</p>
<p>主记录（1）——&gt; 属记录（n）</p>
<p>每个系可以是多个系的主记录，也可以是多个系的属记录，交织成复杂的网状结构。</p>
<pre class="mermaid">graph TB   
    Parts-1-->|m|LINK-M
    Supplier-1-->|n|LINK-M
    Project-1-->|p|LINK-M
    S-1-->|SL|LINK-N
    C-1-->|CL|LINK-N</pre>

<p>（查询时遍历链表）</p>
<h4 id="三、关系模型"><a href="#三、关系模型" class="headerlink" title="三、关系模型"></a>三、关系模型</h4><h5 id="（一）基本结构：-1"><a href="#（一）基本结构：-1" class="headerlink" title="（一）基本结构："></a>（一）基本结构：</h5><p>表（table），将现实世界实体中的所有关系由表来表示：</p>
<p>（1）基于数学集合论，具有更高层次；</p>
<p>（2）底层实现及编程细节都被屏蔽掉，概念简单清除，容易理解；</p>
<p>（3）建立新的代数体系——关系代数；</p>
<p>（4）可以定义<strong>非过程化</strong>的查询语言——SQL；</p>
<p>（5）软连接</p>
<h5 id="（二）属性和域"><a href="#（二）属性和域" class="headerlink" title="（二）属性和域"></a>（二）属性和域</h5><p>1.表的为一个属性都为原子不能再分的，每一个属性的合法取值范围成为域；</p>
<p>2.表中允许NULL（表示未知）；</p>
<h5 id="（三）关系和元组"><a href="#（三）关系和元组" class="headerlink" title="（三）关系和元组"></a>（三）关系和元组</h5><p>1.假设有关系R，属性为A<sub>1</sub>,A<sub>2</sub>,…A<sub>n</sub>，其对应的值域为D<sub>1</sub>,D<sub>2</sub>,…D<sub>n</sub>，n称为目，那么关系R可以表示为</p>
<script type="math/tex; mode=display">
R=（A_1/D_1,A_2/D_2,...A_n/D_n）或者R=(A_1,A_2,...A_n)</script><p>r 称为关系 R 的实例，r 由 m 个元组（tuple）组成。</p>
<p>2.表里的每一行称为记录，即元组t</p>
<script type="math/tex; mode=display">
t \in D_1\times D_2\times ,...,\times D_n, 1\leq i\leq n</script><script type="math/tex; mode=display">
r \subseteq D_1\times D_2\times ,...,\times D_n, 1\leq i\leq n</script><h5 id="（四）组键"><a href="#（四）组键" class="headerlink" title="（四）组键"></a>（四）组键</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>候选键</td>
<td style="text-align:left">总有某一个或者某一组属性的值可以唯一的决定这条元组的其他属性的值，且这组属性的子集没有此特性，把这样的属性或属性组称为候选键</td>
</tr>
<tr>
<td>超键</td>
<td style="text-align:left">在关系中能唯一标识元组的属性或属性集称为关键模式为超键，与候选键相比可能有多余属性</td>
</tr>
<tr>
<td>主键</td>
<td style="text-align:left">用户选作元组标识的候选键称为主键。一般不加说明，键就是指主键（主键不能为空）</td>
</tr>
<tr>
<td>全键</td>
<td style="text-align:left">关系模型的所有属性组是这个关系模式的候选键</td>
</tr>
<tr>
<td>外键</td>
<td style="text-align:left">关系模式R1中的某属性集不是自己的主键，而是关系模式R2的主键，则该属性集称为是关系模式R1的外键</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（五）关系代数"><a href="#（五）关系代数" class="headerlink" title="（五）关系代数"></a>（五）关系代数</h5><p>五种基本的关系代数运算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
<th>作用</th>
<th>运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>并</td>
<td>∪</td>
<td>关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S</td>
<td>R∪S = {t\</td>
<td>t∈R∨t∈S}</td>
</tr>
<tr>
<td>差</td>
<td>−</td>
<td>关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S</td>
<td>R−S = {t\</td>
<td>t∈R∨t∉S}</td>
</tr>
<tr>
<td>广义笛卡尔积</td>
<td>×</td>
<td>两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S</td>
<td>R×S = {t\</td>
<td>t =&lt; (t<sup>n</sup>,t<sup>m</sup>)∧t<sup>n</sup>∈R∧t<sup>m</sup>∈S}</td>
</tr>
<tr>
<td>投影</td>
<td>π</td>
<td>投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作π<sub>A</sub>(R)</td>
<td>π<sub>A</sub>(R) = {t[A]\</td>
<td>t∈R}</td>
</tr>
<tr>
<td>选择</td>
<td>σ</td>
<td>选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 σ<sub>F</sub>(R)</td>
<td>σ<sub>F</sub>(R) = {t\</td>
<td>t∈R∧F(t)=True}</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（六）关系连接"><a href="#（六）关系连接" class="headerlink" title="（六）关系连接"></a>（六）关系连接</h5><h6 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h6><p>也称为等值连接，是最早的一种连接。还可以被称为普通连接或者<a href="http://baike.baidu.com/item/自然连接" target="_blank" rel="noopener">自然连接</a>，内连接是从结果表中删除与其他被<a href="http://baike.baidu.com/item/连接表" target="_blank" rel="noopener">连接表</a>中没有匹配行的所有行，所以内连接可能会丢失信息。WHERE子句中设置的消除笛卡尔积的条件就是使用了等值判断的方式进行的。</p>
<h6 id="2-外连接"><a href="#2-外连接" class="headerlink" title="2.外连接"></a>2.外连接</h6><p>内连接中只能够显示等值满足条件的，如果不满住条件的无法显示，如果希望可以显示特定表的全部数据，就用外链接：外连接分为三种：左外连接，右外连接，全外连接。</p>
<p>（1）左外链接：左关系属性=右关系属性（+），放在等号的右边表示左连接；意思就是显示左边表中没有显示的信息；</p>
<p>（2）右外链接：左关系属性（+）= 右关系属性，放在等号的左边表示右连接；意思就是显示右边表中没有显示的信息。</p>
<h4 id="四、ER图"><a href="#四、ER图" class="headerlink" title="四、ER图"></a>四、ER图</h4><h5 id="（一）ER图的实体：数据模型中的数据对象"><a href="#（一）ER图的实体：数据模型中的数据对象" class="headerlink" title="（一）ER图的实体：数据模型中的数据对象"></a>（一）ER图的实体：数据模型中的数据对象</h5><h6 id="1-弱实体："><a href="#1-弱实体：" class="headerlink" title="1.弱实体："></a>1.弱实体：</h6><p>一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如上图的学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p>
<h6 id="2-复合实体："><a href="#2-复合实体：" class="headerlink" title="2.复合实体："></a>2.复合实体：</h6><p>复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示。</p>
<h5 id="（二）ER图的属性：数据对象所具有的属性"><a href="#（二）ER图的属性：数据对象所具有的属性" class="headerlink" title="（二）ER图的属性：数据对象所具有的属性"></a>（二）ER图的属性：数据对象所具有的属性</h5><p>例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p>
<h5 id="（三）ER图的关系：数据对象与数据对象之间的联系"><a href="#（三）ER图的关系：数据对象与数据对象之间的联系" class="headerlink" title="（三）ER图的关系：数据对象与数据对象之间的联系"></a>（三）ER图的关系：数据对象与数据对象之间的联系</h5><p>1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p>
<p>1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p>
<p>多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p>
<h5 id="（四）工具：Processon"><a href="#（四）工具：Processon" class="headerlink" title="（四）工具：Processon"></a>（四）工具：<a href="https://www.processon.com/login" target="_blank" rel="noopener">Processon</a></h5>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础(一)</title>
    <url>/2020/03/08/linux-ji-chu/</url>
    <content><![CDATA[<h4 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h4><h5 id="（一）OS：Operating-System，通用目的的软件程序"><a href="#（一）OS：Operating-System，通用目的的软件程序" class="headerlink" title="（一）OS：Operating System，通用目的的软件程序"></a>（一）OS：Operating System，通用目的的软件程序</h5><p>硬件驱动；进程管理；内存管理；网络管理；安全管理；文件管理。</p>
<a id="more"></a>
<pre class="mermaid">graph TB;
　　用户-->应用软件;
　　应用软件-->用户;
　　应用软件-->操作系统;
　　操作系统-->应用软件;
　　硬件-->操作系统;
　　操作系统-->硬件;</pre>

<h5 id="（二）OS分类："><a href="#（二）OS分类：" class="headerlink" title="（二）OS分类："></a>（二）OS分类：</h5><p>服务器OS：RHEL，CentOS，Windows Server，AIX；</p>
<p>桌面OS：Windows 10，Windows 7，Mac OS，Fedora；</p>
<p>移动设备OS：Andriod,IOS,YunOS</p>
<h4 id="二、开发接口标准"><a href="#二、开发接口标准" class="headerlink" title="二、开发接口标准"></a>二、开发接口标准</h4><h5 id="（一）ABI："><a href="#（一）ABI：" class="headerlink" title="（一）ABI："></a>（一）ABI：</h5><p>ABI描述了应用程序与OS之间的底层接口，允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行；</p>
<h5 id="（二）API："><a href="#（二）API：" class="headerlink" title="（二）API："></a>（二）API：</h5><p>API定义了源码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译；</p>
<h5 id="（三）POSIX："><a href="#（三）POSIX：" class="headerlink" title="（三）POSIX："></a>（三）POSIX：</h5><p>IEEE在操作系统上定义的一系列API标准；</p>
<p>POSIX兼容的程序可以在其他POSIX操作系统编译执行；</p>
<h5 id="（四）运行程序格式："><a href="#（四）运行程序格式：" class="headerlink" title="（四）运行程序格式："></a>（四）运行程序格式：</h5><p>Windows：EXE，.dll(dynamic link library)，.lib</p>
<p>Linux：ELF，.so(shared object)，.a</p>
<h4 id="三、用户和内核空间"><a href="#三、用户和内核空间" class="headerlink" title="三、用户和内核空间"></a>三、用户和内核空间</h4><h5 id="（一）用户空间：User-space"><a href="#（一）用户空间：User-space" class="headerlink" title="（一）用户空间：User space"></a>（一）用户空间：User space</h5><p>用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃，内核也不受影响；只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（system call），才能向内核发出指令。</p>
<h5 id="（二）内核空间：Kernel-space"><a href="#（二）内核空间：Kernel-space" class="headerlink" title="（二）内核空间：Kernel space"></a>（二）内核空间：Kernel space</h5><p>是Linux内核的运行空间；可以执行任意命令，调用系统的一切资源。</p>
<h4 id="四、Linux哲学思想"><a href="#四、Linux哲学思想" class="headerlink" title="四、Linux哲学思想"></a>四、Linux哲学思想</h4><p>1.一切都是一个文件（包括硬件）；</p>
<p>2.小型，单一用途的程序；</p>
<p>3.链接程序。共同完成复杂的任务；</p>
<p>4.避免令人困惑的用户界面；</p>
<p>5.配置数据存储在文本中。</p>
<h4 id="五、Linux文件与磁盘"><a href="#五、Linux文件与磁盘" class="headerlink" title="五、Linux文件与磁盘"></a>五、Linux文件与磁盘</h4><pre class="mermaid">graph TD
    B["/(根目录)"]
    B-->C(tmp);
    B-->D(usr);
    B-->E(etc-存放相关配置文件);
    B-->F(boot-启动文件);
    B-->G(bin-二进制程序);
    B-->H(...);</pre>

<h5 id="（一）挂载概念："><a href="#（一）挂载概念：" class="headerlink" title="（一）挂载概念："></a>（一）挂载概念：</h5><p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”（即通过访问目录名到其关联的分区），此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”。</p>
<h6 id="1-挂载"><a href="#1-挂载" class="headerlink" title="1.挂载"></a>1.挂载</h6><p>根文件系统外通过关联至根文件系统上的某个目录来实现访问；</p>
<h6 id="2-挂载点"><a href="#2-挂载点" class="headerlink" title="2.挂载点"></a>2.挂载点</h6><p>mount_point，用于作为另一个文件系统的访问入口：</p>
<ul>
<li>事先存在；</li>
<li>应该使用未被或不会被其它进程使用到的目录；</li>
<li>挂载点下原有的文件将会被隐藏； </li>
</ul>
<h4 id="六、什么是shell"><a href="#六、什么是shell" class="headerlink" title="六、什么是shell"></a>六、什么是shell</h4><ul>
<li>Shell是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行；</li>
<li>Shell也被称为Linux的命令解释器；</li>
<li>Shell是一种高级程序设计语言。</li>
</ul>
<h4 id="七、执行命令"><a href="#七、执行命令" class="headerlink" title="七、执行命令"></a>七、执行命令</h4><h5 id="（一）内部命令"><a href="#（一）内部命令" class="headerlink" title="（一）内部命令"></a>（一）内部命令</h5><p>由shell自带的，而且通过某命令形式提供</p>
<ul>
<li>help 内部命令列表；</li>
<li>enable cmd  启用内部命令；</li>
<li>enable -n cmd 禁用内部命令；</li>
<li>enable -n 查看所有禁用的内部命令；</li>
</ul>
<h5 id="（二）外部命令"><a href="#（二）外部命令" class="headerlink" title="（二）外部命令"></a>（二）外部命令</h5><p>在文件系统路径下有对应的可执行程序文件</p>
<ul>
<li>查看路径：which -a |—skip-alias；whereis；</li>
</ul>
<h5 id="（三）命令别名"><a href="#（三）命令别名" class="headerlink" title="（三）命令别名"></a>（三）命令别名</h5><p>显示当前shell进程所有可用的命令别名：alias</p>
<p>例如：将 “cd /etc/sysconfig/network-scripts/“ 用  “cdnet” 命令替代 </p>
<pre><code>#永久添加命令别名需更改相关配置文件,在文件中添加alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;
#仅对当前用户有效：~/.bashrc
#对所有用户有效：/etc/bashrc
[root@localhost ~]# nano .bashrc
 .bashrc

# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
</code></pre><ul>
<li>编辑配置给出的新配置不会立即生效</li>
<li>bash进程重新读取配置文件   .  /path/to/config_file</li>
<li>撤销别名：unalias</li>
<li>如果别名同原名令同名，执行原名令可使用 \ALIASNAME</li>
</ul>
<h4 id="八、文件系统"><a href="#八、文件系统" class="headerlink" title="八、文件系统"></a>八、文件系统</h4><p>1.文件和目录被组织成一个单根倒置树结构</p>
<p>2.文件系统从根目录下开始，用“/”表示</p>
<p>3.根文件系统（rootfs）：root filesystem</p>
<p>4.文件名称区分大小写</p>
<h4 id="九、把输出和错误重定向到文件"><a href="#九、把输出和错误重定向到文件" class="headerlink" title="九、把输出和错误重定向到文件"></a>九、把输出和错误重定向到文件</h4><p>1.STDOUT和STDERR可以被重定向到文件</p>
<p>命令  操作符号  文件名</p>
<p>支持的操作符号包括：&gt;  把STDOUT重定向到文件</p>
<p>​                                      2&gt;  把STDERR重定向到文件</p>
<p>​                                      &amp;&gt;  把STDOUT和STDERR一起重定向到文件</p>
<p>2.&gt; 文件内容会被覆盖</p>
<p>set -C  禁止将内容覆盖已有文件，但可追加</p>
<p>\&lt;| file  强制覆盖</p>
<p>set +C  允许覆盖</p>
<p>3.&lt;&lt; 原有内容基础上，追加内容 </p>
<h4 id="十、从文件中导入STDIN"><a href="#十、从文件中导入STDIN" class="headerlink" title="十、从文件中导入STDIN"></a>十、从文件中导入STDIN</h4><p>1.使用 &lt; 来重定向标准输入</p>
<p>2.某些命令能够接受从文件中导入的STDIN</p>
<pre><code>tr &#39;a-z&#39; &#39;A-Z&#39;&lt; /etc/issue
</code></pre><p>该命令会把/etc/issue中的小写字符都转换成大写字符</p>
<p>3.</p>
<pre><code>tr -d abc &lt; /etc/fstab
</code></pre><p>删除fstab文件中的所有abc中任意字符</p>
<p>4.使用 &gt; 来重定向标准输出</p>
<pre><code>cat &gt; file
mage
abc
</code></pre><p>按Ctrl+d离开，可以使用文件来代替键盘的输入</p>
<h4 id="十一、管道"><a href="#十一、管道" class="headerlink" title="十一、管道"></a>十一、管道</h4><p>管道（使用符号“|”表示）用来连接命令：命令1|命令2|命令3|…</p>
<ul>
<li>将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的TSDIN</li>
<li>STDERR默认不能通过管道转发，可利用2&gt;&amp;1或|&amp;实现</li>
<li>最后一个命令会在当前shell进程的子shell进程中执行</li>
<li>组合多种工具的功能</li>
</ul>
<pre><code>例：ls |tr &#39;a-z&#39; &#39;A-Z&#39;
</code></pre><pre><code>#将who指令的标准输出显示到屏幕的同时重定向追加到who.out文件
[root@localhost ~]# who | tee -a who.out
root     tty1         2020-03-09 17:51
root     pts/0        2020-03-11 00:37 (10.0.2.2)
[root@localhost ~]# cat who.out
root     tty1         2020-03-09 17:51
root     pts/0        2020-03-11 00:37 (10.0.2.2)
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PID算法学习</title>
    <url>/2020/03/05/pid-suan-fa-xue-xi/</url>
    <content><![CDATA[<h4 id="一、常规位式控制算法"><a href="#一、常规位式控制算法" class="headerlink" title="一、常规位式控制算法"></a>一、常规位式控制算法</h4><p><div id="flowchart-0" class="flow-chart"></div></p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.输出信号单一，一般只有两种状态：高电平和低电平；</p>
<p>2.常规位式算法输出信号OUT的依据：Pv &lt; Sv ——&gt; High、Pv &gt;= Sv ——&gt; Low；</p>
<p>3.只考虑控制对象当前的状态值。</p>
<a id="more"></a>
<h4 id="二、PID控制算法"><a href="#二、PID控制算法" class="headerlink" title="二、PID控制算法"></a>二、PID控制算法</h4><pre class="mermaid">graph LR;
　　用户设定-->|Sv|偏差E=Sv-Pv;
　　偏差E=Sv-Pv-->历史偏差;
　　偏差E=Sv-Pv-->当前偏差;
　　偏差E=Sv-Pv-->最近偏差;
　　历史偏差-->+;
　　当前偏差-->+;
　　最近偏差-->+;
　　+-->|OUT|可控硅;
　　220V-->可控硅;
　　可控硅-->负载;
　　220V-->负载;
　　负载-->传感器;
　　传感器-->|Pv当前值|偏差E=Sv-Pv;</pre>

<p>从开机以来，传感器的所有采样点的数据序列</p>
<script type="math/tex; mode=display">
x_1,x_2,x_3······x_{k-2},x_{k-1},x_k</script><p>历史偏差序列</p>
<script type="math/tex; mode=display">
E_1,E_2,E_3......E_{k-2},E_{k-1},E_k</script><script type="math/tex; mode=display">
E_k = S_v-x_k\left\{
\begin{array}{rcl}
>0       &      & {当前未达标}\\
=0    &      & {正好达标}\\
<0    &      & {当前已超标}
\end{array} \right.</script><h5 id="一-PID比例控制"><a href="#一-PID比例控制" class="headerlink" title="(一)PID比例控制"></a>(一)PID比例控制</h5><script type="math/tex; mode=display">
OUT=K_p*E_k</script><p>通过调整输出PWM的脉宽侧面调整负载的功率，根据当前偏差大小输出比例信号。</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>一旦传感器回来的信号与设定值相等，输出信号就等于零，负载处于失控状态，也就是说整个系统工作时总是存在误差。</p>
<script type="math/tex; mode=display">
P_{OUT}=K_p*E_k+OUT_0</script><h5 id="二-PID积分控制"><a href="#二-PID积分控制" class="headerlink" title="(二)PID积分控制"></a>(二)PID积分控制</h5><script type="math/tex; mode=display">
S_k=E_1+E_2+E_3......E_{k-2}+E_{k-1}+E_k\left\{
\begin{array}{rcl}
>0       &      & {过去的大多数时间未达标}\\
=0    &      & {}\\
<0    &      & {过去的大多数时间已超标}
\end{array} \right.</script><script type="math/tex; mode=display">
I_{OUT}=K_p*S_k+OUT_0</script><h5 id="三-PID微分控制"><a href="#三-PID微分控制" class="headerlink" title="(三)PID微分控制"></a>(三)PID微分控制</h5><p>将最近两次的偏差相减：</p>
<script type="math/tex; mode=display">
D_k=E_k-E_{k-1}\left\{
\begin{array}{rcl}
>0       &      & {偏差有增大的趋势}\\
=0    &      & {偏差不变}\\
<0    &      & {偏差有减小的趋势}
\end{array} \right.</script><script type="math/tex; mode=display">
D_{OUT}=k_p*D_k+OUT_0</script><h4 id="三、PID算法的数学模型"><a href="#三、PID算法的数学模型" class="headerlink" title="三、PID算法的数学模型"></a>三、PID算法的数学模型</h4><script type="math/tex; mode=display">
\begin{align}
PID_{OUT}&=P_{OUT}+I_{OUT}+D_{OUT} \\
&=(K_p*E_k+OUT_0)+(K_p*S_k+OUT_0)+(K_p*D_k+OUT_0) \\
&=K_p*(E_k+S_k+D_k)
\end{align}</script><h4 id="四、基于单片机的PID算法"><a href="#四、基于单片机的PID算法" class="headerlink" title="四、基于单片机的PID算法"></a>四、基于单片机的PID算法</h4><h5 id="1-Sk的处理"><a href="#1-Sk的处理" class="headerlink" title="1.Sk的处理"></a>1.S<sub>k</sub>的处理</h5><script type="math/tex; mode=display">
S_k=\frac{1}{T_i}\sum^{n}_{k=0}E_k*T</script><p>T：采样周期（计算周期）</p>
<p>T<sub>i</sub> ：积分常数（积分时间：I<sub>OUT</sub>和P<sub>OUT</sub>共同作用的时间）</p>
<p>由于积分项的存在，在输出值第一次达到设定值前偏差均为正数，累积后作用很大，会出现过冲现象。</p>
<h5 id="2-Dk的处理"><a href="#2-Dk的处理" class="headerlink" title="2.Dk的处理"></a>2.D<sub>k</sub>的处理</h5><script type="math/tex; mode=display">
D_k=T_d(\frac{E_k-E_{k-1}}{T})</script><p>T<sub>d</sub>：微分常数（P<sub>OUT</sub>和D<sub>OUT</sub>共同作用的时间）</p>
<h6 id="单片机中的PID算法表达式——位置式PID"><a href="#单片机中的PID算法表达式——位置式PID" class="headerlink" title="单片机中的PID算法表达式——位置式PID"></a>单片机中的PID算法表达式——位置式PID</h6><script type="math/tex; mode=display">
OUT=K_p*E_k+[K_p*(\frac{T}{T_i})*\sum^{n}_{k=0}E_k]+[K_p*(\frac{T_d}{T})*(E_k-E_{k-1})]+OUT_0</script><h6 id="增量式PID：计算出的是控制量的增加值"><a href="#增量式PID：计算出的是控制量的增加值" class="headerlink" title="增量式PID：计算出的是控制量的增加值"></a>增量式PID：计算出的是控制量的增加值</h6><script type="math/tex; mode=display">
\begin{align}
\Delta OUT&=OUT_k-OUT_{k-1}\\
&=K_p*(E_k-E_{k-1})+K_p*\frac{T}{T_i}*E_k+K_p*\frac{T_d}{T}*(E_k-2E_{k-1}+E_{k-2})
\end{align}</script><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 用户设置Sv
e=>end: End:>http://www.google.com
op1=>operation: 位式控制算法输出out
op2=>operation: 执行部件|current
op3=>operation: 控制对象（具有一定惯性）
op4=>operation: 传感器输出当前值Pv

st->op1(right)->op2(right)->op3->op4(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY矩阵灯</title>
    <url>/2019/10/18/diy-ju-zhen-deng/</url>
    <content><![CDATA[<h4 id="用树莓派或Arduino制造LED矩阵彩灯"><a href="#用树莓派或Arduino制造LED矩阵彩灯" class="headerlink" title="用树莓派或Arduino制造LED矩阵彩灯"></a>用树莓派或Arduino制造LED矩阵彩灯</h4><p>笔者在树莓派网站发现了个简单有意思的DIY的小玩意，就自己动手做了一个，于此分享一下，点击下方 ↓ 链接即可了解相关内容：</p>
<a id="more"></a>
<p><a href="https://shumeipai.nxez.com/2019/04/10/led-matrix-cylinder.html" target="_blank" rel="noopener">树莓派实验室</a></p>
<p><a href="https://tutorials-raspberrypi.com/connect-control-raspberry-pi-ws2812-rgb-led-strips/" target="_blank" rel="noopener">树莓派连接并控制SW2812 RGB LED</a></p>
<p>这是笔者做的成品图片，将外壳由原帖的木质贴面改为3D打印的光敏树脂，效果也不错，顶盖是用切割剩下的椴木板所裁成的</p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片1.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片2.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片3.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片4.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片5.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片6.png" alt></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx应用监控</title>
    <url>/2019/08/27/nginx-ying-yong-jian-kong/</url>
    <content><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，同时也提供了IMAP/POP3/SMTP服务，是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3)代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上其并发能力确实在同类型的网页服务器中表现较好。</p>
<a id="more"></a>
<h4 id="一、安装Nginx"><a href="#一、安装Nginx" class="headerlink" title="一、安装Nginx"></a>一、安装Nginx</h4><pre><code>#安装Nginx所需的依赖
[root@localhost ~]# yum install -y gcc glibc gcc-c++ pcre-devel openssl-devel
#安装Nginx
[root@localhost ~]# cd /usr/local/src
[root@localhost src]# wget http://nginx.org/download/nginx-1.16.1.tar.gz
#解压
[root@localhost src]# tar zxf nginx-1.16.1.tar.gz
[root@localhost src]# ls
nginx-1.16.1  nginx-1.16.1.tar.gz
#查看相关文件
[root@localhost src]# cd nginx-1.16.1
[root@localhost nginx-1.16.1]# ls
auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  man  README  src
</code></pre><p>注：configure是Shell脚本，执行它的作用是生成Makefile（使用Make工具编译C程序，而Make工具需要依赖Makefile）</p>
<pre><code>#创建用户
[root@localhost nginx-1.16.1]# useradd -s /sbin/nologin -M www
#执行脚本
[root@localhost nginx-1.16.1]# ./configure --prefix=/usr/local/ngnix-1.16.1 --user=www --group=www --with-http_ssl_module --with-http_stub_status_module
#之后再查看目录下文件会发现Makefile文件
</code></pre><pre><code>#编译并将生成的文件拷贝到指定的地方
[root@localhost nginx-1.16.1]# make &amp;&amp; make install
#创建软链接
[root@localhost nginx-1.16.1]# cd
[root@localhost ~]# ln -s /usr/local/ngnix-1.16.1/ /usr/local/ngnix
</code></pre><h4 id="二、启动Ngnix服务"><a href="#二、启动Ngnix服务" class="headerlink" title="二、启动Ngnix服务"></a>二、启动Ngnix服务</h4><pre><code>#查看86端口有没有被占用
[root@localhost ~]# netstat -ntlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1178/sshd           
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1281/master         
tcp6       0      0 :::22                   :::*                    LISTEN      1178/sshd           
tcp6       0      0 ::1:25                  :::*                    LISTEN      1281/master 
#启动服务前测试文件
[root@localhost ~]# /usr/local/ngnix/sbin/nginx -t
nginx: the configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf test is successful
#启动服务
[root@localhost ~]# /usr/local/ngnix/sbin/nginx
</code></pre><h4 id="三、配置Nginx"><a href="#三、配置Nginx" class="headerlink" title="三、配置Nginx"></a>三、配置Nginx</h4><pre><code>[root@localhost ~]# cd /usr/local/ngnix/conf/
[root@localhost conf]# vim nginx.conf
...
#在一个服务后加nginx-status
server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location /nginx-status {
            stub_status on;
            access_log  off;
            allow 172.16.137.0/24;
            deny all;
        }
...
#保存后检测文件是否出错
[root@localhost conf]# /usr/local/ngnix/sbin/nginx -t
nginx: the configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf test is successful
# 重启服务
[root@localhost conf]# /usr/local/ngnix/sbin/nginx -s reload
#访问
[root@localhost conf]# curl 172.16.137.128/nginx-status
Active connections: 1 
server accepts handled requests
 2 2 2 
Reading: 0 Writing: 1 Waiting: 0 
#活动链接数1
#成功创建链接次数2  成功创建握手次数2  成功的请求次数2
#当前读取的客户端header的数量0  当前返回给客户端header的数量1  长链接状态下已经处理等待下一次请求的值0
</code></pre><p>在本机浏览器也可访问，如图所示：</p>
<p><img src="/2019/08/27/nginx-ying-yong-jian-kong/图片一.png" alt></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机使用VMware tools与主机共享文件</title>
    <url>/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/</url>
    <content><![CDATA[<h4 id="一、VMware-Tools介绍"><a href="#一、VMware-Tools介绍" class="headerlink" title="一、VMware Tools介绍"></a>一、VMware Tools介绍</h4><p>VMware Tools是VMware虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是VMware提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。</p>
<a id="more"></a>
<p>只有在VMware虚拟机中安装好了VMware Tools，才能实现主机与虚拟机之间的文件共享，同时可支持自由拖拽的功能，鼠标也可在虚拟机与主机之间自由移动（不用再按ctrl+alt），且虚拟机屏幕也可实现全屏化。</p>
<h4 id="二、安装VMware-Tools"><a href="#二、安装VMware-Tools" class="headerlink" title="二、安装VMware Tools"></a>二、安装VMware Tools</h4><p>1.选择虚拟机界面左上角的虚拟机—&gt;重新安装VMware Tools选项。</p>
<p>2.进入CentOS系统</p>
<pre><code>#挂载CD
[root@localhost ~]# mount /dev/cdrom /media
mount: /dev/sr0 写保护，将以只读方式挂载

#查看安装的VMwareTools版本
[root@localhost ~]# cd /media
[root@localhost media]# ls
manifest.txt     VMwareTools-10.3.10-12406962.tar.gz  vmware-tools-upgrader-64
run_upgrader.sh  vmware-tools-upgrader-32

#将安装文件拷贝、解压
[root@localhost media]# cp /media/VMwareTools-10.3.10-12406962.tar.gz /tmp/
[root@localhost media]# cd /tmp
[root@localhost tmp]# tar -zxf VMwareTools-10.3.10-12406962.tar.gz

#安装
[root@localhost tmp]# cd vmware-tools-distrib/
[root@localhost vmware-tools-distrib]# ./vmware-install.pl
#之后一路回车，即可安装完毕
</code></pre><p>3.安装可能会出现内核位置不确定的问题</p>
<pre><code>The path &quot;&quot; is not a valid path to the 3.10.0-957.el7.x86_64 kernel headers.
Would you like to change it? [yes] 

INPUT: [yes]  default

Enter the path to the kernel header files for the 3.10.0-957.el7.x86_64 
kernel? 

INPUT: []  default
</code></pre><p>解决方法为指定版本重新安装内核</p>
<pre><code>[root@localhost vmware-tools-distrib]# yum install &quot;kernel-devel-uname-r == $(uname -r)&quot;
#然后重新安装
[root@localhost vmware-tools-distrib]# ./vmware-install.pl
</code></pre><h4 id="三、使用VMware-Tools共享文件"><a href="#三、使用VMware-Tools共享文件" class="headerlink" title="三、使用VMware Tools共享文件"></a>三、使用VMware Tools共享文件</h4><p>在主机新建一个文件夹存放于虚拟机共享的文件</p>
<p>在虚拟机界面设置中启用共享文件夹，然后将新建的共享文件夹添加进去</p>
<p><img src="/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/图片一.png" alt></p>
<p>在主机文件夹中新建一个test.txt文件</p>
<p><img src="/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/图片二.png" alt></p>
<p>在虚拟机中查看</p>
<pre><code>[root@localhost ~]# cd /mnt/hgfs/虚拟机共享
[root@localhost 虚拟机共享]# ls
test.txt
</code></pre>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>多维监控体系</title>
    <url>/2019/08/22/duo-wei-jian-kong-ti-xi/</url>
    <content><![CDATA[<h4 id="一、监控概述"><a href="#一、监控概述" class="headerlink" title="一、监控概述"></a>一、监控概述</h4><h6 id="一、监控对象："><a href="#一、监控对象：" class="headerlink" title="一、监控对象："></a>一、监控对象：</h6><p>1.监控对象的理解：CPU是怎么工作的，以及工作原理；<br>2.监控对象的指标：CPU的使用率、CPU的负载、CPU个数;<br>3.确定性能基准线：怎么样才算故障？CPU负载多少算高？</p>
<a id="more"></a>
<h6 id="二、监控范围："><a href="#二、监控范围：" class="headerlink" title="二、监控范围："></a>二、监控范围：</h6><p>1.硬件监控：服务器的硬件故障；<br>2.操作系统监控：CPU、内存、IO、进程；<br>3.应用服务监控；<br>4.业务监控。</p>
<h4 id="二、硬件监控"><a href="#二、硬件监控" class="headerlink" title="二、硬件监控"></a>二、硬件监控</h4><h6 id="一、服务器监控：IPMI"><a href="#一、服务器监控：IPMI" class="headerlink" title="一、服务器监控：IPMI"></a>一、服务器监控：IPMI</h6><p>IPMI是一种智能化远程接口标准，Linux就可以使用IPMI实现对服务器的远程监控，IPMI依赖于BMC控制器（一种嵌入式微控制器），</p>
<p>使用ipmitool实现在Linux下对硬件的监控和控制。</p>
<p>使用ipmitool的条件：硬件和操作系统要支持。（虚拟机无法执行IPMI，可在物理机尝试，不执行关机命令即可）</p>
<pre><code>#安装工具
[root@localhost ~]# yum install -y OpenIPMI ipmitool
#启动
[root@localhost ~]# systemctl start ipmi
</code></pre><p>使用IPMI有两种方式：1.本地调用；2.远程调用（通过IP地址，用户名和密码）</p>
<h6 id="二、路由器和交换机监控：SNMP"><a href="#二、路由器和交换机监控：SNMP" class="headerlink" title="二、路由器和交换机监控：SNMP"></a>二、路由器和交换机监控：SNMP</h6><pre><code>[root@localhost ~]# yum install -y net-snmp net-snmp-utils
[root@localhost ~]# cd /etc/snmp
[root@localhost snmp]# ls
snmpd.conf  snmptrapd.conf
[root@localhost snmp]# mv snmpd.conf snmpd.conf.bak
[root@localhost snmp]# vim snmpd.conf
#添加如下内容
rocommunity zzulyt（名称，自己起的团体名） 172.16.137.128（指要收集的机器的IP）
[root@localhost snmp]# ll
总用量 28
-rw-r--r-- 1 root root    34 8月  19 20:08 snmpd.conf
-rw------- 1 root root 18861 7月  30 01:29 snmpd.conf.bak
-rw------- 1 root root   220 7月  30 01:29 snmptrapd.conf
#启动服务
[root@localhost snmp]# systemctl start snmpd
#查看snmp监听的161端口
[root@localhost snmp]# netstat -nulp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
udp        0      0 0.0.0.0:69              0.0.0.0:*                           917/xinetd          
udp        0      0 0.0.0.0:161             0.0.0.0:*                           2711/snmpd
</code></pre><h4 id="三、SNMP系统的管理信息库（MIB）与OID"><a href="#三、SNMP系统的管理信息库（MIB）与OID" class="headerlink" title="三、SNMP系统的管理信息库（MIB）与OID"></a>三、SNMP系统的管理信息库（MIB）与OID</h4><p> 1.任何一个被管理的资源都表示成一个对象，称为被管理的对象。MIB是被管理对象的集合。它定义了被管理对象的一系列属性：对象的名称、对象的访问权限和对象的数据类型等。每个SNMP设备（Agent）都有自己的MIB。MIB也可以看作是NMS（网管系统）和Agent之间的沟通桥梁。它们之间的关系如图所示：</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片一.png" alt></p>
<p> 2.MIB文件中的变量使用的名字取自ISO和ITU管理的对象标识符（object identifier）名字空间。它是一种分级树的结构。</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片二.png" alt></p>
<p> 3.OID(对象标识符)：是SNMP代理提供的具有唯一标识的键值。【MIB（管理信息基）提供数字化OID到可读文本的映射】。</p>
<p>OID可用数字格式表达：<br>长这样“.1.3.6.1.2.1.1.2.0”  子树 1 -&gt; 3 -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 1 -&gt; 1 -&gt; 2</p>
<pre><code>#OID:1.3.6.1.2.1.1.3.0--&gt;监控时间
[root@localhost snmp]# snmpget -v2c -c zzulyt 172.16.137.128 1.3.6.1.2.1.1.3.0
DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (28036) 0:04:40.36
#OID:1.3.6.1.4.1.2021.10.1.3.1--&gt;Load 5
[root@localhost snmp]# snmpget -v2c -c zzulyt 172.16.137.128 1.3.6.1.4.1.2021.10.1.3.1
UCD-SNMP-MIB::laLoad.1 = STRING: 0.01
</code></pre><h4 id="四、CPU监控"><a href="#四、CPU监控" class="headerlink" title="四、CPU监控"></a>四、CPU监控</h4><h5 id="1-CPU三个重要的概念"><a href="#1-CPU三个重要的概念" class="headerlink" title="1.CPU三个重要的概念"></a>1.CPU三个重要的概念</h5><p>上下文切换：CPU调度器实施的进程的切换过程；</p>
<p>运行队列（负载）：负载可以理解为运行队列里单位时间内的排队线程的平均数，（负载只是一个参考值，负载高未必系统繁忙）；</p>
<p>使用率：指运行的程序占用的CPU资源，表示你的机器在某个时间点的运行程序的情况。</p>
<h5 id="2-确定服务类型"><a href="#2-确定服务类型" class="headerlink" title="2.确定服务类型"></a>2.确定服务类型</h5><p>IO密集型——数据库<br>CPU密集型——web、mail</p>
<h5 id="3-确定性能基准线"><a href="#3-确定性能基准线" class="headerlink" title="3.确定性能基准线"></a>3.确定性能基准线</h5><p>运行队列：1-3线程；1CPU；4核；负载不超过12（经验值）</p>
<p>CPU使用：65%-70%的用户态利用率<br>                   30%-35%的内核利用率<br>                   0%-5%的空闲利用率</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片三.png" alt></p>
<h5 id="4-监控工具"><a href="#4-监控工具" class="headerlink" title="4.监控工具"></a>4.监控工具</h5><p>（1）top</p>
<pre><code>[root@localhost ~]# top
top - 13:09:07 up 17:02,  3 users,  load average: 0.04, 0.03, 0.05
Tasks: 105 total,   1 running, 104 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :   999696 total,   145684 free,   161652 used,   692360 buff/cache
KiB Swap:  2097148 total,  2095184 free,     1964 used.   659484 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                    
     1 root      20   0  125364   3404   2092 S  0.0  0.3   0:09.59 systemd                                    
     2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd                                   
     3 root      20   0       0      0      0 S  0.0  0.0   0:01.58 ksoftirqd/0                                
     5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H                               
     7 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0                                
     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh                                     
     9 root      20   0       0      0      0 S  0.0  0.0   0:04.28 rcu_sched                                  
    10 root      rt   0       0      0      0 S  0.0  0.0   0:00.82 watchdog/0
</code></pre><p>top命令中       P—&gt;按CPU使用率排序<br>                         M—&gt;按内存使用率排序</p>
<p>（2）安装sysstat，使用vmstat或mpstat工具</p>
<pre><code>[root@localhost ~]# yum install -y sysstat
#每一秒显示一次监控信息，显示10次
[root@localhost ~]# vmstat 1 10
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0   1964 141160      0 696360    0    0    16    15   51   49  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   76   83  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   85   92  1  0 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   92   90  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   96   96  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   89   90  0  1 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   88   84  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   82   81  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0  106  110  0  1 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   83   79  0  0 100  0  0
#每一秒显示一次监控信息，显示5次 
[root@localhost ~]# mpstat 1 5
Linux 3.10.0-693.el7.x86_64 (localhost.localdomain)     2019年08月22日     _x86_64_    (1 CPU)

13时56分36秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13时56分37秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分38秒  all    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00
13时56分39秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分40秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分41秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间:  all    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
</code></pre><h4 id="五、内存监控"><a href="#五、内存监控" class="headerlink" title="五、内存监控"></a>五、内存监控</h4><h5 id="vmstat显示的参数说明"><a href="#vmstat显示的参数说明" class="headerlink" title="vmstat显示的参数说明"></a>vmstat显示的参数说明</h5><p>swpd:已使用的交换分区的大小<br>free：可用的物理内存的大小<br>si：从磁盘交换到内存的交换页数量，单位：KB/秒<br>so：从内存交换到磁盘的交换页数量，单位：KB/秒<br>bi：每秒从块设备接收到的块数，单位：块/秒 也就是读块设备<br>bo：每秒发送到块设备的块数，单位：块/秒  也就是写块设备<br>in：每秒的中断数，包括时钟中断。与cs一般同步增长。in和cs两值越大，会看到由内核消耗的CPU时间（sy）也会越大<br>cs：每秒的环境（上下文）切换次数<br>us：用户CPU时间(非内核进程占用时间)（单位为百分比）。 us的值比较高时，说明用户进程消耗的CPU时间多<br>sy：系统使用的CPU时间（单位为百分比）。sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。<br>id：空闲的CPU的时间(百分比)，在Linux 2.5.41之前，这部分包含IO等待时间。<br>wa：等待IO的CPU时间，在Linux 2.5.41之前，这个值为0 .这个指标意味着CPU在等待硬盘读写操作的时间，用百分比表示。wait越大则机器io性能就越差。说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）<br>st：针对虚拟技术，如果st不为0，说明本来分配给本机的CPU时间被其他虚拟机偷走了</p>
<h4 id="六、系统监控"><a href="#六、系统监控" class="headerlink" title="六、系统监控"></a>六、系统监控</h4><h5 id="一、硬盘监控"><a href="#一、硬盘监控" class="headerlink" title="一、硬盘监控"></a>一、硬盘监控</h5><p>通过iotop工具监控硬盘</p>
<pre><code>[root@localhost ~]# yum install iotop
[root@localhost ~]# iotop
Total DISK READ :    0.00 B/s | Total DISK WRITE :       0.00 B/s
Actual DISK READ:    0.00 B/s | Actual DISK WRITE:       0.00 B/s
......
</code></pre><h5 id="二、网络监控"><a href="#二、网络监控" class="headerlink" title="二、网络监控"></a>二、网络监控</h5><p>通过iftop监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等。</p>
<pre><code>[root@localhost ~]# yum install iftop
[root@localhost ~]# iftop -n
</code></pre><p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片四.png" alt></p>
<h5 id="三、利用nmon监控并分析数据"><a href="#三、利用nmon监控并分析数据" class="headerlink" title="三、利用nmon监控并分析数据"></a>三、利用nmon监控并分析数据</h5><p>1.去官网下载nmon的二进制文件</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片五.png" alt></p>
<p>2.将文件共享给虚拟机的系统</p>
<pre><code>[root@localhost ~]# cd /mnt/hgfs/虚拟机共享
[root@localhost 虚拟机共享]# chmod +x nmon16e_x86_rhel71
[root@localhost 虚拟机共享]# ./nmon16e_x86_rhel71
</code></pre><p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片六.png" alt></p>
<p>3.主机下载nomn_analyzer</p>
<p>下载后的文件夹里包含：</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片七.png" alt></p>
<p>4.将检测结果生成Excel文件</p>
<p>在虚拟机系统中输入监控并将结果生成文件的命令</p>
<pre><code>[root@localhost 虚拟机共享]# ./nmon16e_x86_rhel71 -c 10 -s 10 -f
#检查发现多了一个nmon文件，190826表示年月日，1542表示时分
[root@localhost 虚拟机共享]# ls
localhost_190826_1542.nmon  nmon16e_x86_rhel71
</code></pre><p>在主机打开nomn_analyzer文件夹中的nmon analyser v61文件，点击Analyze nmon data</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片八.png" alt></p>
<p>选择共享文件夹中的nmon文件，即可生成图表</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片九.png" alt></p>
<p>（底部的表格栏即为监控的参数名称）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware中centos在NAT模式下配置静态IP</title>
    <url>/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/</url>
    <content><![CDATA[<h4 id="一、VMware的配置"><a href="#一、VMware的配置" class="headerlink" title="一、VMware的配置"></a>一、VMware的配置</h4><p>1.虚拟机设置中网络适配器设置为NAT模式</p>
<a id="more"></a>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片1.png" alt></p>
<p>2.点击左上角的编辑—&gt;虚拟网络编辑器，win10系统下更改需要管理员权限</p>
<p>取消DHCP前的对号，然后进入NAT设置，记下子网IP、子网掩码和网关</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片2.png" alt></p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片3.png" alt></p>
<h4 id="二、查看本机VMnet8网段（虚拟机网关与VMnet8-ip必须要在同一网段）"><a href="#二、查看本机VMnet8网段（虚拟机网关与VMnet8-ip必须要在同一网段）" class="headerlink" title="二、查看本机VMnet8网段（虚拟机网关与VMnet8 ip必须要在同一网段）"></a>二、查看本机VMnet8网段（虚拟机网关与VMnet8 ip必须要在同一网段）</h4><p>在cmd命令行下，输入ipconfig查看</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片4.png" alt></p>
<h4 id="三、配置CentOS7相关文件"><a href="#三、配置CentOS7相关文件" class="headerlink" title="三、配置CentOS7相关文件"></a>三、配置CentOS7相关文件</h4><p>1.修改配置文件</p>
<pre><code>[root@localhost ~]# cd /etc/sysconfig/network-scripts
#先查看该目录下相关配置文件名称，有的是ifcfg-ent0,有的是ifcfg-ens33
[root@localhost network-scripts]# vim ifcfg-ens33
TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
BOOTPROTO=&quot;dhcp&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;7d2dd01c-42fc-4ab6-857b-394690430e9f&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
</code></pre><p>在文件底部添加</p>
<pre><code>NM_CONTROLLED=no
BOOTPROTO=static #设置为静态
IPADDR=172.16.137.128 #自己选择的IP，遵循网络段设置0-255任取
NETMASK=255.255.255.0 #子网掩码，在VMware里看到的
GATEWAY=172.16.137.2 #网关，在NAT设置里看到的
DNS1=172.16.137.2
</code></pre><p>保存退出</p>
<p>2.查看网关</p>
<pre><code>[root@localhost ~]# cd /etc
[root@localhost etc]# cat resolv.conf
# Generated by NetworkManager
search localdomain
nameserver 172.16.137.2 #查看网关是否一致
</code></pre><p>3.重启网络服务</p>
<pre><code>[root@localhost ~]# service network restart
</code></pre><p>4.查看IP，并ping外网测试</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片5.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>cobbler部署并自动化安装系统</title>
    <url>/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/</url>
    <content><![CDATA[<h4 id="一、安装部署"><a href="#一、安装部署" class="headerlink" title="一、安装部署"></a>一、安装部署</h4><p>1.可以去阿里巴巴开源镜像站寻找所需镜像源（epel—&gt;epel-release-latest-7.noarch.rpm），复制其链接</p>
<a id="more"></a>
<pre><code>[root@localhost ~]# rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
</code></pre><p>2.安装所需软件包</p>
<pre><code>[root@localhost ~]# yum install -y httpd dhcp tftp cobbler cobbler-web pykickstart
[root@localhost kickstarts]# yum install xinetd -y
</code></pre><p>3.查看安装情况</p>
<pre><code>[root@localhost ~]# cd /etc/httpd/conf.d/
#可看到cobbler的相关文件
[root@localhost conf.d]# ll
总用量 36
-rw-r--r--. 1 root root 2926 7月  30 01:18 autoindex.conf
-rw-r--r--. 1 root root 1087 11月 27 2018 cobbler.conf
-rw-r--r--. 1 root root 1165 11月 27 2018 cobbler_web.conf
-rw-r--r--. 1 root root  366 7月  30 01:19 README
-rw-r--r--. 1 root root 9443 7月  29 23:15 ssl.conf
-rw-r--r--. 1 root root 1252 7月  29 23:15 userdir.conf
-rw-r--r--. 1 root root  824 7月  29 23:15 welcome.conf
</code></pre><h4 id="二、启动进程"><a href="#二、启动进程" class="headerlink" title="二、启动进程"></a>二、启动进程</h4><pre><code>[root@localhost ~]# systemctl start httpd
[root@localhost ~]# systemctl start cobblerd
[root@localhost kickstarts]# systemctl start xinetd
[root@localhost ~]# cobbler check
</code></pre><p>新装的系统在运行cobbler check命令后会报错，如图所示</p>
<p><img src="/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/图片一.png" alt></p>
<p>解决方法如下：</p>
<pre><code>[root@localhost ~]# getenforce
Enforcing
[root@localhost ~]# setenforce 0
[root@localhost ~]# getenforce
Permissive
[root@localhost ~]# service httpd restart
Redirecting to /bin/systemctl restart httpd.service
</code></pre><p>再次查看，所列条数便是接下来的需要做的配置步骤</p>
<pre><code>[root@localhost ~]# cobbler check
The following are potential configuration items that you may want to fix:

1 : The &#39;server&#39; field in /etc/cobbler/settings must be set to something other than localhost, or kickstarting features will not work.  This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it.
2 : For PXE to be functional, the &#39;next_server&#39; field in /etc/cobbler/settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.
3 : SELinux is enabled. Please review the following wiki page for details on ensuring cobbler works correctly in your SELinux environment:
    https://github.com/cobbler/cobbler/wiki/Selinux
4 : change &#39;disable&#39; to &#39;no&#39; in /etc/xinetd.d/tftp
5 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run &#39;cobbler get-loaders&#39; to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The &#39;cobbler get-loaders&#39; command is the easiest way to resolve these requirements.
6 : enable and start rsyncd.service with systemctl
7 : debmirror package is not installed, it will be required to manage debian deployments and repositories
8 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to &#39;cobbler&#39; and should be changed, try: &quot;openssl passwd -1 -salt &#39;random-phrase-here&#39; &#39;your-password-here&#39;&quot; to generate new one
9 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them

Restart cobblerd and then run &#39;cobbler sync&#39; to apply changes.
</code></pre><h4 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h4><p>1.更改vim etc/cobbler/settings文件中的server，将其改成自己的IP</p>
<pre><code>[root@localhost ~]# vim /etc/cobbler/settings
#需要更改的部分在文件的第272行和384行
</code></pre><p>2.将文件中的disable原来的yes改为no</p>
<pre><code>[root@localhost ~]# vim /etc/xinetd.d/tftp

# default: off
# description: The tftp server serves files using the trivial file transfer \
#       protocol.  The tftp protocol is often used to boot diskless \
#       workstations, download configuration files to network-aware printers, \
#       and to start the installation process for some operating systems.
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
}
</code></pre><p>3.开启进程，使文件生效</p>
<pre><code>[root@localhost ~]# systemctl start rsyncd
[root@localhost ~]# cobbler get-loaders
</code></pre><p>4.设置密码</p>
<pre><code>#命令格式：
[root@localhost ~]# openssl passwd -1 -salt &#39;random-phrase-here&#39; &#39;your-password-here&#39;
#将密码部分填入，命令即可为：
[root@localhost ~]# openssl passwd -1 -salt &#39;cobler&#39; &#39;cobler&#39;
#将生成的密码全部复制下来
$1$cobler$XJnisBweZJlhL651HxAM00
[root@localhost ~]# vim /etc/cobbler/settings
#将密码粘贴到文件的第101行
101 default_password_crypted: &quot;$1$cobler$XJnisBweZJlhL651HxAM00&quot;
#242行的0改为1
242 manage_dhcp: 1
[root@localhost ~]# systemctl restart cobblerd
[root@localhost ~]# cobbler check
</code></pre><p>5.配置dhcp文件</p>
<pre><code>[root@localhost ~]# vim /etc/cobbler/dhcp.template
#将自己服务器的子网，网关，DNS改入
subnet 10.0.2.0 netmask 255.255.255.0 {
     option routers             10.0.2.15;
     option domain-name-servers 10.0.2.15;
     option subnet-mask         255.255.255.0;
     range dynamic-bootp        10.0.2.100 10.0.2.254;
     default-lease-time         21600;
     max-lease-time             43200;
     next-server                $next_server;
     class &quot;pxeclients&quot; {
          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;
#保存后重启服务，使之生效
[root@localhost ~]# systemctl restart cobblerd
[root@localhost ~]# cobbler sync
#可查看更改是否生效
[root@localhost ~]# cat /etc/dhcp/dhcpd.conf
subnet 10.0.2.0 netmask 255.255.255.0 {
     option routers             10.0.2.15;
     option domain-name-servers 10.0.2.15;
     option subnet-mask         255.255.255.0;
     range dynamic-bootp        10.0.2.100 10.0.2.254;
     default-lease-time         21600;
     max-lease-time             43200;
     next-server                10.0.2.15;
</code></pre><h4 id="四、配置kickstart相关服务"><a href="#四、配置kickstart相关服务" class="headerlink" title="四、配置kickstart相关服务"></a>四、配置kickstart相关服务</h4><p>1.磁盘挂载</p>
<pre><code>[root@localhost ~]# mount /dev/cdrom /mnt
mount: /dev/sr0 写保护，将以只读方式挂载
（挂载光盘）
#此步骤要等待一段时间
[root@localhost ~]# cobbler import --path=/mnt/ --name=CentOS-7-x86_64 --arch=x86_64
task started: 2019-08-12_212801_import
task started (id=Media import, time=Mon Aug 12 21:28:01 2019)
Found a candidate signature: breed=redhat, version=rhel6
Found a candidate signature: breed=redhat, version=rhel7
Found a matching signature: breed=redhat, version=rhel7
Adding distros from path /var/www/cobbler/ks_mirror/CentOS-7-x86_64:
creating new distro: CentOS-7-x86_64
trying symlink: /var/www/cobbler/ks_mirror/CentOS-7-x86_64 -&gt; /var/www/cobbler/links/CentOS-7-x86_64
creating new profile: CentOS-7-x86_64
associating repos
checking for rsync repo(s)
checking for rhn repo(s)
checking for yum repo(s)
starting descent into /var/www/cobbler/ks_mirror/CentOS-7-x86_64 for CentOS-7-x86_64
processing repo at : /var/www/cobbler/ks_mirror/CentOS-7-x86_64
need to process repo/comps: /var/www/cobbler/ks_mirror/CentOS-7-x86_64
looking for /var/www/cobbler/ks_mirror/CentOS-7-x86_64/repodata/*comps*.xml
Keeping repodata as-is :/var/www/cobbler/ks_mirror/CentOS-7-x86_64/repodata
*** TASK COMPLETE ***
</code></pre><p>2.可查看完成情况，可发现清单已出现 CentOS-7-x86_64</p>
<pre><code>[root@localhost ~]# cobbler profile list
   CentOS-7-x86_64
</code></pre><p>3.使用自己的kickstarts文件</p>
<pre><code>[root@localhost ~]# cd /var/lib/cobbler/kickstarts
[root@localhost kickstarts]# vim CentOS-7-x86_64.cfg
#将如下内容添至文件中
install
url --url=$tree  
text
lang en_US.UTF-8
keyboard us
zerombr
bootloader --location=mbr 
# Network information
$SNIPPET(&#39;network_config&#39;)
timezone --utc Asia/Shanghai
authconfig --enableshadow --passalgo=sha512
rootpw  --iscrypted $default_password_crypted
clearpart --all --initlabel
part /boot --fstype xfs --size 500  
part swap --size 2000
part / --fstype xfs --size 20000 
part /data --fstype xfs --size 30000 
firstboot --disable
selinux --disabled
firewall --disabled
logging --level=info
reboot
%pre
$SNIPPET(&#39;log_ks_pre&#39;)
$SNIPPET(&#39;kickstart_start&#39;)
$SNIPPET(&#39;pre_install_network_config&#39;)
# Enable installation monitoring
$SNIPPET(&#39;pre_anamon&#39;)
%end
%packages
@base
@compat-libraries
@debugging
@development
tree
nmap
sysstat
lrzsz
dos2unix
telnet
iptraf
ncurses-devel
openssl-devel
zlib-devel
OpenIPMI-tools
screen
%end
%post
systemctl disable postfix.service
%end
#保存后配置路径，如下指令
[root@localhost kickstarts]# cobbler profile edit --name=CentOS-7-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
</code></pre><p>4.CentOS7系统安装时使网卡为eth0需要加内核参数，可通过profile加内核参数</p>
<pre><code>[root@localhost kickstarts]# cobbler profile edit --name=CentOS-7-x86_64 --kopts=&#39;net.ifnames=0 biosdevname=0&#39;
[root@localhost kickstarts]# cobbler profile report
[root@localhost kickstarts]# cobbler sync
#以上命令使输出时清空重新生成一遍，使文件生效
[root@localhost kickstarts]# start xinetd
#开启tftp服务，如果自动安装时进程卡在tftp，可以尝试关闭防火墙
</code></pre><h4 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h4><p>1.VMvare上直接新建一个虚拟机，进入后选择相应系统即可自动安装</p>
<p><img src="/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/图片二.png" alt></p>
<p>2.Virtualbox上则先需在管理&gt;&gt;主机网络管理器中，禁止启用DHCP服务，避免发生重复，之后即可新建，启动后自动安装系统。</p>
<h4 id="六、自动化重装"><a href="#六、自动化重装" class="headerlink" title="六、自动化重装"></a>六、自动化重装</h4><pre><code>#使用该工具实现自动化重装
[root@localhost ~]# yum install -y koan
#查看该服务器下可以重装的系统
[root@localhost ~]# koan --server=10.0.2.15 --list=profiles
- looking for Cobbler at http://10.0.2.15:80/cobbler_api
CentOS-7-x86_64
#--profile后指定想重装成的系统
[root@localhost ~]# koan --replace-self --server=10.0.2.15 --profile=CentOS-7-x86_64
</code></pre><p>重启即可将现系统重装为设定系统</p>
<h4 id="七、自定义yum源"><a href="#七、自定义yum源" class="headerlink" title="七、自定义yum源"></a>七、自定义yum源</h4><pre><code>#启动相关服务
[root@localhost ~]# systemctl start httpd.service 
[root@localhost ~]# systemctl start cobblerd.service
#添加源
[root@localhost ~]# cobbler repo add --name=openstack-mitaka --mirror=https://mirrors.aliyun.com/centos/7.6.1810/cloud/x86_64/openstack-stein/ --arch=x86_64 --breed=yum
#进行同步
[root@localhost ~]# cobbler reposync
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下PXE+Kickstart+DHCP+TFTP+HTTP无人值守安装系统</title>
    <url>/2019/08/11/zi-dong-hua-yun-wei/</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="（一）什么是PXE"><a href="#（一）什么是PXE" class="headerlink" title="（一）什么是PXE"></a>（一）什么是PXE</h5><p>​        PXE(Pre boot Execution Environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP ( trivial file transfer protocol )或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机，内存中执行，由这个启动软件包完成终端基本软件设置，从而引导预先安装在服务器中的终端操作系统。</p>
<a id="more"></a>
<p>​        严格来说，PXE并不是一种安装方式 ，而是种引导方式。 进行PXE安装的必要条件是在要安装的计算机中必须包含个PXE支持的网卡(NIC)， 即网卡中必须要有PXE Client。PXE 协议可以使计算机通过网络启动。此协议分为Client端和Server端，而PXE Client则在网卡的ROM中。当计算机引导时，BIOS把PXE Client调入内存中执行，然后由PXE Client将放置在远端的文件通过网络下载到本地运行。运行PXE协议需要设置DHCP服务器和TFTP服务器。DHCP 服务器会给PXE<br>Client (将要安装系统的主机)分配个IP地址，由于是给PXE Client分配IP地址，所以在配置DHCP服务器时需要增加相应的PXE设置。此外，在PXE Client的ROM中，已经存在了TFTP Client，那么它就可以通过TFTP协议到TFTP Server上下载所需的文件了。</p>
<h5 id="（二）PXE工作过程"><a href="#（二）PXE工作过程" class="headerlink" title="（二）PXE工作过程"></a>（二）PXE工作过程</h5><p>​        1.PXE方便通过网络大批量地操作系统的部署。PXE client当按下电源键选择从PXE网络启动，通过广播找到DHCP服务器索取IP；</p>
<p>​        2.DHCP服务器返回分配给客户机的IP以及PXE文件的放置位置(该文件一般是放在一台TFTP服务器上) ;</p>
<p>​        3.PXE Client向本网络中的TFTP服务器索取pxelinux.0文件;</p>
<p>​        4.PXE Client取得pxelinux.0文件后之执行该文件;</p>
<p>​        5.根据nxelinux 0的执行结里诵过TFTP服务器加载内核和文件系统；</p>
<p>​        6.进入安装画面，此时可以通过选择HTTP、FTP、NFS方式之一进行安装。</p>
<h5 id="（三）环境准备说明"><a href="#（三）环境准备说明" class="headerlink" title="（三）环境准备说明"></a>（三）环境准备说明</h5><p>​        PXE服务器：CentOS7基于virtualbox的虚拟机</p>
<p>​        IP：10.0.2.15</p>
<pre class=" language-lang-linux"><code class="language-lang-linux">#可通过如下命令查询DNS
[root@localhost ~]# cat /etc/resolv.conf
</code></pre>
<p>​        DNS：114.114.114.114</p>
<p>​        在tftp服务器上要首先由PXE的安装信息，配置服务及安装软件包如下;DHCP；tftp；http；sysliinux（通过yum安装）</p>
<pre><code>[root@localhost ~]# yum install  dhcp tftp tftp-server syslinux httpd -y
#生成ks.cfg文件需要system-config-kickstart工具
[root@localhost ~]# yum install system-config-kickstart -y
#此工具依赖于X Windows，所以需安装X Windows和Desktop
[root@localhost ~]# yum groupinstall &quot;X Windows System&quot;
[root@localhost ~]# yum groupinstall Desktop
#重启系统
[root@localhost ~]# reboot
</code></pre><h4 id="二、基于httpd搭建本地安装源"><a href="#二、基于httpd搭建本地安装源" class="headerlink" title="二、基于httpd搭建本地安装源"></a>二、基于httpd搭建本地安装源</h4><h5 id="（一）挂载光盘"><a href="#（一）挂载光盘" class="headerlink" title="（一）挂载光盘"></a>（一）挂载光盘</h5><pre><code>#挂载CentOS7光盘
[root@localhost ~]# mkdir /media/cdrom
[root@localhost ~]# mount /dev/cdrom /media/cdrom
[root@localhost ~]# mkdir -pv /var/www/html/centos/7/x86_64
#绑定挂载到http默认目录下
[root@localhost ~]#mount --bind /media/cdrom /var/www/html/centos/7/x86_64
</code></pre><h5 id="（二）kickstart-ks-cfg配置文件"><a href="#（二）kickstart-ks-cfg配置文件" class="headerlink" title="（二）kickstart ks.cfg配置文件"></a>（二）kickstart ks.cfg配置文件</h5><pre><code>[root@localhost ~]# cd /var/www/html;mkdir ks
[root@localhost ~]# vim anaconda-ks.cfg
#version=DEVEL
# System authorization information
auth --enableshadow --passalgo=sha512
# Use CDROM installation media
#cdrom
# Install OS instead of upgrade
install
# Use network installation
url --url=http://（自己的IP地址，如：10.0.2.15）/centos/7/x86_64
# Use graphical install
graphical
# Run the Setup Agent on first boot
firstboot --enable
#ignoredisk --only-use=sda
# Keyboard layouts
keyboard --vckeymap=cn --xlayouts=&#39;cn&#39;
# System language
lang zh_CN.UTF-8

# Network information
network  --bootproto=dhcp --device=enp0s3 --onboot=off --ipv6=auto
network  --hostname=localhost.pkey.cn

# Root password
rootpw --iscrypted $1$lSeSXuy.$7HmGY9vVxEGEGB98qTUuv1
# System timezone
timezone Asia/Shanghai --isUtc
# System bootloader configuration
bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda
autopart --type=lvm
# Partition clearing information
clearpart --none --initlabel

%packages
@^minimal
@core
kexec-tools
vim
wget
httpd
%end
%addon com_redhat_kdump --enable --reserve-mb=&#39;auto&#39;
%end
selinux --disabled     #禁用selinux
reboot        #安装完重启系统
</code></pre><h5 id="（三）配置启动"><a href="#（三）配置启动" class="headerlink" title="（三）配置启动"></a>（三）配置启动</h5><pre><code>[root@localhost ~]# systemctl start httpd
[root@localhost ~]# systemctl enable httpd
</code></pre><h5 id="（四）查看当前服务状态"><a href="#（四）查看当前服务状态" class="headerlink" title="（四）查看当前服务状态"></a>（四）查看当前服务状态</h5><pre><code>[root@localhost ~]# systemctl status httpd.service
</code></pre><p> <img src="/2019/08/11/zi-dong-hua-yun-wei/图片一.png" alt></p>
<h4 id="三、配置DHCP服务"><a href="#三、配置DHCP服务" class="headerlink" title="三、配置DHCP服务"></a>三、配置DHCP服务</h4><h5 id="（一）配置dhcp服务"><a href="#（一）配置dhcp服务" class="headerlink" title="（一）配置dhcp服务"></a>（一）配置dhcp服务</h5><p>dhcp配置文件在/etc/dhcp/目录下,默认的配置文件没有,但我们可以在帮助文件中找到模板示例文件加以修改，帮助文件的位置为 /usr/share/doc/dhcp*/dhcpd.conf.sample，也可以自己新建一个dhcpd.conf文件，写入</p>
<pre><code>[root@localhost ~]# vim /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
option domain-name &quot;pkey.cn&quot;;
option domain-name-servers 114.114.114.114;    #写入网关
default-lease-time 600;
max-lease-time 7200;
log-facility local7;
subnet 10.0.2.0 netmask 255.255.255.0 {
    range dynamic-bootp 10.0.2.110 10.0.2.120;
    option routers 10.0.2.1;
    next-server 10.0.2.254;    #tftp server也是本机,可以分开
  filename &quot;pxelinux.0&quot;;               #引导文件
}
</code></pre><h5 id="（二）启动与查看"><a href="#（二）启动与查看" class="headerlink" title="（二）启动与查看"></a>（二）启动与查看</h5><pre><code>[root@localhost ~]# systemctl start dhcpd
[root@localhost ~]# systemctl enable dhcpd
#查看监听情况
[root@localhost ~]# ss -tunl
Netid  State      Recv-Q Send-Q    Local Address:Port                   Peer Address:Port              
udp    UNCONN     0      0                     *:67                                *:*                 
udp    UNCONN     0      0                     *:68                                *:*                 
udp    UNCONN     0      0             127.0.0.1:323                               *:*                 
udp    UNCONN     0      0                    :::69                               :::*
</code></pre><h5 id="（三）查看当前服务状态"><a href="#（三）查看当前服务状态" class="headerlink" title="（三）查看当前服务状态"></a>（三）查看当前服务状态</h5><pre><code>[root@localhost ~]# systemctl status httpd.service
</code></pre><p><img src="/2019/08/11/zi-dong-hua-yun-wei/图片二.png" alt=" "></p>
<h4 id="四、配置tftp服务"><a href="#四、配置tftp服务" class="headerlink" title="四、配置tftp服务"></a>四、配置tftp服务</h4><p>安装好tftp-server软件包后 默认的数据根目录是/var/lib/tftpboot/ 无须修改,只需要复制一些软件引导文件进来即可</p>
<p><strong>1、相关文件准备</strong></p>
<pre><code>##引导文件
[root@localhost ~]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/  
#内核文件
[root@localhost ~]# cp /media/cdrom/images/pxeboot/{vmlinuz,initrd.img} /var/lib/tftpboot
#引导菜单
[root@localhost ~]# cp /usr/share/syslinux/{chain.c32,mboot.c32,menu.c32,memdisk} /var/lib/tftpboot
#制件引导默认文件
[root@localhost ~]# mkdir -pv /var/lib/tftpboot/pxelinux.cfg
#在/var/lib/tftpboot/pxelinux.cfg目录下
[root@localhost pxelinux.cfg]# cat default 
default menu.c32
   prompt 5
   timeout 30
   MENU TITLE CentOS 7 PXE Menu

   LABEL linux
   MENU LABEL Install CentOS 7 x86_64
   KERNEL vmlinuz
   APPEND initrd=initrd.img inst.repo=http://（自己的IP）/centos/7/x86_64 ks=http://（自己的IP）/ks/ks.cfg
</code></pre><p><strong>2、启动配置开机自启</strong></p>
<pre><code>[root@localhost]# systemctl enable tftp
[root@localhost]# systemctl start tftp
</code></pre><p><strong>3、tftp测试</strong></p>
<pre><code>#查看/var/lib/tftpboot/的目录文件结构
[root@localhost tftpboot]# tree -L 2
.
├── chain.c32
├── initrd.img
├── mboot.c32
├── memdisk
├── menu.c32
├── pxelinux.0
├── pxelinux.cfg
│   └── default
└── vmlinuz

1 directory, 8 files
</code></pre><pre><code>[root@localhost ~]# cd /var/lib/tpm
[root@localhost tpm]# pwd;ls
/var/lib/tpm
[root@localhost tpm]# tftp 10.0.2.15
tftp&gt; get vmlinuz
tftp&gt; quit
[root@localhost tpm]# pwd;ls
/var/lib/tpm
vmlinuz
</code></pre><h5 id="五、PEX无人值守安装测试"><a href="#五、PEX无人值守安装测试" class="headerlink" title="五、PEX无人值守安装测试"></a>五、PEX无人值守安装测试</h5><p><strong>（一）修改virtualbox网络</strong><br>管理—&gt;全局设定—&gt;网络—&gt;”仅主机(Host-Only)网络” —&gt;双击vboxnet0 —&gt;把virtualbox自带的仅主机网络的DHCP服务关掉</p>
<p><strong>（二）新建虚拟机</strong><br>和用cdrom安装虚拟的唯一区别是不用挂载镜像,只需要修改新的虚拟机的网络类型为”仅主机(Host-Only)网络”</p>
<p>开机—&gt;按F12选择LAN启动</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机三级嵌入式学习笔记</title>
    <url>/2019/08/10/ji-suan-ji-san-ji-qian-ru-shi-xue-xi-bi-ji/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​        笔者在大一下学期一时冲动，直接跳过计算机二级报名考计算机三级嵌入式。没错，我觉得我冲动了，当时想着接触一下嵌入式，学点皮毛也好，考个证下来就更好了，结果，看书做题，发现，我高估自己了喔。</p>
<a id="more"></a>
<p>​        八十块钱报名费极大可能打水漂，但看完书还是认认真真的把题库刷一遍吧，前面八十分基本全是概念啊，全是啊，我滴天，孩子最不擅长的就是背这些balabala的，哭了，孩子快哭了啊！！！太难啦！！！</p>
<p>​        做过题记一下笔记吧，加深些印象也好，呜呜呜~</p>
<h4 id="大致提纲"><a href="#大致提纲" class="headerlink" title="大致提纲"></a>大致提纲</h4><h5 id="一、嵌入式系统概论"><a href="#一、嵌入式系统概论" class="headerlink" title="一、嵌入式系统概论"></a>一、嵌入式系统概论</h5><h6 id="1-嵌入式系统及其应用"><a href="#1-嵌入式系统及其应用" class="headerlink" title="1.嵌入式系统及其应用"></a>1.嵌入式系统及其应用</h6><p>​        （1）嵌入式系统介绍及其特性：</p>
<p>​                专用性；隐蔽性；资源受限；高可靠性；实时性；软件固化。</p>
<p>​        （2）嵌入式系统的应用</p>
<p>​        （3）嵌入式系统的逻辑组成：</p>
<p>​                软硬件两部分：硬件主体是中央处理器和存储器，它们通过输入/输出（I/O）接口和输入/输出设备与外部世界联系，并借助总线相互连接，这些硬件连同嵌入式软件一同构成完整的嵌入式系统。</p>
<p>​        （4）嵌入式处理芯片：</p>
<p>​                嵌入式系统的CPU一般具有四个特点：支持实时处理；低功耗；结构可扩展；集成了测试电路。</p>
<p>​        （5）目前嵌入式处理芯片类型：</p>
<p>​                微处理器（MCU）；数字信号处理器（DSP）；微控制器（单片机）；片上系统（SoC）。</p>
<p>​        （6）嵌入式系统的多种分类方法</p>
<p>​                可以按用途分类；按实时性分类；按产品形态分类；按系统的复杂程度分类。</p>
<p>​        （7）SoC芯片的介绍</p>
<p>​        （8）IP核及其复用</p>
<p>​                软核；固核；硬核。</p>
<h6 id="2-嵌入式系统与数字媒体"><a href="#2-嵌入式系统与数字媒体" class="headerlink" title="2.嵌入式系统与数字媒体"></a>2.嵌入式系统与数字媒体</h6><p>​        （1）数字（电子）文本</p>
<p>​        （2）数字图像</p>
<p>​        （3）数字音频与数字视频</p>
<h6 id="3-数字通信与计算机网络"><a href="#3-数字通信与计算机网络" class="headerlink" title="3.数字通信与计算机网络"></a>3.数字通信与计算机网络</h6><p>​        （1）数字通信：</p>
<p>​                模拟通信与数字通信；有线与无线通信。</p>
<p>​                调制与解调技术；多路复用技术；交换技术。</p>
<p>​        （2）计算机网络</p>
<p>​        （3）互联网</p>
<h5 id="二、嵌入式处理器"><a href="#二、嵌入式处理器" class="headerlink" title="二、嵌入式处理器"></a>二、嵌入式处理器</h5><h6 id="1-嵌入式处理器概述："><a href="#1-嵌入式处理器概述：" class="headerlink" title="1.嵌入式处理器概述："></a>1.嵌入式处理器概述：</h6><p>​        （1）嵌入式处理器的结构类型</p>
<p>​                嵌入式处理器的体系结构按<u>指令集</u>可分为两大类：复杂指令集结构（CISC）及精简指令集结构（RISC）。进一步细分，按<u>存储机制</u>分为冯.诺依曼结构和哈佛结构；按<u>字长</u>分为8位、16位、32位和64位结构；按<u>不同内核系列</u>又可分为51、AVR、PIC、MSP430、MIPS、PowerPC、MC68K、ColdFire、ARM等。</p>
<p>​        （2）ARM处理器概述</p>
<p>​                主要特点：单周期操作；只使用加载、存储（Load/Store）指令访问内存；指令长度固定为32位长；三地址指令格式；指令流水线技术；低功耗设计。</p>
<h6 id="2-典型ARM处理器介绍"><a href="#2-典型ARM处理器介绍" class="headerlink" title="2.典型ARM处理器介绍"></a>2.典型ARM处理器介绍</h6><p>​        （1）ARM处理器的分类：</p>
<p>​                经典ARM处理器（T表示支持Thumb指令集，D表示支持片上调试，M表示具有快速的64位乘法，I表示提供片内在线仿真，-S表示该处理器以IP软核的形式提供授权）、ARM Cortex嵌入式处理器（Cortex -M）、ARM Cortex实时嵌入式处理器（Cortex -R）、ARM Cortex应用处理器（Cortex -A）以及ARM Cortex专家处理器。</p>
<h6 id="3-ARM处理器体系结构"><a href="#3-ARM处理器体系结构" class="headerlink" title="3.ARM处理器体系结构"></a>3.ARM处理器体系结构</h6><p>​        （1）ARM处理器工作状态：</p>
<p>​                    ARM状态；Thumb状态及Thumb-2状态；调试状态。</p>
<p>​        （2）ARM处理器的工作模式：</p>
<p>​                用户模式（User）；快速中断模式（FIQ）；外部中断模式（IRQ）；管理模式（SVC）；中止模式（ABT）；未定义指令模式（UND）；系统模式（SYS）。</p>
<p>​        （3）ARM异常种类及优先级</p>
<p>​                复位RESET（1）；未定义的指令UND（6）；软件中断SWI（6）；指令预取中止PABT（5）；数据访问中止DABT（2）；外部中断请求IRQ（4）；快速中断请求FIQ（3）。</p>
<p>​        （4）ARM处理器中的MMU（内存管理单元）；MPU（存储器保护单元）。</p>
<h6 id="4-ARM处理器指令集"><a href="#4-ARM处理器指令集" class="headerlink" title="4.ARM处理器指令集"></a>4.ARM处理器指令集</h6><p>​    （太多了，不好记，这部分我还是回去看资料吧。。。ε=(´ο｀*)))唉）</p>
<h6 id="5-ARM汇编语言程序设计"><a href="#5-ARM汇编语言程序设计" class="headerlink" title="5.ARM汇编语言程序设计"></a>5.ARM汇编语言程序设计</h6><h5 id="三、嵌入式系统硬件组成"><a href="#三、嵌入式系统硬件组成" class="headerlink" title="三、嵌入式系统硬件组成"></a>三、嵌入式系统硬件组成</h5><h6 id="1-嵌入式最小硬件系统"><a href="#1-嵌入式最小硬件系统" class="headerlink" title="1.嵌入式最小硬件系统"></a>1.嵌入式最小硬件系统</h6><p>​                电源电路；时钟电路；复位电路；JTAG测试接口。</p>
<h6 id="2-嵌入式处理芯片"><a href="#2-嵌入式处理芯片" class="headerlink" title="2.嵌入式处理芯片"></a>2.嵌入式处理芯片</h6><p>​        （1）ARM的AMBA总线体系结构及标准</p>
<p>​        （2）基于ARM内核的嵌入式芯片的硬件组成</p>
<p>​                存储器及控制器；中断控制器；DMA控制器；电源管理与时钟控制器；GPIO端口；定时计数组件；模拟通道组件；互联通信组件。</p>
<h6 id="3-嵌入式系统的存储器"><a href="#3-嵌入式系统的存储器" class="headerlink" title="3.嵌入式系统的存储器"></a>3.嵌入式系统的存储器</h6><p>​                随机存取存储器；只读存储器；铁电存储器；磁性存储器。</p>
<h6 id="4-I-O接口及常用的I-O设备"><a href="#4-I-O接口及常用的I-O设备" class="headerlink" title="4.I/O接口及常用的I/O设备"></a>4.I/O接口及常用的I/O设备</h6><p>​                通用I/O接口GPIO；集成电路互连总线接口I²C；串行外设接口SPI；串行异步通信接口UART；通用串行总线USB；高清多媒体接口HDMI；常用简单输入设备；常用简单输出设备。</p>
<h6 id="5-ARM内核典型嵌入式处理芯片"><a href="#5-ARM内核典型嵌入式处理芯片" class="headerlink" title="5.ARM内核典型嵌入式处理芯片"></a>5.ARM内核典型嵌入式处理芯片</h6><h6 id="6-嵌入式系统外部通信接口"><a href="#6-嵌入式系统外部通信接口" class="headerlink" title="6.嵌入式系统外部通信接口"></a>6.嵌入式系统外部通信接口</h6><p>​                基于UART的RS-232/RS-485接口；CAN总线接口；以太网通信接口；常用无线通信接口。</p>
<h5 id="四、嵌入式系统软件"><a href="#四、嵌入式系统软件" class="headerlink" title="四、嵌入式系统软件"></a>四、嵌入式系统软件</h5><h6 id="1-嵌入式系统的软件组成"><a href="#1-嵌入式系统的软件组成" class="headerlink" title="1.嵌入式系统的软件组成"></a>1.嵌入式系统的软件组成</h6><p>​    （1）嵌入式软件的特点：</p>
<p>​                软件与硬件一体化；软件代码时空效率要求高；软件可裁剪，尽可能去除冗余；软件应用环境复杂，安全性和可靠性要求高；软件开发难度大；软件面向用户、面向商品、面向应用，受限于功能和具体应用环境；软件产业高度分散；软件具有较长的生命周期。</p>
<p>​    （2）嵌入式软件的软件结构:</p>
<p>​                简单的轮询结构；带中断的轮询结构；监控式操作系统+应用软件的结构；通用嵌入式操作系统+应用软件的结构。</p>
<p>​    （3）硬件抽象层与板级支持包</p>
<p>​    （4）引导加载程序</p>
<p>​                引导加载程序的概念和功能；嵌入式操作系统的加载方式；引导加载程序的执行过程；U-Boot简介。</p>
<p>​    （5）嵌入式系统的设备驱动设备</p>
<h6 id="2-嵌入式操作系统"><a href="#2-嵌入式操作系统" class="headerlink" title="2.嵌入式操作系统"></a>2.嵌入式操作系统</h6><p>​        （1）实时系统与实时操作系统</p>
<p>​                实时系统：硬实时任务；软实时任务；准实时任务。</p>
<p>​                实时操作系统：事件驱动；多级中断嵌套处理；细粒度的任务优先级控制；实时抢占式调度。</p>
<p>​                实时操作系统的实时性指标：中断延迟时间；任务切换时间；任务抢占时间。</p>
<p>​        （2）嵌入式操作系统概述</p>
<p>​                嵌入式操作系统的特点和分类</p>
<p>​                嵌入式操作系统的内核结构：单内核和微内核。</p>
<p>​                常用嵌入式操作系统简介。</p>
<h6 id="3-uC-OS嵌入式操作系统"><a href="#3-uC-OS嵌入式操作系统" class="headerlink" title="3.uC/OS嵌入式操作系统"></a>3.uC/OS嵌入式操作系统</h6><p>​        （1）uC/OS操作系统概述</p>
<p>​                uC/OS-Ⅱ内核大致可以划分为任务调度、任务管理、时间管理、任务间同步与通信以及内存管理、系统管理等模块。系统管理又包括系统初始化、系统启动、中断管理、时钟中断及事件处理等部分。</p>
<p>​        （2）uC/OS-Ⅱ的任务及其管理</p>
<p>​                任务的程序代码；任务堆栈；任务控制块。</p>
<p>​        （3）uC/OS-Ⅱ的系统服务</p>
<p>​                uC/OS-Ⅱ的任务管理服务；uC/OS-Ⅱ的时钟节拍与时间管理服务；uC/OS-Ⅱ的任务间通信与同步服务。</p>
<p>​        （4）uC/OS-Ⅲ操作系统的改进与提高</p>
<p>​                时间片轮转调度；内核对象的数量无限制；任务消息和任务信号；优先级的时钟节拍处理；可针对的时钟节拍处理；可针对处理器体系结构进行优化；时间戳；增强的内置性能测试功能。</p>
<h5 id="五、嵌入式系统的开发"><a href="#五、嵌入式系统的开发" class="headerlink" title="五、嵌入式系统的开发"></a>五、嵌入式系统的开发</h5><h6 id="1-开发嵌入式系统的基础知识"><a href="#1-开发嵌入式系统的基础知识" class="headerlink" title="1.开发嵌入式系统的基础知识"></a>1.开发嵌入式系统的基础知识</h6><p>​        （1）嵌入式系统的开发过程</p>
<p>​                需求分析与规格说明；系统设计；构件设计；系统集成与测试。</p>
<p>​        （2）嵌入式系统的开发特点</p>
<p>​                使用宿主机-目标机的开发架构；与底层硬件控制程序的关系密切；软硬件资源受限制；需要固化程序。</p>
<p>​        （3）嵌入式系统的调试</p>
<p>​                在线仿真器；片上调试技术-JTAG；驻留监控软件调试；指令集模拟器。</p>
<h6 id="2-系统开发工具软件"><a href="#2-系统开发工具软件" class="headerlink" title="2.系统开发工具软件"></a>2.系统开发工具软件</h6><p>​        （1）ADS1.2工具软件</p>
<p>​        （2）RVDS</p>
<p>​        （3）GNU</p>
<p>​                是一种常用于开发基于Linux操作系统的嵌入式软件的工具套件简称。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>​        本篇文章为看完资料书做的大致提纲，梳理知识点与思路，为之后刷题做个铺垫，然鹅好像仍然没有记住多少。。。这知识它不进脑子呀。。。</p>
<p>​        </p>
<p>​        </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装配置看门狗</title>
    <url>/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/</url>
    <content><![CDATA[<h3 id="看门狗——让树莓派永不死机"><a href="#看门狗——让树莓派永不死机" class="headerlink" title="看门狗——让树莓派永不死机"></a>看门狗——让树莓派永不死机</h3><p>当利用树莓派做一些需要长期待机的应用时，会遇到的一个问题就是树莓派会因为过热而死机，需要重启树莓派，然后再次开启树莓派上的应用，watchdog（看门狗）这款软件可以帮我们解决这样的麻烦，来实现树莓派永不死机的功能。</p>
<a id="more"></a>
<p>1.树莓派本身自带了看门狗模块，因此，我们需在命令行中输入下列命令打开配置文件</p>
<pre><code>sudo modprobe bcm2708_wdog
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片一.png" alt></p>
<pre><code>sudo nano /etc/modules
</code></pre><p>2.在配置文件中添加一行”bcm2708_wdog”，添加完成后，按快捷键Ctrl+O进行保存，按快捷键Ctrl+X退出编辑</p>
<p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片二.png" alt></p>
<p>3.输入命令安装看门狗软件</p>
<pre><code>sudo apt-get install chkconfig watchdog
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片三.png" alt></p>
<p>4.输入命令打开看门狗配置文件</p>
<pre><code>sudo nano /etc/watchdog.conf
</code></pre><p>找到”#watchdog-device = /dev/watchdog“一行内容，将“#”去掉</p>
<p>之后便可以自行设定树莓派重启的条件</p>
<p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片四.png" alt></p>
<pre><code>//用于设定CPU温度重启条件
temperature-device=/sys/class/thermal/thermal_zone0/temp
//最大温度为80度，超过80度就会引起重启
max-temperature = 80000
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片五.png" alt></p>
<pre><code>//1分钟最多进程为24个，超过即重启
max-load-1=24
//5分钟最多进程为18个，超过即重启
max-load-5=18
//15分钟最多进程为12个，超过即重启
max-load-15=12
</code></pre><p>完成配置后，按快捷键Ctrl+O进行保存，按快捷键Ctrl+X退出编辑</p>
<p>5.配置看门狗程序，开机自动运行</p>
<pre><code>chkconfig watchdog on
</code></pre><p>6.启动看门狗</p>
<pre><code>sudo /etc/init.d/watchdog start
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片六.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell在IP可查且可ping通外网的情况连接不上VirtualBox的解决方法</title>
    <url>/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/</url>
    <content><![CDATA[<p>​    笔者在学习Linux的过程中，经常会遇到xshell连接不上虚拟机的情况，而在使用VirtualBox的时候遇到过一次，IP地址可查，在虚拟机中ping外网也能ping通，但xshell却连接不上的情况。</p>
<a id="more"></a>
<p>​    在网上搜索说是物理机连接虚拟机的网卡配置不对 ：VMware Virtual Ethernet Adapter for VMnet8 ；要将该网卡IP设置为和虚拟机服务器IP在同一个网段，但尝试后仍无效果，后请教大佬得以解决。</p>
<p>​    解决方法如下：</p>
<p>1.进入设置界面</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片一.png" alt></p>
<p>2.进入网络设置，并点击高级选项</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片二.png" alt></p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片三.png" alt></p>
<p>3.按照如下配置，进行转换</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片五.png" alt></p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片四.png" alt></p>
<p>4.登录xshell，配置主机IP</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片六.png" alt></p>
<p>然后即可连接到虚拟机上</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片七.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>数码雨</title>
    <url>/2019/07/10/shu-ma-yu/</url>
    <content><![CDATA[<h3 id="有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果"><a href="#有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果" class="headerlink" title="有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果"></a>有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果</h3><p>闲言少叙，命令如下</p>
<a id="more"></a>
<p>1.yum -y install wget</p>
<p>2.wget <a href="https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz" target="_blank" rel="noopener">https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz</a></p>
<p>3.tar xvf cmatrix-1.2a.tar.gz</p>
<p>4.跳转到cmatrix-1.2a目录下</p>
<p>命令为 cd cmatrix-1.2a</p>
<p>5.yum install ncurses-devel</p>
<p>（过程中会出现    “Is this ok [y/d/N]: ”</p>
<p>（ 输入”y”,敲回车即可</p>
<p>6.yum -y install gcc</p>
<p>7.yum -y install gcc-c++</p>
<p>8.yum install make</p>
<p>9.输入命令 “./configure &amp;&amp; make &amp;&amp; make install”</p>
<p>（尤其注意，该命令以“.”开头，不要输入错误）</p>
<p>10.输入cmatrix，即可看到数码雨的情景</p>
<p><img src="/2019/07/10/shu-ma-yu/图片一.png" alt></p>
<h4 id="cmatrix常用命令如下"><a href="#cmatrix常用命令如下" class="headerlink" title="cmatrix常用命令如下:"></a>cmatrix常用命令如下:</h4><p>cmatrix-a :异步滚动（默认）</p>
<p>cmatrix-b :随机粗体</p>
<p>cmatrix-B :全部粗体</p>
<p>cmatrix-o :使用旧风格滚动</p>
<p>cmatrix-x :X window 模式</p>
<p>cmatrix-V :显示版本信息</p>
<p>cmatrix-u :刷新频率，0-9，也就是滚动的快慢</p>
<p>cmatrix-C :显示的颜色，支持green(默认),red,blue,white,yellow,cyan</p>
<p><img src="/2019/07/10/shu-ma-yu/图片二.png" alt></p>
<h5 id="骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。"><a href="#骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。" class="headerlink" title="骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。"></a>骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。</h5>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC数模转换的学习</title>
    <url>/2019/07/09/adc-shu-mo-zhuan-huan/</url>
    <content><![CDATA[<h3 id="一、什么是ADC"><a href="#一、什么是ADC" class="headerlink" title="一、什么是ADC"></a>一、什么是ADC</h3><p>Analog-to-Digital Converter的缩写。</p>
<p>指模/数转换器或者模拟/数字转换器。是指将连续变量的模拟信号转换为离散的数字信号的器件。</p>
<p>典型的模拟数字转换器将模拟信号转换为表示一定比例电压值的数字信号。</p>
<a id="more"></a>
<h3 id="二、STM32F10x的ADC特点"><a href="#二、STM32F10x的ADC特点" class="headerlink" title="二、STM32F10x的ADC特点"></a>二、STM32F10x的ADC特点</h3><p>1.12位逐次逼近型的模拟数字转换器；</p>
<p>2.最多带3个ADC控制器；</p>
<p>3.最多支持18个通道，可最多测量16个外部和2个内部信号源；</p>
<p>4.支持单次和连续转换模式； </p>
<p>5.转换结束，注入转换结束，和发生模拟看门狗事件时产生中断；</p>
<p>6.通道0到通道n的自动扫描模式；</p>
<p>7.自动校准；</p>
<p>8.采样间隔可以按通道编程；</p>
<p>9.规则通道和注入通道均有外部触发选项； </p>
<p>10.转换结果支持左对齐或右对齐方式存储在16位数据寄存器 ADC转换时间：最大转换速率 1us。（最大转换速度为1MHz，在ADCCLK=14M，采样周期为1.5个ADC时钟下得到。）； </p>
<p>11.ADC供电要求：2.4V-3.6V；</p>
<p>12.ADC输入范围：VREF- ≤  VIN  ≤  VREF+</p>
<h3 id="三、STM32通道组"><a href="#三、STM32通道组" class="headerlink" title="三、STM32通道组"></a>三、STM32通道组</h3><h5 id="规则通道组：相当正常运行的程序。最多16个通道。"><a href="#规则通道组：相当正常运行的程序。最多16个通道。" class="headerlink" title="规则通道组：相当正常运行的程序。最多16个通道。"></a>规则通道组：相当正常运行的程序。最多16个通道。</h5><p>规则通道和它的转换顺序在ADC_SQRx寄存器中选择，规则组转换的总数应写入ADC_SQR1寄存器的L[3:0]中</p>
<h5 id="注入通道组：相当于中断。最多4个通道。"><a href="#注入通道组：相当于中断。最多4个通道。" class="headerlink" title="注入通道组：相当于中断。最多4个通道。"></a>注入通道组：相当于中断。最多4个通道。</h5><p>注入组和它的转换顺序在ADC_JSQR寄存器中选择。注入组     里转化的总数应写入ADC_JSQR寄存器的L[1:0]中</p>
<p><img src="/2019/07/09/adc-shu-mo-zhuan-huan/guize.png" alt></p>
<p><img src="/2019/07/09/adc-shu-mo-zhuan-huan/zhuru.png" alt></p>
<h3 id="四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。"><a href="#四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。" class="headerlink" title="四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。"></a>四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。</h3><h4 id="ADC单通道："><a href="#ADC单通道：" class="headerlink" title="ADC单通道："></a>ADC单通道：</h4><p>要求进行一次ADC转换：配置为单次模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，就停止转换。</p>
<p>要求进行连续ADC转换：配置为连续模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，接着进行下一次转换，不断连续。</p>
<h4 id="ADC多通道："><a href="#ADC多通道：" class="headerlink" title="ADC多通道："></a>ADC多通道：</h4><p>要求进行一次ADC转换：配置为单次模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，就停止转换。</p>
<p>要求进行连续ADC转换：配置为连续模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，接着进行下一次转换，不断连续。</p>
<p>（扫描模式只在多通道的条件下有效，来使得各个通道按照配置循序依次转换。而单次模式无论在单通道还是多通道下只对这些或者这个通道进行一次转换，连续模式无论是在单通道还是多通道下都对这些或者这个通道不断进行连续的转换。 ）</p>
<h3 id="五、ADC中断"><a href="#五、ADC中断" class="headerlink" title="五、ADC中断"></a>五、ADC中断</h3><p>规则和注入组转换结束时能产生中断。它们都有独立的中断使能位。</p>
<h3 id="六、配置函数选讲"><a href="#六、配置函数选讲" class="headerlink" title="六、配置函数选讲"></a>六、配置函数选讲</h3><h5 id="（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入"><a href="#（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入" class="headerlink" title="（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入"></a>（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入</h5><h5 id="GPIO-Init"><a href="#GPIO-Init" class="headerlink" title="GPIO_Init();"></a>GPIO_Init();</h5><h5 id="APB2PeriphClockCmd"><a href="#APB2PeriphClockCmd" class="headerlink" title="APB2PeriphClockCmd();"></a>APB2PeriphClockCmd();</h5><p>其中设置分频因子时需注意：</p>
<p>RCC_ADCCLKConfig(RCC_PCLK2_Div6); </p>
<p>//设置 ADC 分频因子 6<br>//APB2的时钟为72M,而72M/6=12,ADC 最大时间不能超过 14M</p>
<h5 id="（2）ADC-规则通道配置函数"><a href="#（2）ADC-规则通道配置函数" class="headerlink" title="（2）ADC 规则通道配置函数"></a>（2）ADC 规则通道配置函数</h5><h5 id="ADC-RegularChannelConfig-ADC1-ADC-Channel-1-1-ADC-SampleTime-239Cycles5"><a href="#ADC-RegularChannelConfig-ADC1-ADC-Channel-1-1-ADC-SampleTime-239Cycles5" class="headerlink" title="ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1,                   ADC_SampleTime_239Cycles5 );"></a>ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1,                   ADC_SampleTime_239Cycles5 );</h5><p>ADC1的通道1，第三个1是指ADC1的通道1在规则序列中序号为1，即第一个转换，最后一个参数表示采样周期为239.5</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN基础知识介绍</title>
    <url>/2019/05/03/can-xue-xi-bi-ji/</url>
    <content><![CDATA[<h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><p>CAN是控制器局域网络(Controller Area Network, CAN)的简称，已成为汽车计算机控制系统和嵌入式工业控制局域网的标准总线。</p>
<a id="more"></a>
<h4 id="一、CAN协议的特点"><a href="#一、CAN协议的特点" class="headerlink" title="一、CAN协议的特点"></a>一、CAN协议的特点</h4><p>1.多主控制</p>
<p>2.系统柔软性</p>
<p>3.速度快，距离远</p>
<p>4.具有错误检测，错误通知和错误恢复功能</p>
<p>5.故障封闭功能</p>
<p>6.连接节点多</p>
<h4 id="二、物理层特征"><a href="#二、物理层特征" class="headerlink" title="二、物理层特征"></a>二、物理层特征</h4><p>显性电平对应逻辑：0（CAN_H和CAN_L之差为2V左右）</p>
<p>隐性电平对应逻辑：1（CAN_H和CAN_L之差为0V）</p>
<p>【在CAN总线的起止端都有一个120欧姆的中断电阻，来做阻抗匹配，以减少回波辐射】</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片1.png" alt="逻辑电平"></p>
<h4 id="三、数据帧（7个段）"><a href="#三、数据帧（7个段）" class="headerlink" title="三、数据帧（7个段）"></a>三、数据帧（7个段）</h4><p><img src="/2019/05/03/can-xue-xi-bi-ji/图片2.png" alt="数据帧"></p>
<p>1.帧起始：表示数据帧开始的段</p>
<p>2.仲裁段：表示该帧优先级的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片3.png" alt="仲裁段"></p>
<p>3.控制段：表示数据的字节数及保留位的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片4.png" alt="控制段"></p>
<p>4.数据段：数据的内容，一帧可发送0~8个字节的数据</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片5.png" alt="数据段"></p>
<p>5.CRC段：检查帧的传输错误的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片6.png" alt="CRC段"></p>
<p>6.ACK段：表示确认正常接收的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片7.png" alt="ACK段"></p>
<p>7.帧结束：表示数据帧结束的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片8.png" alt="帧结束"></p>
<p>（ ID：11位，高位在前，低位在后，基本ID禁止高7位都为隐性，即不能：ID=1111111xxxx ）</p>
<h4 id="四、总线仲裁"><a href="#四、总线仲裁" class="headerlink" title="四、总线仲裁"></a>四、总线仲裁</h4><p>1.总线空闲时，最先发送的单元获得发送优先权，一旦发送，其他单元无法抢占</p>
<p>2.如果有多个单元同时发送，则连续输出显性电平多的单元，具有较高优先级</p>
<h4 id="五、位时序"><a href="#五、位时序" class="headerlink" title="五、位时序"></a>五、位时序</h4><p>可根据位时序设置波特率</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片9.png" alt="位时序"></p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>一直觉得通信啥的很玄学，其实还是没能熟练掌握最基本的规则。说玄也玄，但万物有因，了解好通信的基础知识，以后出现问题，才好追根溯源，然后好好解决。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的生命周期和作用域</title>
    <url>/2019/05/03/c-yu-yan-de-sheng-ming-zhou-qi-he-zuo-yong-yu/</url>
    <content><![CDATA[<p>生命周期：是一个变量存在的周期。</p>
<p>作用域：是一个变量可以被引用的范围。最常见的如：{}、static修饰符等等。</p>
<a id="more"></a>
<h3 id="（1）全局变量："><a href="#（1）全局变量：" class="headerlink" title="（1）全局变量："></a>（1）全局变量：</h3><p>作用域：全局作用域（只需要在一个源文件中定义，就可以作用于所有的源文件）；</p>
<p>生命周期：程序运行期一直存在；</p>
<p>引用方法：其他文件如果要使用，必须用extern 关键字声明要引用的全局变量；</p>
<p>内存分布：全局（静态存储区）。</p>
<p>注意：如果再两个文件中都定义了相同名字的全局变量，则连接错误：变量重定义。</p>
<h3 id="（2）全局静态变量："><a href="#（2）全局静态变量：" class="headerlink" title="（2）全局静态变量："></a>（2）全局静态变量：</h3><p>生命周期：程序运行期一直存在；</p>
<p>作用域：文件作用域（只在被定义的文件中可见：static的一个作用就是隐藏）</p>
<p>内存分布：全局（静态存储区）。</p>
<p>定义方法：static关键字，const关键字（注意C/C++意义不同）</p>
<p>注意：只要文件不相互包含，两个不同的文件中是可以定义完全相同的两个全局静态变量的。</p>
<h3 id="（3）静态局部变量："><a href="#（3）静态局部变量：" class="headerlink" title="（3）静态局部变量："></a>（3）静态局部变量：</h3><p>生命周期：程序运行期一直存在；（超过其作用域便无法被引用）</p>
<p>作用域：局部作用域（只在局部作用于可见）</p>
<p>内存分布：全局（静态存储区）。</p>
<p>定义方法：局部作用域中用static定义。</p>
<p>注意：只被初始化一次，多线程中需要加锁保护。</p>
<h3 id="（4）局部变量："><a href="#（4）局部变量：" class="headerlink" title="（4）局部变量："></a>（4）局部变量：</h3><p>生命周期：程序运行处局部作用域 即被销毁。</p>
<p>作用域：局部作用域（只在局部作用于可见）</p>
<p>内存分布：栈区</p>
<p>定义方法：在局部作用域中用auto指示符定义，可省略auto</p>
<pre class=" language-lang-c"><code class="language-lang-c">static int c =  1;//全局初始化去（静态全局变量）
int a = 0; //全局初始化区(全局变量)
char  *p1; //全局未初始化区（全局变量）

int main(int argc, char const *argv[])
{
    int b;//存放于栈区（局部变量）
    char s[] = "abc";//s存放于栈区（局部变量）
    char *p2 ;//栈（局部变量）
    char *p3 = "123456";//p3存放于栈区(局部变量);“123456”存放区文字常量区

    static int c = 0;// c存放于全局初始化区（静态局部变量）
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);//分配得来的10和20字节的区域在堆区；
                            //变量p1、p2指向堆区分配的内存

    strcpy(p1, "123456");//“123456”存放区文字常量区
    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/05/03/test/</url>
    <content><![CDATA[<h3 id="Hello-world！"><a href="#Hello-world！" class="headerlink" title="Hello world！"></a>Hello world！</h3><p>第一篇博客佛系的向世界问好</p>
<a id="more"></a>
<p>老羊头以后会好好经营自己的小破站</p>
<p>Hello world！</p>
<p><img src="/2019/05/03/test/timg1.jpg" alt="你想输入的替代文字"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
