<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下安装pyenv</title>
    <url>/2020/06/16/linux-xia-an-zhuang-pyenv/</url>
    <content><![CDATA[<h4 id="一、Pyenv"><a href="#一、Pyenv" class="headerlink" title="一、Pyenv"></a>一、Pyenv</h4><p>在开发Python程序的时候，有时候可能需要在不同版本的Python上进行测试。pyenv就是这么一个管理多版本Python的工具。</p>
<a id="more"></a>
<p>常见操作是：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[python@localhost ~]$ curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash
</code></pre>
<p>但在由于网络环境原因，很可能导致连接失败，出现如下报错等等：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
</code></pre>
<p>所以我们需要采取其他安装方法，如 git clone 所需的脚本</p>
<h4 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h4><p>最好使用新创建的非root用户安装</p>
<ol>
<li>clone 下最新版本的pyenv，安装到 $HOME/.pyenv 文件夹</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">git clone https://github.com/pyenv/pyenv.git ~/.pyenv
</code></pre>
<ol>
<li>定义环境变量<strong>PYENV_ROOT</strong>以指向克隆<strong>pyenv repo</strong>的路径<br><strong>$PATH</strong>用以访问<strong>pyenv</strong>命令行实用程序</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
</code></pre>
<ol>
<li>添加 <strong>pyenv init</strong> 到 <strong>shell</strong> 以启用填充和自动补全功能。</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.bashrc
</code></pre>
<ol>
<li>重启shell</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">exec "$SHELL"
</code></pre>
<ol>
<li>安装低版本python测试</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">pyenv install 2.7.8
</code></pre>
<h6 id="详细信息参考GitHub的官方文档"><a href="#详细信息参考GitHub的官方文档" class="headerlink" title="详细信息参考GitHub的官方文档"></a>详细信息参考<a href="https://github.com/pyenv/pyenv#installation" target="_blank" rel="noopener">GitHub的官方文档</a></h6>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下git clone报错Peer&#39;s Certificate has expired</title>
    <url>/2020/06/16/centos7-xia-git-clone-bao-cuo-peer-s-certificate-has-expired/</url>
    <content><![CDATA[<h4 id="一、报错情况"><a href="#一、报错情况" class="headerlink" title="一、报错情况"></a>一、报错情况</h4><p>操作系统环境：Centos7</p>
<p>报错提示：证书过期</p>
<a id="more"></a>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# git clone https://gitlab.com/XXX
Cloning into 'gitlab'...
fatal: unable to access 'https://gitlab.com/XXX/': Peer's Certificate has expired.
</code></pre>
<p>查看当前系统时间：发现系统时间与当前时间不对应</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# date
</code></pre>
<h4 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h4><p>安装ntpdate，使系统时间同步</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# yum -y install ntpdate
......
[root@localhost ~]# ntpdate -u 210.72.145.44 #网络时间同步命令
[root@localhost ~]# date #查看系统时间正常
</code></pre>
<p>（210.72.145.44：中国国家授时中心的官方服务器）</p>
<p>再次git clone，正常</p>
<h4 id="三、将时间同步服务加到开机启动"><a href="#三、将时间同步服务加到开机启动" class="headerlink" title="三、将时间同步服务加到开机启动"></a>三、将时间同步服务加到开机启动</h4><pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# systemctl enable ntpdate.service
Created symlink from /etc/systemd/system/multi-user.target.wants/ntpdate.service to /usr/lib/systemd/system/ntpdate.service.
[root@localhost ~]# systemctl start ntpdate.service
</code></pre>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本</title>
    <url>/2020/06/12/shell-jiao-ben/</url>
    <content><![CDATA[<h4 id="一、shell脚本基础"><a href="#一、shell脚本基础" class="headerlink" title="一、shell脚本基础"></a>一、shell脚本基础</h4><h5 id="（一）shell脚本"><a href="#（一）shell脚本" class="headerlink" title="（一）shell脚本"></a>（一）shell脚本</h5><p>包含一些命令或声明，并符合一定格式的文本文件</p>
<a id="more"></a>
<h5 id="（二）格式要求：首行shebang机制"><a href="#（二）格式要求：首行shebang机制" class="headerlink" title="（二）格式要求：首行shebang机制"></a>（二）格式要求：首行shebang机制</h5><p>​                                #!/bin/bash</p>
<p>​                                #!/usr/bin/python</p>
<h5 id="（三）用途"><a href="#（三）用途" class="headerlink" title="（三）用途"></a>（三）用途</h5><ul>
<li>自动化常用命令</li>
<li>执行系统管理和故障排除</li>
<li>创建简单的应用程序</li>
<li>处理文本或文件</li>
</ul>
<h5 id="（四）脚本的基本结构"><a href="#（四）脚本的基本结构" class="headerlink" title="（四）脚本的基本结构"></a>（四）脚本的基本结构</h5><pre class=" language-lang-shell"><code class="language-lang-shell">#!SHEBANG
CONFIGURATION_VARIABLES
FUNCTION_DEFINITIONS
MAIN_CODE
</code></pre>
<h5 id="（五）脚本调试"><a href="#（五）脚本调试" class="headerlink" title="（五）脚本调试"></a>（五）脚本调试</h5><p>检测脚本中的语法错误：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">bash -n /path/to/some_script
</code></pre>
<p>调试执行：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">bash -n /path/to/some_script
</code></pre>
<h5 id="（六）变量"><a href="#（六）变量" class="headerlink" title="（六）变量"></a>（六）变量</h5><h6 id="1-强类型"><a href="#1-强类型" class="headerlink" title="1.强类型"></a>1.强类型</h6><p>变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。一般定义变量时必须指定类型、参与运算必须符合类型要求；调用未声明变量会产生错误。如：Java，C#</p>
<h6 id="2-弱类型"><a href="#2-弱类型" class="headerlink" title="2.弱类型"></a>2.弱类型</h6><p>语言的运行时会隐式做数据类型转换。无需指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无需事先定义可直接调用。如：bash不支持浮点数，PHP</p>
<h5 id="（七）bash中变量的种类"><a href="#（七）bash中变量的种类" class="headerlink" title="（七）bash中变量的种类"></a>（七）bash中变量的种类</h5><h6 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1.局部变量"></a>1.局部变量</h6><p>生效范围为当前shell进程；对当前shell之外的其他shell进程，包括当前shell的子shell进程均无效</p>
<ul>
<li>变量赋值：name=’value’</li>
<li>可以使用引用value:<br>(1)可以直接字串：name=”root”<br>(2)变量引用：name=”$USER”<br>(3)命令引用：name=`COMMAND`     name=$(COMMAND)</li>
<li>变量引用：${name}    $name</li>
<li>显示已定义的所有变量：set</li>
<li>删除变量：unset name</li>
</ul>
<h6 id="2-环境（全局）变量"><a href="#2-环境（全局）变量" class="headerlink" title="2.环境（全局）变量"></a>2.环境（全局）变量</h6><p>生效范围为当前shell进程及其子进程</p>
<ul>
<li>变量声明、赋值：<br>export name=VALUE<br>declare -x name=VALUE</li>
<li>变量引用：$name,${name}</li>
<li>显示所有环境变量：env；printenv；export；declare -x</li>
<li>删除变量：unset name</li>
</ul>
<h6 id="3-本地变量"><a href="#3-本地变量" class="headerlink" title="3.本地变量"></a>3.本地变量</h6><p>生效范围为当前shell进程中某代码片段，通常指函数</p>
<h6 id="4-位置变量"><a href="#4-位置变量" class="headerlink" title="4.位置变量"></a>4.位置变量</h6><p>$1,$2……来表示，用于让脚本在脚本代码中调用命令行传递给它的参数</p>
<h6 id="5-特殊变量"><a href="#5-特殊变量" class="headerlink" title="5.特殊变量"></a>5.特殊变量</h6><p>$?    $0    $*    $@    $#    $$</p>
<h5 id="（八）退出状态"><a href="#（八）退出状态" class="headerlink" title="（八）退出状态"></a>（八）退出状态</h5><p>进程使用退出状态来报告成功或失败</p>
<ul>
<li>0代表成功，1-255代表失败</li>
<li>$? 变量保存最近的命令退出状态</li>
</ul>
<pre class=" language-lang-shell"><code class="language-lang-shell">例如：
ping -c1 -W1 hostdown &> /dev/null
echo $?
</code></pre>
<h5 id="（九）条件测试"><a href="#（九）条件测试" class="headerlink" title="（九）条件测试"></a>（九）条件测试</h5><ul>
<li>判断某需求是否满足，需要由测试机制来实现</li>
<li>评估布尔声明，以便用在条件性执行中<ul>
<li>若真，则返回0</li>
<li>若假，则返回1</li>
</ul>
</li>
<li>测试命令<ul>
<li>test EXPRESSION</li>
<li>[ EXPRESSION ]</li>
<li>[[ EXPRESSION ]]<ul>
<li>注意：EXPRESSION前后必须有空白字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class=" language-lang-shell"><code class="language-lang-shell">例如：
[root@localhost ~]# m=10
[root@localhost ~]# n=20
[root@localhost ~]# test $m -eq $n
[root@localhost ~]# echo $?
1
</code></pre>
<h5 id="（十）使用read命令来接收输入"><a href="#（十）使用read命令来接收输入" class="headerlink" title="（十）使用read命令来接收输入"></a>（十）使用read命令来接收输入</h5><p>使用read来把输入值分配给一个或多个shell变量</p>
<ul>
<li>-p 指定要显示的提示</li>
<li>-s 静默输入，一般用于密码</li>
<li>-n N指定输入的字符长度N</li>
<li>-d ‘字符’输入结束符</li>
<li>-t N TIMEOUT为N秒</li>
</ul>
<h5 id="（十一）条件选择if语句"><a href="#（十一）条件选择if语句" class="headerlink" title="（十一）条件选择if语句"></a>（十一）条件选择if语句</h5><ul>
<li><p>单分支</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">if  判断条件;then 
            条件为真的分支代码
fi
</code></pre>
</li>
<li><p>双分支</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">if  判断条件;then 
            条件为真的分支代码
else
            条件为假的分支代码
fi
</code></pre>
</li>
</ul>
<h5 id="（十二）条件判断：case语句"><a href="#（十二）条件判断：case语句" class="headerlink" title="（十二）条件判断：case语句"></a>（十二）条件判断：case语句</h5><pre class=" language-lang-shell"><code class="language-lang-shell">case变量引用in
        PAT1)
                    分支1
                    ;;
        *)
                    默认分支
                    ;;
        esac
</code></pre>
<h5 id="（十三）循环"><a href="#（十三）循环" class="headerlink" title="（十三）循环"></a>（十三）循环</h5><h6 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h6><pre class=" language-lang-shell"><code class="language-lang-shell">for 变量名 in 列表; do
    循环体
done
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">#例如：求100以为奇数之和
sum=0;for number in `seq 1 2 100`;do let sum+=number;done;echo "sum is $sum"
sum is 2500
#或者
for((sum=0,i=1;i<=100;i+=2));do let sum+=i;done;echo "sum is $sum"
sum is 2500
</code></pre>
<h6 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h6><pre class=" language-lang-shell"><code class="language-lang-shell">while CONDITION;do
        循环体
done
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">#例：
sum=0;i=1;while [ "$i" -le 100 ];do let sum+=i;let i+=2;done;echo "sum is $sum"
sum is 2500
</code></pre>
<h6 id="3-until循环"><a href="#3-until循环" class="headerlink" title="3.until循环"></a>3.until循环</h6><pre class=" language-lang-shell"><code class="language-lang-shell">until CONDITION;do
        循环体
done
</code></pre>
<h5 id="（十四）数组"><a href="#（十四）数组" class="headerlink" title="（十四）数组"></a>（十四）数组</h5><ol>
<li>声明数组：declare -a ARRAY_NAME<pre><code>                declare -A ARRAY_NAME：关联数组
</code></pre>注意：两者不可相互转换</li>
<li>引用数组元素：${ARRAY_NAME[INDEX]}<br>注意：省略[INDEX]表示引用下标为0的元素</li>
<li>引用数组所有元素：${ARRAY_NAME[*]}<pre><code>                               ${ARRAY_NAME[@]}
</code></pre></li>
<li>删除数组中的某元素：导致稀疏格式<br>unset ARRAY[INDEX]</li>
<li>删除整个数组：unset ARRAY</li>
</ol>
<h4 id="二、自动生成脚本开头注释"><a href="#二、自动生成脚本开头注释" class="headerlink" title="二、自动生成脚本开头注释"></a>二、自动生成脚本开头注释</h4><p>在/root/目录下新建文件并命名成 “ <strong>.vimrc</strong> ” 名称，并添加以下模板代码</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim .vimrc
set ignorecase
set cursorline
set autoindent
autocmd BufNewFile *.sh exec ":call SetTitle()"
func SetTitle()
        if expand("%:e") == 'sh'
                call setline(1,"#!/bin/bash")
                call setline(2,"#*************************************************************")
                call setline(3,"#Author: Y*Y")                    
                call setline(4,"#Date:  ".strftime("%Y-%m-%d"))
                call setline(5,"#FileName:      ".expand("%"))
                call setline(6,"#*************************************************************")
                call setline(7,"")
        endif
endfunc                                                            
 autocmd BufNewFile * normal G
</code></pre>
<p>再建立shell脚本时则会自动添加开头注释为</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim choose.sh
#!/bin/bash
#*************************************************************
#Author: Y*Y
#Date:  2020-03-12
#FileName:      choose.sh
#*************************************************************
</code></pre>
<h4 id="三、脚本示例"><a href="#三、脚本示例" class="headerlink" title="三、脚本示例"></a>三、脚本示例</h4><h5 id="（一）脚本要求：当磁盘占用率达到80-以上时报警"><a href="#（一）脚本要求：当磁盘占用率达到80-以上时报警" class="headerlink" title="（一）脚本要求：当磁盘占用率达到80%以上时报警"></a>（一）脚本要求：当磁盘占用率达到80%以上时报警</h5><pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim checkspace.sh 
#!/bin/bash
#author:yy
#function:chechspace
value=df -h | awk '/^\/dev\/sda/{print $5}' | awk -F '%' '{print $1}' | sort -nr |head -1
[ $value -gt 80 ] && wall "disk will be full" || wall "disk is normal"
</code></pre>
<p>运行脚本</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# chmod +x *
[root@localhost ~]# ./checkspace.sh
Broadcast message from root@localhost.localdomain (pts/0) (Thu Mar 12 13:13:32 2020):

disk is normal
</code></pre>
<h5 id="（二）交互示例：选择是或否"><a href="#（二）交互示例：选择是或否" class="headerlink" title="（二）交互示例：选择是或否"></a>（二）交互示例：选择是或否</h5><pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim choose.sh
#!/bin/bash
#*************************************************************
#Author: Y*Y
#Date:  2020-03-12
#FileName:      choose.sh
#*************************************************************
read -p "Do you agree? yes or no:" answer
[[ $answer =~ ^([yY][Ee][sS])|[Yy]$ ]] && echo "GO!" || echo "NO"
</code></pre>
<p>运行脚本</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# chmod +x choose.sh
[root@localhost ~]# ./choose.sh
Do you agree? yes or no:yes
GO!
</code></pre>
<h5 id="（三）调用函数实现IP地址是否合法"><a href="#（三）调用函数实现IP地址是否合法" class="headerlink" title="（三）调用函数实现IP地址是否合法"></a>（三）调用函数实现IP地址是否合法</h5><ol>
<li>建立一个专门存放函数的文件</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim functions
checkip() {
    [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] && echo "This is a IP" || echo "This is not IP"
}
</code></pre>
<ol>
<li>新建shell脚本，调用函数</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# vim iptest.sh
#!/bin/bash
#*************************************************************
#Author: Y*Y
#Date:  2020-03-12
#FileName:      iptest.sh
#*************************************************************
. functions
read -p "Please input a ip addr: " ipaddr
checkip $ipaddr
</code></pre>
<ol>
<li>运行脚本测试</li>
</ol>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# chmod +x iptest.sh
[root@localhost ~]# ./iptest.sh 
Please input a ip addr: 1.1.1.1
This is a IP
</code></pre>
<h5 id="（四）定义数组，数组中元素是-var-log目录下所有以-log结尾的文件，统计出其下标为计数的文件中的行数之和"><a href="#（四）定义数组，数组中元素是-var-log目录下所有以-log结尾的文件，统计出其下标为计数的文件中的行数之和" class="headerlink" title="（四）定义数组，数组中元素是/var/log目录下所有以.log结尾的文件，统计出其下标为计数的文件中的行数之和"></a>（四）定义数组，数组中元素是/var/log目录下所有以.log结尾的文件，统计出其下标为计数的文件中的行数之和</h5><pre class=" language-lang-shell"><code class="language-lang-shell">declare -a files
files=(/var/log/*.log)
declare -i lines=0
for i in $(seq 0 $[${#files[*]}-1]); do
        if [ $[$i%2] -ne 0 ]; then                                
                let lines+=$(wc -l ${files[$i]} | cut -d' ' -f1)
        fi
done
echo "Lines: $lines."
</code></pre>
<p>运行结果</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">[root@localhost ~]# ./array.sh 
Lines: 70.
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决CentOS执行yum操作报错Could not retrieve mirrorlist</title>
    <url>/2020/05/22/jie-jue-centos-zhi-xing-yum-cao-zuo-bao-cuo-could-not-retrieve-mirrorlist/</url>
    <content><![CDATA[<h5 id="一、问题说明："><a href="#一、问题说明：" class="headerlink" title="一、问题说明："></a>一、问题说明：</h5><p>在CentOS7环境下执行yum操作安装软件包时出现如下报错：</p>
<a id="more"></a>
<pre><code>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=extras&amp;infra=stock error was
12: Timeout on http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=extras&amp;infra=stock: (28, &#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;)
</code></pre><h5 id="二、解决方法："><a href="#二、解决方法：" class="headerlink" title="二、解决方法："></a>二、解决方法：</h5><p>修改/etc/resolv.conf配置文件后重启网络</p>
<pre><code>[root@localhost ~]# vim /etc/resolv.conf
# Generated by NetworkManager
# nameserver 192.168.43.1
nameserver 8.8.8.8
search localdomain
[root@localhost ~]# service network restart
</code></pre><p>然后正常安装</p>
<pre><code>[root@localhost ~]# yum -y install wget
已加载插件：fastestmirror
base                                    | 3.6 kB     00:00     
extras                                  | 2.9 kB     00:00     
updates                                 | 2.9 kB     00:00     
(1/4): base/7/x86_64/group_gz             | 153 kB   00:01     
(2/4): extras/7/x86_64/primary_db         | 194 kB   00:02     
(3/4): updates/7/x86_64/primary_db        | 1.3 MB   00:05     
(4/4): base/7/x86_64/primary_db           | 6.1 MB   00:17  
......
</code></pre>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编译安装源码包</title>
    <url>/2020/05/22/linux-bian-yi-an-zhuang-yuan-ma-bao/</url>
    <content><![CDATA[<p>源码包就是源代码的可见的软件包，基于Linux和BSD系统的软件最常见；源代码安装具有自定义软件功能，优化编译参数、提高性能以及解决不必要的空间依赖等好处。</p>
<a id="more"></a>
<h4 id="一、程序包编译"><a href="#一、程序包编译" class="headerlink" title="一、程序包编译"></a>一、程序包编译</h4><ul>
<li>Application-VERSION-release.scr.rpm ——&gt; 安装后，使用rpmbuild命令制作成二进制格式的rpm包，而后再安装</li>
<li>源代码——&gt; 预处理——&gt; 编译——&gt; 汇编——&gt; 链接——&gt; 执行</li>
<li>源代码组织格式：多文件：文件中的代码之间，很可能存在跨文件依赖关系</li>
</ul>
<p>​                                       C、C++：make项目管理器（configure脚本——&gt; Makefile.in——&gt; Makefile）</p>
<p>​                                       Java：maven</p>
<h4 id="二、以安装HTTPD为例介绍具体步骤："><a href="#二、以安装HTTPD为例介绍具体步骤：" class="headerlink" title="二、以安装HTTPD为例介绍具体步骤："></a>二、以安装<strong>HTTPD</strong>为例介绍具体步骤：</h4><h5 id="1-从Apache网站-下载压缩包"><a href="#1-从Apache网站-下载压缩包" class="headerlink" title="1.从Apache网站 下载压缩包"></a>1.从<a href="http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="noopener">Apache网站</a> 下载压缩包</h5><pre><code>[root@localhost ~]# wget https://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.43.tar.bz2
</code></pre><p>如果使用<strong>wget</strong>命令出现无法验证证书的警告，则在地址后加上 <strong>—no-check-certificate</strong>，命令如下：</p>
<pre><code>[root@localhost ~]# wget https://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.43.tar.bz2 --no-check-certificate
</code></pre><h5 id="2-解压缩"><a href="#2-解压缩" class="headerlink" title="2.解压缩"></a>2.解压缩</h5><pre><code>[root@localhost ~]# tar xvf httpd-2.4.43.tar.bz2
</code></pre><p>如果解压缩时出现报错：<strong>tar (child): lbzip2：无法 exec: 没有那个文件或目录</strong>，解决方法为：</p>
<pre><code>[root@localhost ~]# yum install -y bzip2
</code></pre><h5 id="3-对即将安装的软件进行配置，检测当前环境"><a href="#3-对即将安装的软件进行配置，检测当前环境" class="headerlink" title="3.对即将安装的软件进行配置，检测当前环境"></a>3.对即将安装的软件进行配置，检测当前环境</h5><p>编译命令根据<strong>./configure —help</strong>提示添加所需功能，输入命令后如果报错，按照报错提示安装所需要的依赖包</p>
<pre><code>[root@localhost httpd-2.4.43]# ./configure --prefix=/apps/httpd24 --sysconfdir=/etc/httpd24
#.......成功状态如下
Server Version: 2.4.43
    Install prefix: /apps/httpd24
    C compiler:     gcc -std=gnu99
    CFLAGS:           -pthread  
    CPPFLAGS:        -DLINUX -D_REENTRANT -D_GNU_SOURCE  
    LDFLAGS:           
    LIBS:             
    C preprocessor: gcc -E
</code></pre><h5 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h5><p>此过程需要等待一段时间</p>
<pre><code>[root@localhost httpd-2.4.43]# make -j 4
</code></pre><h5 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h5><pre><code>[root@localhost apps]# make install
</code></pre><h5 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h5><p>启动服务</p>
<pre><code>[root@localhost ~]# apachectl
</code></pre><p>访问测试网站</p>
<pre><code>[root@localhost ~]# curl localhost:80
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库管理系统</title>
    <url>/2020/04/15/shu-ju-ku-guan-li-xi-tong/</url>
    <content><![CDATA[<h4 id="一、DBMS体系结构"><a href="#一、DBMS体系结构" class="headerlink" title="一、DBMS体系结构"></a>一、DBMS体系结构</h4><h5 id="（一）DBMS核心的构成"><a href="#（一）DBMS核心的构成" class="headerlink" title="（一）DBMS核心的构成"></a>（一）DBMS核心的构成</h5><a id="more"></a>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片一.png" alt></p>
<h5 id="（二）DBMS进程结构"><a href="#（二）DBMS进程结构" class="headerlink" title="（二）DBMS进程结构"></a>（二）DBMS进程结构</h5><h6 id="1-单进程结构"><a href="#1-单进程结构" class="headerlink" title="1.单进程结构"></a>1.单进程结构</h6><p>应用程序使用 DBMS 核心作为一个.exe 文件编译，作为单个进程运行</p>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片二.png" alt></p>
<h6 id="2-多进程结构"><a href="#2-多进程结构" class="headerlink" title="2.多进程结构"></a>2.多进程结构</h6><p>一个应用程序进程对应于一个 DBMS 核心进程（当进程过多时，操作系统资源占用过多，性能会下降）</p>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片三.png" alt></p>
<h6 id="3-多线程结构"><a href="#3-多线程结构" class="headerlink" title="3.多线程结构"></a>3.多线程结构</h6><p>只有一个 DBMS 进程，每个应用程序进程对应于一个 DBMS 核心线程</p>
<p>属于同一个进程的线程可以共享这一个进程的资源</p>
<p>Daemon是一个特殊的进程，会监视应用程序访问数据库的请求</p>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片四.png" alt></p>
<h6 id="4-进程-线程通信协议"><a href="#4-进程-线程通信协议" class="headerlink" title="4.进程/线程通信协议"></a>4.进程/线程通信协议</h6><p>应用程序通过DBMS提供的API或嵌入式SQL访问数据库，根据通信协议进行同步控制。</p>
<ul>
<li>写管道：pipe0：发送SQL语句、内部命令；</li>
<li>读管道：pipe1：返回结果。</li>
</ul>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片五.png" alt></p>
<ul>
<li>State：0-出错； 1-插、删、改操作成功； 2-查询成功，需进一步处理结果</li>
<li>TupNum：结果中的元组数</li>
<li>AttNum：结果中的属性个数</li>
<li>AttName：属性名</li>
<li>AttType：属性类型</li>
<li>AttLen：属性长度</li>
<li>TmpFileName：存放结果数据的临时文件名，其中的数据要用上述字典信息来解释。</li>
</ul>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片六.png" alt></p>
<h4 id="二、文件组织"><a href="#二、文件组织" class="headerlink" title="二、文件组织"></a>二、文件组织</h4><h5 id="（一）堆文件"><a href="#（一）堆文件" class="headerlink" title="（一）堆文件"></a>（一）堆文件</h5><p>按插入顺序存储的记录，并按顺序检索。这是文件组织最基本、最普遍的形式。</p>
<h5 id="（二）hash文件"><a href="#（二）hash文件" class="headerlink" title="（二）hash文件"></a>（二）hash文件</h5><p>记录地址通过哈希函数根据某个属性的值映射。</p>
<h5 id="（三）索引文件"><a href="#（三）索引文件" class="headerlink" title="（三）索引文件"></a>（三）索引文件</h5><p>索引 + 堆文件</p>
<h6 id="常用索引："><a href="#常用索引：" class="headerlink" title="常用索引："></a>常用索引：</h6><p>​       1.B+树：一种多路搜索树，所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>​       2.簇集索引：簇集是一种存储表的方法，这些表密切相关并经常一起连接进磁盘的同一区域。例如，表BOOKSHELF 和BOOKSHELF_AUTHOR 数据行可以一起插入到称为簇（Cluster）的单个区域中，而不是将两个表放在磁盘上的不同扇区上。</p>
<h4 id="三、查询优化"><a href="#三、查询优化" class="headerlink" title="三、查询优化"></a>三、查询优化</h4><h5 id="关系代数等价变换规则"><a href="#关系代数等价变换规则" class="headerlink" title="关系代数等价变换规则"></a>关系代数等价变换规则</h5><h6 id="1-连接、笛卡尔积交换律"><a href="#1-连接、笛卡尔积交换律" class="headerlink" title="1.连接、笛卡尔积交换律"></a>1.连接、笛卡尔积交换律</h6><p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片七.png" alt></p>
<h6 id="2-连接、笛卡尔积结合律"><a href="#2-连接、笛卡尔积结合律" class="headerlink" title="2.连接、笛卡尔积结合律"></a>2.连接、笛卡尔积结合律</h6><p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片八.png" alt></p>
<h6 id="3-投影的串接定律"><a href="#3-投影的串接定律" class="headerlink" title="3.投影的串接定律"></a>3.投影的串接定律</h6><p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片九.png" alt></p>
<h6 id="4-选择的串接定律"><a href="#4-选择的串接定律" class="headerlink" title="4.选择的串接定律"></a>4.选择的串接定律</h6><p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片十.png" alt></p>
<h6 id="5-选择与投影的交换律"><a href="#5-选择与投影的交换律" class="headerlink" title="5.选择与投影的交换律"></a>5.选择与投影的交换律</h6><p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片11.png" alt></p>
<h6 id="6-选择与笛卡尔积的交换律"><a href="#6-选择与笛卡尔积的交换律" class="headerlink" title="6.选择与笛卡尔积的交换律"></a>6.选择与笛卡尔积的交换律</h6><p>​    （1）如果 <strong>F</strong> 中涉及的属性都是 <strong>E</strong> <strong>1</strong> 中的属性，则</p>
<p>​            <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>X</strong> <strong>E</strong> <strong>2</strong> <strong>)≡</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>)</strong> <strong>X</strong>  <strong>E</strong> <strong>2</strong> </p>
<p>​    （2）如果<strong>F</strong> = <strong>F1</strong> ∧ <strong>F2</strong> ，并且<strong>F1</strong>只涉及<strong>E1</strong>中的属性，<strong>F2</strong>只涉及<strong>E2</strong>中的属性，则可推出</p>
<p>​            <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>X</strong> <strong>E</strong> <strong>2</strong> <strong>)≡</strong> <strong>σ</strong> <strong>F1</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>)</strong> <strong>X</strong>  <strong>σ</strong> <strong>F2</strong> <strong>( E</strong> <strong>2 ）</strong> </p>
<h6 id="7-选择与并的分配律"><a href="#7-选择与并的分配律" class="headerlink" title="7.选择与并的分配律"></a>7.选择与并的分配律</h6><p>​        设 <strong>E = E</strong> <strong>1</strong> <strong>∪</strong> <strong>E</strong> <strong>2</strong>，<strong>E1,E2</strong>有相同的属性名，则</p>
<p>​            <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>∪</strong> <strong>E</strong> <strong>2</strong> <strong>)≡</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>)∪</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>2</strong> <strong>)</strong> </p>
<h6 id="8-选择与差运算的分配律"><a href="#8-选择与差运算的分配律" class="headerlink" title="8.选择与差运算的分配律"></a>8.选择与差运算的分配律</h6><p>​        若 <strong>E1,E2</strong>有相同的属性名，则</p>
<p>​            <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>-</strong> <strong>E</strong> <strong>2</strong> <strong>)≡</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <strong>)-</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>2</strong> <strong>)</strong> </p>
<h6 id="9-选择对自然连接的分配律"><a href="#9-选择对自然连接的分配律" class="headerlink" title="9.选择对自然连接的分配律"></a>9.选择对自然连接的分配律</h6><p>​            <strong>σ </strong> <strong>F</strong> <strong>(</strong> <strong>E</strong> <strong>1</strong> <img src="https://img-blog.csdnimg.cn/20190602204715901.png" alt="img">   <strong>E</strong> <strong>2</strong> <strong>)≡</strong> <strong>σ</strong> <strong>F</strong> <strong>(</strong> <strong>E1)</strong>  <img src="https://img-blog.csdnimg.cn/20190602204722248.png" alt="img">    <strong>σF</strong> <strong>(</strong> <strong>E</strong> <strong>2</strong> <strong>)</strong> </p>
<pre><code>        **F** 只涉及**E** **1** 与**E** **2** 的公共属性
</code></pre><h6 id="10-投影与笛卡尔积的分配律"><a href="#10-投影与笛卡尔积的分配律" class="headerlink" title="10.投影与笛卡尔积的分配律"></a>10.投影与笛卡尔积的分配律</h6><p>​        设E1和E2是两个关系表达式，A1，…，An是E1的属性，B1，…，Bm是E2的属性，则</p>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片12.png" alt></p>
<h6 id="11-投影与并的分配律"><a href="#11-投影与并的分配律" class="headerlink" title="11.投影与并的分配律"></a>11.投影与并的分配律</h6><p>​        设E1和E2有相同的属性名，则</p>
<p><img src="/2020/04/15/shu-ju-ku-guan-li-xi-tong/图片13.png" alt></p>
<h4 id="四、数据库恢复技术"><a href="#四、数据库恢复技术" class="headerlink" title="四、数据库恢复技术"></a>四、数据库恢复技术</h4><h5 id="（一）事务"><a href="#（一）事务" class="headerlink" title="（一）事务"></a>（一）事务</h5><p>​        事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p>
<p>​        事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，即提交事务的所有操作，将事务中所有对数据库的更新写回磁盘上的物理数据库中去，事务正常结束。ROLLBACK表示回滚，即在事务运行过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。</p>
<h5 id="（二）事务的特性"><a href="#（二）事务的特性" class="headerlink" title="（二）事务的特性"></a>（二）事务的特性</h5><h6 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h6><p>​        事务是数据库的逻辑工作单元，事务中包括的诸操作要么全执行，要么全不执行。</p>
<h6 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2.一致性"></a>2.一致性</h6><p>​        事务执行的结果必须是使数据库从一个一致性变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入数据库中，这时数据库就处于一种不正确的状态。</p>
<h6 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3.隔离性"></a>3.隔离性</h6><p>​        一个事务的执行不能被其他事务干扰。即一个事务的内部操作以及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<h6 id="4-持续性"><a href="#4-持续性" class="headerlink" title="4.持续性"></a>4.持续性</h6><p>​        持续性也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p>
<h5 id="（三）数据转储"><a href="#（三）数据转储" class="headerlink" title="（三）数据转储"></a>（三）数据转储</h5><p>​        数据转储是数据库恢复中采用的基本技术。所谓转储即DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据成为后备副本或后援副本。</p>
<h6 id="1-静态转储"><a href="#1-静态转储" class="headerlink" title="1.静态转储"></a>1.静态转储</h6><p>​        静态转储是在系统中无运行事务时进行的转储操作。即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许对数据库的任何存取、 修改活动。显然，静态转储得到的一定是一个数据一致性的副本。</p>
<h6 id="2-动态转储"><a href="#2-动态转储" class="headerlink" title="2.动态转储"></a>2.动态转储</h6><p>​        动态转储是指转储期间允许对数据库进行存取或修改。但是，转储结束时后援副本上的数据并不能保证正确有效。为此，必须把转储期间各事务对数据库的修改活动登记下来，建立日志文件，这样，后援副本加上日志文件就能把数据库恢复到某一时刻的正确状态。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统的用户接口以及SQL语言（二）</title>
    <url>/2020/03/28/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan-er/</url>
    <content><![CDATA[<h4 id="一、嵌套子查询"><a href="#一、嵌套子查询" class="headerlink" title="一、嵌套子查询"></a>一、嵌套子查询</h4><h5 id="（一）标量子查询"><a href="#（一）标量子查询" class="headerlink" title="（一）标量子查询"></a>（一）标量子查询</h5><p>查询结果为单个值（凡是可以出现值的地方，都可以出现标量子查询）</p>
<a id="more"></a>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：查找所有纽约的部门编号，部门名称和此部门中雇员的最高工资
SELECT d.deptno,d.deptname,(SELECT MAX(SALARY)
        FROM emp
        WHERE deptno=d.deptno) AS maxpay
FROM dept AS d
WHERE d.location='New York'
</code></pre>
<h5 id="（二）表表达式"><a href="#（二）表表达式" class="headerlink" title="（二）表表达式"></a>（二）表表达式</h5><p>子查询的结果本身就是一个表</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：求每一年入职员工的平均收入
SELECT startyear,aug(pay)
FROM (SELECT name,salay+bonus AS pay,
      year(startdate) AS startyear
     FROM emp)AS emp2
GROUP BY startyear;
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：查询雇员总收入大于200000的部门
SELECT deptno,totalpay
FROM (SELECT deptno,sum(salay)+sum(bonus) AS totalpay
     FROM emp
     GROUP BY deptno) AS payroll
WHERE totalpay>200000;
</code></pre>
<h5 id="（三）公共表表达式"><a href="#（三）公共表表达式" class="headerlink" title="（三）公共表表达式"></a>（三）公共表表达式</h5><p>一个公共表表达式可以当成一个临时视图，是一个在查询中定义的临时命名结果集将在from子句中使用它。它仅被定义一次(但在其作用域内可以被引用任意次)，并且在该查询生存期间将一直生存。可以用来执行递归操作。</p>
<p>WITH可以定义一个公共表表达式</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：利用WITH定义一个包含部门编号deptno和雇员总收入totalpay的临时表payroll，查询收入雇员收入最高的部门
WITH payroll (deptno,totalpay) AS
    (SELECT deptno,sum(salary)+sum(bonus)
    FROM emp
    GROUP BY deptno)
SELECT deptno
FROM payroll
WHERE totalpay=(SELECT max(totalpay)
               FROM payroll);
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：找出前一个部门的平均收入大于后一个部门平均收入二倍的部门对,将临时表自连接
WITH deptavg (deptno,avgsal) AS
    (SELECT deptno,avg(salary)
    FROM emp
    GROUP BY deptno)
SELECT d1.deptno,d1.avgsal,d2.deptno,d2.avgsal
FROM deptavg AS d1,deptavg AS d2
WHERE d1.avgsal>2*d2.avgsal;
</code></pre>
<h4 id="二、外连接"><a href="#二、外连接" class="headerlink" title="二、外连接"></a>二、外连接</h4><p>连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：查询所有老师（包括有课讲和没课讲）和所有课程（包括有人选和没人选）
WITH 
    innerjoin(name,rank,subject,enrollment) AS
        (SELECT t.name,t.rank,c.subject,c.enrollment
        FROM teachers As t,courses AS c
        WHERE t.name=c.teacher AND c.quarter='Fall 96'),
    teacher-only(name,rank) AS
        (SELECt name,rank
        FROM teachers
        EXCEPT ALL
        SELECT name,rank
        FROM innerjoin),
    course-only(subject,enrollment) AS
        (SELECT subject,enrollment
        FROM courses
        EXCEPT ALL
        SELECT subject,enrollment
        FROM innerjoin)
SELECT name,rank,subject,enrollment
FROM innerjoin
UNION ALL
SELECT name,rank
    CAST(NULL AS Varchar(20)) AS subject,
    CAST(NULL AS Integer) AS enrollment
FROM teacher-only
UNION ALL
SELECT CAST(NULL AS Varchar(20)) AS name,
       CAST(NULL AS Varchar(20)) AS rank,
       subject,enrollment
FROM course-only;
</code></pre>
<h4 id="三、递归查询"><a href="#三、递归查询" class="headerlink" title="三、递归查询"></a>三、递归查询</h4><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p>公用表表达式 (CTE) 可以认为是在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。公用表表达式可以包括对自身的引用，这种表达式称为递归公用表表达式。</p>
<p>例：航线查询：从 SFO —&gt; JFK 最便宜的航班：</p>
<p><img src="/2020/03/28/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan-er/D:/blog\Hexo\source\_posts\数据库系统的用户接口以及SQL语言（二）\图片一.png" alt></p>
<p><img src="/2020/03/28/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan-er/D:/blog\Hexo\source\_posts\数据库系统的用户接口以及SQL语言（二）\图片二.png" alt></p>
<p>设法建立临时表trips：第一项destination：从SFO出发可能到达的所有目的地；</p>
<p>​                                       第二项route：从SFO达到同一行的前一个目的地需要的路径；</p>
<p>​                                       第三项nsegs：为了达到目的地进行中转的次数；</p>
<p>​                                       第四项totalcost：按照路径route到达目的地所支付的钱。</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">WITH trips(destination,route,nsegs,totalcost)
    ((SELECT destination,CAST(destination AS varchar(20)),1,cost
     FROM flights                             -- initial query
     WHERE origin='SFO')
    UNION ALL
    (SELECT f.destination,
            CAST(t.route||','||f.destination AS varchar(20)),
            t.nsegs+1,t.totalcost+f.cost      -- ||:字符串拼接作用
    FROM trips t,flights f
    -- 因为是有向环，所以需要结束条件避免无限循环
    WHERE t.destination=f.origin
          AND f.destination<>'SFO'            -- stopping rule1
          AND f.origin<>'JFK'                 -- stopping rule2
          AND t.nsegs<=3))                    -- stopping rule3
SELECT route,totalcost
FROM trips
WHERE destination='JFK' AND totalcost=
                            (SELECT min(totalcost)
                            FROM trips
                            WHERE destination='JFK');
</code></pre>
<h4 id="四、数据操作语言"><a href="#四、数据操作语言" class="headerlink" title="四、数据操作语言"></a>四、数据操作语言</h4><h5 id="（一）Insert"><a href="#（一）Insert" class="headerlink" title="（一）Insert"></a>（一）Insert</h5><p>将元组插入到表中</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例：
INSERT INTO EMPLOYEES VALUES('Smith','John','1980-06-10');
</code></pre>
<h5 id="（二）Delete"><a href="#（二）Delete" class="headerlink" title="（二）Delete"></a>（二）Delete</h5><p>把满足一定条件的元组删除掉</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例：
DELETE FROM Person WHERE LastName='Rasmussen';
</code></pre>
<h5 id="（三）Update"><a href="#（三）Update" class="headerlink" title="（三）Update"></a>（三）Update</h5><p>把满足条件的元组按set子句的要求做更新</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例：
UPDATE Person SET Address='Zhongshan 23'
WHERE LastName='Wilson';
</code></pre>
<h4 id="五、嵌入式SQL（in-C为例）"><a href="#五、嵌入式SQL（in-C为例）" class="headerlink" title="五、嵌入式SQL（in C为例）"></a>五、嵌入式SQL（in C为例）</h4><p>​        嵌入式SQL(英文: Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。借此方法，可使得应用程序拥有了访问数据以及处理数据的能力。</p>
<h5 id="（一）概述："><a href="#（一）概述：" class="headerlink" title="（一）概述："></a>（一）概述：</h5><ol>
<li>以 <strong>EXEC SQL</strong> 开头，以 “ <strong>; </strong> ”  结尾</li>
<li>利用宿主变量在C与SQL间传递信息，且数组需要被<strong>EXEC SQL</strong>进行定义</li>
<li>宿主变量不能是数组或结构</li>
<li>一个特殊的宿主变量：SQLCA</li>
<li>用SQLCA.SQLCODE可以返回查询状态</li>
</ol>
<h5 id="（二）定义宿主变量"><a href="#（二）定义宿主变量" class="headerlink" title="（二）定义宿主变量"></a>（二）定义宿主变量</h5><pre class=" language-lang-c"><code class="language-lang-c">EXEC SQL BEGIN DECLARE SECTION;
    char SNO[7];
    char GIVENSNO[7];
    char CNO[6];
    char GOVENCNO[6];
    float GRADE;
    short GRADEI;
EXEC SQL END DECLARE SECTION;
</code></pre>
<h5 id="（三）可执行语句"><a href="#（三）可执行语句" class="headerlink" title="（三）可执行语句"></a>（三）可执行语句</h5><pre class=" language-lang-c"><code class="language-lang-c">//连接
EXEC SQL CONNECT:uid IDENTIFIED BY:pwd;
//执行DDL或DML语句，在SC表中插入元组
EXEC SQL INSERT INTO SC(SNO,CNO,GRADE)
         VALUES(:SNO,:CNO,:GRADE);  //插入的新元组的值
//查询某个学生某门课的成绩
EXEC SQL SELECT GRADE
         INTO :GRADE,:GRADEI
         FROM SC
         WHERE SNO=:GIVENSNO AND
               CNO=:GIVENCNO
</code></pre>
<h5 id="（四）游标Cursor"><a href="#（四）游标Cursor" class="headerlink" title="（四）游标Cursor"></a>（四）游标Cursor</h5><p>游标是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。可以把游标当做一个指针，它可以指定结果中的任何位置，然后允许用户对指定位置的数据进行处理。</p>
<pre class=" language-lang-c"><code class="language-lang-c">//查询某一门所有选修该课学生的学号以及考试成绩
EXEC SQL DECLARE C1 CURSOR FOR
        SELECT SNO,GRADE
        FROM SC
        WHERE CNO=:GIVENCNO;
EXEC SQL OPEN C1;
if(SQLCA.SQLCODE<0) exit(1);  //这里是查询警告
while(1){
    EXEC SQL FETCH C1 INTO :SNO,:GRADE,:GRADEI
    if(SQLCA.SQLCODE==100) break;
    ...//省略拿到返回值后的处理
}
EXEC SQL CLOSE C1;
...
</code></pre>
<pre class="mermaid">graph TD
    B[start]
    B--使用嵌入式SQL语句的宿主语言源代码-->C(预编译处理器);
    C--使用SQL库函数调用的宿主语言源代码-->D(编译程序);
    D(编译程序)--机器语言-->E(链接程序);
    F(SQL库函数)-->E(链接程序);
    E(链接程序)-->F(可执行语句);</pre>

<h5 id="（五）动态SQL"><a href="#（五）动态SQL" class="headerlink" title="（五）动态SQL"></a>（五）动态SQL</h5><h6 id="1-可直接执行的动态SQL"><a href="#1-可直接执行的动态SQL" class="headerlink" title="1.可直接执行的动态SQL"></a>1.可直接执行的动态SQL</h6><pre class=" language-lang-c"><code class="language-lang-c">//例：删除符合动态输入条件的学生
EXEC SQL BEGIN DECLARE SECTION;
char sqlstring[200];  //该数组用来输入执行的SQL语句
EXEC SQL END DECLARE SECTION;
char cond[150];  //该数组用来输入用户需要删除学生的满足条件
strcpy(sqlstring,"DELETE FROM STUDENT WHERE");
printf("Enter search condition:");
scanf("%s",cond);
strcat(sqlstring,cond);  //拼接语句
EXEC SQL EXECUTE IMMENDIATE :sqlstring;
</code></pre>
<h6 id="2-带动态参数的动态SQL"><a href="#2-带动态参数的动态SQL" class="headerlink" title="2.带动态参数的动态SQL"></a>2.带动态参数的动态SQL</h6><pre class=" language-lang-c"><code class="language-lang-c">//例：删除某一年之前出生的学生
EXEC SQL BEGIN DECLARE SECTION;
char sqlstring[200];  //该数组用来输入执行的SQL语句
int birth_year;  //定义出生年份的变量
EXEC SQL END DECLARE SECTION; 
strcpy(sqlstring,"DELETE FROM STUDENT WHERE YEAR(BDATE) <= :y;");  //y不是定义的变量，此处为占位符
printf("Enter birth year for delete :");
scanf("%d",&birth_year);
EXEC SQL PREPARE PURGE FROM:sqlstring;
EXEC SQL EXECUTE PURGE USING:birth_year;
</code></pre>
<h6 id="3-针对查询的动态SQL"><a href="#3-针对查询的动态SQL" class="headerlink" title="3.针对查询的动态SQL"></a>3.针对查询的动态SQL</h6><pre class=" language-lang-c"><code class="language-lang-c">EXEC SQL BEGIN DECLARE SECTION;
    char sqlstring[200];
    char SNO[7];
    float GRADE;
    short GRADEI;
    char GOVENCNO[6];
EXEC SQL END DECLARE SECTION;
char orderby[150];
strcpy(sqlstring,"SELECT SNO,GRADE FROM SC WHERE CNO=:c");
printf("Enter the ORDER BY clause:");
scanf("%s",orderby);
stract(sqlstring,orderby);
printf("Enter the course number:");
scanf("%s",GIVENCNO);
EXEC SQL PREPARE query FROM:sqlstring;
EXEC SQL DECLARE grade_cursor CURSOR FOR query;
EXEC sQL OPEN grade_cursor USING :GIVENCNO;
if(SQLCA.SQLCODE<0) exit(1);  //这里是查询警告
while(1){
    EXEC SQL FETCH grade_cursor INTO :SNO,:GRADE,:GRADEI
    if(SQLCA.SQLCODE==100) break;
    ...//省略拿到返回值后的处理
}
EXEC SQL CLOSE grade_cursor,
...
</code></pre>
<h4 id="六、存储过程"><a href="#六、存储过程" class="headerlink" title="六、存储过程"></a>六、存储过程</h4><h5 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h5><p>存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集。经编译后存储在数据库中。</p>
<p>存储过程是数据库中的一个重要对象，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p>
<p>存储过程是由 流控制 和 SQL语句书写的过程，这个过程经编译和优化后存储在数据库服务器中。</p>
<p>存储过程 可由应用程序通过一个调用来执行，而且允许用户声明变量。</p>
<p>同时，存储过程可以接收和输出参数、返回执行存储过程的状态值，也可以嵌套调用。</p>
<h5 id="（二）优点"><a href="#（二）优点" class="headerlink" title="（二）优点"></a>（二）优点</h5><ol>
<li><p>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</p>
</li>
<li><p>当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时)，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。</p>
</li>
<li>存储过程可以重复使用,可减少数据库开发人员的工作量。</li>
<li>安全性高,可设定只有某些用户才具有对指定存储过程的使用权。</li>
</ol>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：创建一个存储过程
create procedure porcedureName () 
begin 
    select name from user; 
end;  

-- 调用过程
call porcedureName ();

-- 删除存储过程
DROP PROCEDURE IF EXISTS porcedureName; -- 没有括号()
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>awk报告生成器</title>
    <url>/2020/03/26/awk-bao-gao-sheng-cheng-qi/</url>
    <content><![CDATA[<h4 id="一、awk介绍"><a href="#一、awk介绍" class="headerlink" title="一、awk介绍"></a>一、awk介绍</h4><h5 id="（一）gawk"><a href="#（一）gawk" class="headerlink" title="（一）gawk"></a>（一）gawk</h5><p>模式扫描和处理语言</p>
<a id="more"></a>
<h5 id="（二）基本用法"><a href="#（二）基本用法" class="headerlink" title="（二）基本用法"></a>（二）基本用法</h5><p>awk [options] ‘program’  var=value file…</p>
<p>awk [options] -f programfile  var=value file…</p>
<p>awk [options] ‘BEGIN{action;…} pattern{action;…} END{action;…}’ file…</p>
<p>awk程序通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共三部分组成</p>
<p>program通常是在单引号或双引号中</p>
<h5 id="（三）选项"><a href="#（三）选项" class="headerlink" title="（三）选项"></a>（三）选项</h5><p>-F ：指明输入时用到的字段分隔符；</p>
<p>-v var=value：自定义变量。</p>
<h5 id="（四）分割符、域和记录"><a href="#（四）分割符、域和记录" class="headerlink" title="（四）分割符、域和记录"></a>（四）分割符、域和记录</h5><ol>
<li>awk执行时，由分隔符分割的字段（域）标记$1,$2…$n称为域标识。$0为所有域，注意：和shell中变量$符含义不同；</li>
<li>文件的每一行称为记录；</li>
<li>省略action，则默认执行print $0的操作。</li>
</ol>
<h5 id="（五）print格式"><a href="#（五）print格式" class="headerlink" title="（五）print格式"></a>（五）print格式</h5><p>print item1,item2,…</p>
<ol>
<li>逗号分隔符；</li>
<li>输出的各item可以是字符串，也可以是数值；当前记录的字段、变量或awk的表达式；</li>
<li>如省略item，相当于print $0。</li>
</ol>
<pre><code>例：查看分区利用率
[root@localhost ~]# df |awk &#39;{print $5}&#39;
已用%
18%
0%
0%
2%
0%
13%
0%
</code></pre><h4 id="二、awk变量"><a href="#二、awk变量" class="headerlink" title="二、awk变量"></a>二、awk变量</h4><h5 id="（一）变量"><a href="#（一）变量" class="headerlink" title="（一）变量"></a>（一）变量</h5><p>内置和自定义变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认为空白字符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认为空白字符</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，指定输入时的换行符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符，输出时用指定符号代替换行符</td>
</tr>
<tr>
<td>NF</td>
<td>字段数量</td>
</tr>
<tr>
<td>NR</td>
<td>记录号</td>
</tr>
<tr>
<td>FNR</td>
<td>各文件分别计数，记录号</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前文件名</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数的个数</td>
</tr>
<tr>
<td></td>
<td>数组，保存的是命令行所给定的各参数</td>
</tr>
</tbody>
</table>
</div>
<pre><code>例：查询文件最后一个字段并标注记录号
[root@localhost etc]# awk -F: &#39;{print NR,$NF}&#39; /etc/passwd
1 /bin/bash
2 /sbin/nologin
3 /sbin/nologin
4 /sbin/nologin
......
</code></pre><h5 id="（二）自定义变量"><a href="#（二）自定义变量" class="headerlink" title="（二）自定义变量"></a>（二）自定义变量</h5><p>​    （1）-v var=value；</p>
<p>​    （2）在program中直接定义。</p>
<pre><code>例：打印自定义变量
[root@localhost ~]# awk -v test=&quot;hello awk&quot; &#39;{print test}&#39; /etc/fstab
hello awk
hello awk
......
[root@localhost ~]# awk &#39;{test=&quot;test awk&quot;;print test}&#39; /etc/fstab
test awk
test awk
......
</code></pre><pre><code>例：打印
[root@localhost ~]# awk -F: &#39;BEGIN{printf &quot;username          userid\n---------------------------\n&quot;}{printf &quot;%-20s |%-10d\n&quot;,$1,$3}&#39; /etc/passwd
username          userid
---------------------------
root                 |0         
bin                  |1         
daemon               |2         
adm                  |3     
......
</code></pre><h4 id="三、操作符"><a href="#三、操作符" class="headerlink" title="三、操作符"></a>三、操作符</h4><h5 id="（一）算术操作符"><a href="#（一）算术操作符" class="headerlink" title="（一）算术操作符"></a>（一）算术操作符</h5><p>​        x+y,x-y,x*y……</p>
<p>​        -x：转换为负数；</p>
<p>​        +x：转换为负数。</p>
<h5 id="（二）字符串操作符"><a href="#（二）字符串操作符" class="headerlink" title="（二）字符串操作符"></a>（二）字符串操作符</h5><p>​        没有符号的操作符，字符串连接。</p>
<h5 id="（三）赋值操作符"><a href="#（三）赋值操作符" class="headerlink" title="（三）赋值操作符"></a>（三）赋值操作符</h5><p>​        =，+=，-=，++，—……</p>
<h5 id="（四）比较操作符"><a href="#（四）比较操作符" class="headerlink" title="（四）比较操作符"></a>（四）比较操作符</h5><p>​        ==,!=,&gt;,&gt;=,&lt;,&lt;=…..</p>
<h5 id="（五）模式匹配符"><a href="#（五）模式匹配符" class="headerlink" title="（五）模式匹配符"></a>（五）模式匹配符</h5><p>​        ~：左边是否和右边匹配包含；</p>
<p>​        !~：是否不匹配。</p>
<h5 id="（六）逻辑运算符"><a href="#（六）逻辑运算符" class="headerlink" title="（六）逻辑运算符"></a>（六）逻辑运算符</h5><p>​        与&amp;&amp;，或||，非！</p>
<h5 id="（七）函数调用"><a href="#（七）函数调用" class="headerlink" title="（七）函数调用"></a>（七）函数调用</h5><p>​        function_name(argu1,argu2,…)</p>
<h5 id="（八）条件表达式（三目表达式）"><a href="#（八）条件表达式（三目表达式）" class="headerlink" title="（八）条件表达式（三目表达式）"></a>（八）条件表达式（三目表达式）</h5><p>​        selector?if-true-expression:if-false-expression</p>
<pre><code>#示例：
[root@localhost ~]# awk -F: &#39;$3 &lt;= 1000 &amp;&amp; $3 &gt;=100 {print $0}&#39; /etc/passwd
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
polkitd:x:999:997:User for polkitd:/:/sbin/nologin
chrony:x:998:996::/var/lib/chrony:/sbin/nologin
......
</code></pre><pre><code>#三目表达式
[root@localhost ~]# awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;system user&quot;;printf &quot;%-12s:%-20s:%-6d\n&quot;,usertype,$1,$3&#39;} /etc/passwd
system user :root                :0     
system user :bin                 :1     
system user :daemon              :2     
......
common user :git                 :1235  
......
</code></pre><h4 id="四、控制语句"><a href="#四、控制语句" class="headerlink" title="四、控制语句"></a>四、控制语句</h4><h5 id="（一）if-else"><a href="#（一）if-else" class="headerlink" title="（一）if-else"></a>（一）if-else</h5><h6 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h6><p>if(condition){statement;…}[else statement]</p>
<p>if(condiftion 1){statement1} else if(condition2){statement2}</p>
<p>​            else{statement3}</p>
<h6 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h6><p>对awk取得的整行或某个字段做条件判断</p>
<pre><code>#例：
[root@localhost ~]# awk &#39;BEGIN{test=100;if(test&gt;90){print &quot;very good&quot;} else if(test&gt;60){print &quot;good&quot;} else{print &quot;no pass&quot;}}&#39;
very good
</code></pre><h5 id="（二）while循环"><a href="#（二）while循环" class="headerlink" title="（二）while循环"></a>（二）while循环</h5><h6 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1.语法"></a>1.语法</h6><p>while(condition){statement;…}</p>
<p>条件“真”：进入循环；    条件“假”：退出循环</p>
<h6 id="2-使用场景-1"><a href="#2-使用场景-1" class="headerlink" title="2.使用场景"></a>2.使用场景</h6><p>对一行内的多个字段逐一类似处理时使用</p>
<p>对数组中的各元素逐一处理时使用</p>
<pre><code>#例：打印文件每个字段的长度
[root@localhost ~]# awk -F: &#39;{i=1;while(i&lt;=NF){print $i,length($i);i++}}&#39; /etc/passwd
root 4
x 1
0 1
0 1
root 4
/root 5
/bin/bash 9
......
</code></pre><pre><code>#例：累加
[root@localhost ~]# awk &#39;BEGIN{sum=0;i=1;while(i&lt;=100){sum+=i;i++};print &quot;sum=&quot;sum}&#39;
sum=5050
</code></pre><h5 id="（三）do-while循环"><a href="#（三）do-while循环" class="headerlink" title="（三）do-while循环"></a>（三）do-while循环</h5><h6 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1.语法"></a>1.语法</h6><p>do {statement;…}while(condition)</p>
<h6 id="2-意义"><a href="#2-意义" class="headerlink" title="2.意义"></a>2.意义</h6><p>无论真假，至少执行一次循环体</p>
<pre><code>#例：累加
[root@localhost ~]# awk &#39;BEGIN{local=0;i=0;do{total+=i;i++}while(i&lt;=100);print total}&#39;
5050
</code></pre><h5 id="（四）for循环"><a href="#（四）for循环" class="headerlink" title="（四）for循环"></a>（四）for循环</h5><h6 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1.语法"></a>1.语法</h6><p>for(expr1;expr2;expr3){statement;….}</p>
<h6 id="2-常见用法"><a href="#2-常见用法" class="headerlink" title="2.常见用法"></a>2.常见用法</h6><p>for(variable assignment;condiftion;iteration process)</p>
<p>​            {for-body}</p>
<h6 id="3-特殊用法"><a href="#3-特殊用法" class="headerlink" title="3.特殊用法"></a>3.特殊用法</h6><p>能够遍历数组中的元素： for(var in array){for-body}</p>
<pre><code>例：累加
[root@localhost ~]# awk &#39;BEGIN{for(sum=0;i&lt;=100;i++){sum+=i}print sum}&#39;
5050
</code></pre><pre><code>#continue中断
[root@localhost ~]# awk &#39;BEGIN{for(sum=0;i&lt;=100;i++){if(i==50)continue;sum+=i}print sum}&#39;
5000
#break退出
[root@localhost ~]# awk &#39;BEGIN{for(sum=0;i&lt;=100;i++){if(i==50)break;sum+=i}print sum}&#39;
1225
</code></pre><h6 id="4-next"><a href="#4-next" class="headerlink" title="4.next"></a>4.next</h6><p>提前结束对本行处理而直接进入下一行处理（awk自身循环）</p>
<h4 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h4><p>若要遍历数组中的每个元素，要是用for循环：for(var in array){for-body}</p>
<p>注：var会遍历array的每个索引</p>
<pre><code>#例：
[root@localhost ~]# awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;yue&quot;]=&quot;Tuesday&quot;;for(i in weekdays){print weekdays[i]}}&#39;
Tuesday
Monday
</code></pre><pre><code>#例：查看监听状况数量
[root@localhost ~]# netstat -tan |awk &#39;/^tcp/{state[$NF]++}END{for(i in state){print i,state[i]}}&#39;
LISTEN 4
ESTABLISHED 1
</code></pre><h4 id="六、awk函数"><a href="#六、awk函数" class="headerlink" title="六、awk函数"></a>六、awk函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rand()</td>
<td>返回0和1之间一个随机数</td>
</tr>
<tr>
<td>length([s])</td>
<td>返回指定字符串的长度</td>
</tr>
<tr>
<td>sub(r,s,[t])</td>
<td>对t字符串进行搜索r表示的模式匹配的内容，并将第一个匹配的内容替换为s</td>
</tr>
<tr>
<td>gsub(r,s,[t])</td>
<td>对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容</td>
</tr>
<tr>
<td>split(s,array,[r])</td>
<td>以r为分隔符，切割字符串s，并将切割后的结果保存至array所表示的数组中，第一个索引值为1，第二个索引值为2，…</td>
</tr>
</tbody>
</table>
</div>
<pre><code>#例：
[root@localhost log]# echo &quot;2008:08:08 08:08:08&quot; |awk &#39;gsub(/:/,&quot;-&quot;,$0)&#39;
2008-08-08 08-08-08
[root@localhost log]# echo &quot;2008:08:08 08:08:08&quot; |awk &#39;gsub(/:/,&quot;-&quot;,$1)&#39;
2008-08-08 08:08:08
</code></pre><pre><code>#统计连接主机IP的连接次数
[root@localhost ~]# netstat -tan
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     
tcp        0      0 10.0.2.15:22            10.0.2.2:3194           ESTABLISHED
tcp6       0      0 :::22                   :::*                    LISTEN     
tcp6       0      0 ::1:25                  :::*                    LISTEN     
[root@localhost ~]# netstat -tan |awk &#39;/^tcp\&gt;/{split($5,ip,&quot;:&quot;);count[ip[1]]++}END{for(i in count){print i,count[i]}}&#39;
0.0.0.0 2     #0.0.0.0 IP连接两次
10.0.2.2 1    #10.0.2.2 IP连接一次
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sed工具</title>
    <url>/2020/03/25/sed-gong-ju/</url>
    <content><![CDATA[<h4 id="一、sed介绍"><a href="#一、sed介绍" class="headerlink" title="一、sed介绍"></a>一、sed介绍</h4><p>Stream EDitor，行编辑器</p>
<p>sed是一种流编辑器，它一次处理一行的内容。处时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<a id="more"></a>
<p>功能：主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等。</p>
<h4 id="二、sed工具"><a href="#二、sed工具" class="headerlink" title="二、sed工具"></a>二、sed工具</h4><h5 id="（一）用法"><a href="#（一）用法" class="headerlink" title="（一）用法"></a>（一）用法</h5><pre><code>sed [option]...&#39;script&#39; inputfile
#script：&#39;地址命令&#39;
</code></pre><h5 id="（二）常用选项"><a href="#（二）常用选项" class="headerlink" title="（二）常用选项"></a>（二）常用选项</h5><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>不输出模式空间内容到屏幕，即不自动打印</td>
</tr>
<tr>
<td>-e</td>
<td>多点编辑</td>
</tr>
<tr>
<td>-f:/PATH/SCRIPT_FILE</td>
<td>从指定文件中读取编辑脚本</td>
</tr>
<tr>
<td>-r</td>
<td>支持使用扩展正则表达式</td>
</tr>
<tr>
<td>-i.bak</td>
<td>备份文件并原处编辑</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（三）地址定界"><a href="#（三）地址定界" class="headerlink" title="（三）地址定界"></a>（三）地址定界</h5><h6 id="1-不给地址"><a href="#1-不给地址" class="headerlink" title="1.不给地址"></a>1.不给地址</h6><p>​    对全文进行处理；</p>
<h6 id="2-单地址"><a href="#2-单地址" class="headerlink" title="2.单地址"></a>2.单地址</h6><ol>
<li><p>#：指定的行，$：最后一行；</p>
</li>
<li><p>/pattern/：被此处模式所能够匹配到的每一行。</p>
</li>
</ol>
<h6 id="3-地址范围"><a href="#3-地址范围" class="headerlink" title="3.地址范围"></a>3.地址范围</h6><p>​    #,#        #,+#        /pat1/,/pat2/        #,/pat1/</p>
<h6 id="4-：步进"><a href="#4-：步进" class="headerlink" title="4.~：步进"></a>4.~：步进</h6><p>​    1~2：奇数行；    2~2：偶数行。</p>
<h5 id="（四）编辑命令"><a href="#（四）编辑命令" class="headerlink" title="（四）编辑命令"></a>（四）编辑命令</h5><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>删除模式空间匹配的行，并立即启用下一轮循环</td>
</tr>
<tr>
<td>p</td>
<td>打印当前模式空间内容，追加到默认输出之后</td>
</tr>
<tr>
<td>a [\]text</td>
<td>在指定行后面追加文本（支持使用\n实现多行追加）</td>
</tr>
<tr>
<td>i [\]text</td>
<td>在行前面插入文本</td>
</tr>
<tr>
<td>c [\]text</td>
<td>替换行为单行或多行文本</td>
</tr>
<tr>
<td>w /path/somefile</td>
<td>保存模式匹配的行至指定文件</td>
</tr>
<tr>
<td>r /path/somefile</td>
<td>读取指定文件的文本至模式空间中（匹配到的行后）</td>
</tr>
<tr>
<td>=</td>
<td>为模式空间中的行打印行号</td>
</tr>
<tr>
<td>!</td>
<td>模式空间中匹配行取反处理</td>
</tr>
<tr>
<td>s///</td>
<td>查找替换，支持使用其他分隔符，s@@@,s###</td>
</tr>
</tbody>
</table>
</div>
<pre><code>#例：利用查询并仅显示enp0s3的IP
[root@localhost ~]# ifconfig enp0s3
enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::1e79:d487:1182:62be  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 08:00:27:a5:2e:c5  txqueuelen 1000  (Ethernet)
        RX packets 56725  bytes 50370820 (48.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 34698  bytes 2855108 (2.7 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@localhost ~]# ifconfig |sed -n &#39;2p&#39; |sed -e &#39;s/^.*net //&#39; -e &#39;s/ netmask.*//&#39; 
10.0.2.15
</code></pre><h5 id="（五）高级编辑命令"><a href="#（五）高级编辑命令" class="headerlink" title="（五）高级编辑命令"></a>（五）高级编辑命令</h5><ol>
<li>模式空间：可以想成工程里面的流水线，数据之间在它上面进行处理。</li>
<li>保持空间：可以想象成仓库，我们在进行数据处理的时候，作为数据的暂存区域。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>打印模式空间开端至\n内容，并追加到默认输出之前</td>
</tr>
<tr>
<td>h</td>
<td>把模式空间中的内容覆盖至保持空间中</td>
</tr>
<tr>
<td>H</td>
<td>把模式空间中的内容追加至保持空间中</td>
</tr>
<tr>
<td>g</td>
<td>从保持空间取出数据覆盖至模式空间</td>
</tr>
<tr>
<td>G</td>
<td>从保持空间取出内容追加至模式空间</td>
</tr>
<tr>
<td>x</td>
<td>把模式空间中的内容与保持空间中的内容进行互换</td>
</tr>
<tr>
<td>n</td>
<td>读取匹配到的行的下一行覆盖至模式空间</td>
</tr>
<tr>
<td>N</td>
<td>读取匹配到的行的下一行追加至模式空间</td>
</tr>
<tr>
<td>D</td>
<td>如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环。</td>
</tr>
</tbody>
</table>
</div>
<p>​    例：</p>
<pre><code>#只打印偶数行
[root@localhost ~]# seq 10 |sed -n &#39;n;p&#39;
2
4
6
8
10
#倒序打印
[root@localhost ~]# seq 10 |sed &#39;1!G;h;$!d&#39;
10
9
8
7
6
5
4
3
2
1
只打印最后一行
[root@localhost ~]# seq 10 |sed &#39;N;D&#39;
10
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim编辑器</title>
    <url>/2020/03/24/vim-bian-ji-qi/</url>
    <content><![CDATA[<h4 id="七、Vim编辑器"><a href="#七、Vim编辑器" class="headerlink" title="七、Vim编辑器"></a>七、Vim编辑器</h4><h5 id="（一）打开文件"><a href="#（一）打开文件" class="headerlink" title="（一）打开文件"></a>（一）打开文件</h5><pre><code># vim [OPTION]...FILE...
</code></pre><a id="more"></a>
<ol>
<li><p>+#：打开文件后，让光标处于第#行的行首，+默认行尾；</p>
</li>
<li><p>+/PATTERN：打开文件后，直接让光标处于第一个被PATTERN匹配到的行首；</p>
</li>
<li>-b file：二进制方式打开文件；</li>
<li>-d file1 file2…：比较多个文件；</li>
<li>-m file：打开只读文件；</li>
<li>ex file或vim -e 直接进入ex模式；</li>
<li>如果改文件存在，文件被打开并显示内容；如果不存在，当编辑后第一次存盘时创建它。</li>
</ol>
<h5 id="（二）vim模式"><a href="#（二）vim模式" class="headerlink" title="（二）vim模式"></a>（二）vim模式</h5><p><img src="/2020/03/24/vim-bian-ji-qi/图片二.png" alt></p>
<h5 id="（三）模式转换"><a href="#（三）模式转换" class="headerlink" title="（三）模式转换"></a>（三）模式转换</h5><ol>
<li><p>命令模式 —&gt; 插入模式</p>
<p>​    i：insert，当光标所在处输入；</p>
<p>​    I：在当前光标所在行的行首输入；</p>
<p>​    a：append，在光标所在处后面输入；</p>
<p>​    A：在当前光标所在行的行尾输入；</p>
<p>​    o：在当前光标所在行的下方打开一个新行；</p>
<p>​    O：在当前光标所在行的上方打开一个新行。</p>
</li>
<li><p>插入模式 —&gt; 命令模式：ESC</p>
</li>
<li>命令模式 —&gt; 扩展命令模式：：</li>
<li>扩展命令模式 —&gt; 命令模式：ESC，enter</li>
</ol>
<h5 id="（四）关闭文件"><a href="#（四）关闭文件" class="headerlink" title="（四）关闭文件"></a>（四）关闭文件</h5><h6 id="1-扩展模式："><a href="#1-扩展模式：" class="headerlink" title="1.扩展模式："></a>1.扩展模式：</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出，丢弃你做出的修改</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:x</td>
<td>保存退出</td>
</tr>
<tr>
<td>:w</td>
<td>写（存）磁盘文件</td>
</tr>
<tr>
<td>:r filename</td>
<td>读文件内容到当前文件中</td>
</tr>
<tr>
<td>:w filename</td>
<td>读当前文件内容写入另一个文件</td>
</tr>
<tr>
<td>:r!command</td>
<td>读入命令的输出</td>
</tr>
<tr>
<td>:!command</td>
<td>执行命令</td>
</tr>
</tbody>
</table>
</div>
<h6 id="2-命令模式："><a href="#2-命令模式：" class="headerlink" title="2.命令模式："></a>2.命令模式：</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
<tr>
<td>ZQ</td>
<td>不保存退出</td>
</tr>
</tbody>
</table>
</div>
<h6 id="3-命令模式光标跳转"><a href="#3-命令模式光标跳转" class="headerlink" title="3.命令模式光标跳转"></a>3.命令模式光标跳转</h6><p>（1）字符间跳转：</p>
<p>​        h：左；    l：右；    j：下；    k：上；</p>
<p>​        #COMMAND：跳转由#指定的个数的字符。</p>
<p>（2）单词间跳转</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>下一个单词的词首</td>
</tr>
<tr>
<td>e</td>
<td>当前或下一单词的词尾</td>
</tr>
<tr>
<td>b</td>
<td>当前或前一个单词的词首</td>
</tr>
<tr>
<td>#COMMAND</td>
<td>由#指定一次跳转的单词数</td>
</tr>
</tbody>
</table>
</div>
<p>（3）当前页跳转</p>
<p>​        H：页首；    M：页中间行；    L：页底。</p>
<p>（4）行首行尾跳转</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>跳转至行首的第一个非空白符</td>
</tr>
<tr>
<td>0</td>
<td>跳转至行首</td>
</tr>
<tr>
<td>$</td>
<td>跳转至行尾</td>
</tr>
</tbody>
</table>
</div>
<p>（5）行间移动</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>最后一行</td>
</tr>
<tr>
<td>1G/gg</td>
<td>第一行</td>
</tr>
</tbody>
</table>
</div>
<p>（6）句间移动</p>
<p>​        )：下一句；    （：上一句</p>
<p>（7）段落间移动</p>
<p>​        }：下一段；    {：上一段</p>
<h6 id="4-字符编辑"><a href="#4-字符编辑" class="headerlink" title="4.字符编辑"></a>4.字符编辑</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标处的字符</td>
</tr>
<tr>
<td>#x</td>
<td>删除光标处起始的#个字符</td>
</tr>
<tr>
<td>xp</td>
<td>交换光标所在处的字符及其后面的字符的位置</td>
</tr>
<tr>
<td>~</td>
<td>转换大小写</td>
</tr>
<tr>
<td>J</td>
<td>删除当前行后的换行符</td>
</tr>
</tbody>
</table>
</div>
<h6 id="5-替换命令"><a href="#5-替换命令" class="headerlink" title="5.替换命令"></a>5.替换命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>替换光标所在处的字符</td>
</tr>
<tr>
<td>R</td>
<td>切换成REPLACE模式</td>
</tr>
</tbody>
</table>
</div>
<h6 id="6-删除命令"><a href="#6-删除命令" class="headerlink" title="6.删除命令"></a>6.删除命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>删除命令，可结合光标跳转字符，实现范围删除</td>
</tr>
<tr>
<td>d$</td>
<td>删除到行尾</td>
</tr>
<tr>
<td>d^</td>
<td>删除到非空行首</td>
</tr>
<tr>
<td>d0</td>
<td>删除到行首</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的行</td>
</tr>
<tr>
<td>#dd</td>
<td>多行删除</td>
</tr>
<tr>
<td>D</td>
<td>从当前光标位置一直删除到行尾，留空行，等同于d$</td>
</tr>
</tbody>
</table>
</div>
<h6 id="7-复制命令"><a href="#7-复制命令" class="headerlink" title="7.复制命令"></a>7.复制命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>复制，行为相似于d命令</td>
</tr>
<tr>
<td>yy</td>
<td>复制行</td>
</tr>
<tr>
<td>Y</td>
<td>复制整行</td>
</tr>
</tbody>
</table>
</div>
<h6 id="8-粘贴命令"><a href="#8-粘贴命令" class="headerlink" title="8.粘贴命令"></a>8.粘贴命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，粘贴至当前光标所在处的后面；</td>
</tr>
<tr>
<td>P</td>
<td>缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，粘贴至当前光标所在处的前面；</td>
</tr>
</tbody>
</table>
</div>
<h6 id="9-改变命令"><a href="#9-改变命令" class="headerlink" title="9.改变命令"></a>9.改变命令</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>修改后切换成插入模式</td>
</tr>
<tr>
<td>cc</td>
<td>删除当前行并输入新内容，相当于S</td>
</tr>
<tr>
<td>C</td>
<td>删除当前光标到行尾，并切换成插入模式</td>
</tr>
</tbody>
</table>
</div>
<h6 id="10-地址定界"><a href="#10-地址定界" class="headerlink" title="10.地址定界"></a>10.地址定界</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>具体第#行，例如2表示第2行</td>
</tr>
<tr>
<td>#，#</td>
<td>从左侧#表示起始行，到右侧#表示结尾行</td>
</tr>
<tr>
<td>#，+#</td>
<td>从左侧#表示的起始行，加上右侧#表示的行数：2，+3   表示2到5行</td>
</tr>
<tr>
<td>.</td>
<td>当前行</td>
</tr>
<tr>
<td>$</td>
<td>最后一行</td>
</tr>
<tr>
<td>%</td>
<td>全文，相当于1，$</td>
</tr>
</tbody>
</table>
</div>
<h6 id="11-查找"><a href="#11-查找" class="headerlink" title="11.查找"></a>11.查找</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PATTERN</td>
<td>从当前光标所在处向文件尾部查找</td>
</tr>
<tr>
<td>?PATTERN</td>
<td>从当前光标所在处向文件首部查找</td>
</tr>
<tr>
<td>n</td>
<td>与命令同方向</td>
</tr>
<tr>
<td>N</td>
<td>与命令反方向</td>
</tr>
</tbody>
</table>
</div>
<h6 id="12-查找并替换"><a href="#12-查找并替换" class="headerlink" title="12.查找并替换"></a>12.查找并替换</h6><p>​        s：在扩展模式下完成查找替换操作</p>
<p>​                格式：s/要查找的内容/替换为的内容/修饰符</p>
<p>​                可以使用”&amp;“引用前面查找是查找到的整个内容</p>
<h6 id="13-撤销更改"><a href="#13-撤销更改" class="headerlink" title="13.撤销更改"></a>13.撤销更改</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤销最近的更改</td>
</tr>
<tr>
<td>#u</td>
<td>撤销之前的多次更改</td>
</tr>
<tr>
<td>U</td>
<td>撤销光标落在这行后所有此行的更改</td>
</tr>
<tr>
<td>Ctrl -r</td>
<td>重做最后的“撤销”更改</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个操作</td>
</tr>
<tr>
<td>n.</td>
<td>重复前一个操作n次</td>
</tr>
</tbody>
</table>
</div>
<h6 id="14-可视化模式"><a href="#14-可视化模式" class="headerlink" title="14.可视化模式"></a>14.可视化模式</h6><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>面向字符</td>
</tr>
<tr>
<td>V</td>
<td>面向行</td>
</tr>
<tr>
<td>ctrl -v</td>
<td>面向块</td>
</tr>
</tbody>
</table>
</div>
<h6 id="15-多窗口"><a href="#15-多窗口" class="headerlink" title="15.多窗口"></a>15.多窗口</h6><p>​    （1）多文件分割</p>
<p>​                vim -o|-O FILE1 FILE2…</p>
<p>​                -o：水平分割；    -O：垂直分割。</p>
<p>​    （2）单文件窗口分割</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+w,s</td>
<td>水平分割</td>
</tr>
<tr>
<td>Ctrl+w,v</td>
<td>垂直分割</td>
</tr>
<tr>
<td>Ctrl+w,q</td>
<td>取消相邻窗口</td>
</tr>
<tr>
<td>Ctrl+w,o</td>
<td>取消全部窗口</td>
</tr>
<tr>
<td>:wqall</td>
<td>退出</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统的用户接口以及SQL语言（一）</title>
    <url>/2020/03/18/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan/</url>
    <content><![CDATA[<h4 id="一、DBMS的用户数据接口"><a href="#一、DBMS的用户数据接口" class="headerlink" title="一、DBMS的用户数据接口"></a>一、DBMS的用户数据接口</h4><h5 id="（一）查询语言；"><a href="#（一）查询语言；" class="headerlink" title="（一）查询语言；"></a>（一）查询语言；</h5><p>​        形式化查询语言 Formal Query Language</p>
<a id="more"></a>
<p>​        表格式查询语言 Tabular Query Language</p>
<p>​        图形化查询语言 Graphic Query Language</p>
<p>​        受限的自然语言 Limited Natural Language Query Language</p>
<h5 id="（二）图形化用户工具（GUI）"><a href="#（二）图形化用户工具（GUI）" class="headerlink" title="（二）图形化用户工具（GUI）"></a>（二）图形化用户工具（GUI）</h5><h5 id="（三）APIs：应用程序的访问接口"><a href="#（三）APIs：应用程序的访问接口" class="headerlink" title="（三）APIs：应用程序的访问接口"></a>（三）APIs：应用程序的访问接口</h5><h5 id="（四）Class-Library：类库"><a href="#（四）Class-Library：类库" class="headerlink" title="（四）Class Library：类库"></a>（四）Class Library：类库</h5><h4 id="二、SQL-Language"><a href="#二、SQL-Language" class="headerlink" title="二、SQL Language"></a>二、SQL Language</h4><h5 id="（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询-，插入，更新和删除等操作"><a href="#（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询-，插入，更新和删除等操作" class="headerlink" title="（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询 ，插入，更新和删除等操作"></a>（一）数据操纵语言（DML）：主要用来处理数据库中的数据内容。允许用户对数据库中的数据进行查询 ，插入，更新和删除等操作</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DML语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>从表或视图中检索数据行</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据到表或视图</td>
</tr>
<tr>
<td>UPDATE</td>
<td>更新数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>CALL</td>
<td>调用过程</td>
</tr>
<tr>
<td>MERGE</td>
<td>合并（插入或修改）</td>
</tr>
<tr>
<td>COMMIT</td>
<td>将当前事务所做的更改永久化（写入数据库）</td>
</tr>
<tr>
<td>ROLLBACK</td>
<td>取消上次提交以来的所有操作</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（二）数据定义语言（DDL）-是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。"><a href="#（二）数据定义语言（DDL）-是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。" class="headerlink" title="（二）数据定义语言（DDL）:是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。"></a>（二）数据定义语言（DDL）:是一组SQL命令，用于创建和定义数据库对象，并且将对这些对象的定义保存到数据字典中。通过DDL语句可以创建数据库对象，修改数据库对象和删除数据库对象等。</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DDL语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>创建数据库结构</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改数据库结构</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库结构</td>
</tr>
<tr>
<td>RENAME</td>
<td>更改数据库对象的名称</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>删除表的全部内容</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种："><a href="#（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种：" class="headerlink" title="（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种："></a>（三）数据控制语言（DCL）：数据控制语言用于修改数据库结构的操作权限。DCL语句主要有2种：</h5><div class="table-container">
<table>
<thead>
<tr>
<th>DCL语句</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRANT</td>
<td>授予其他用户对数据库结构的访问权限</td>
</tr>
<tr>
<td>REVOKE</td>
<td>收回用户访问数据库结构的权限</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三、基本SQL查询"><a href="#三、基本SQL查询" class="headerlink" title="三、基本SQL查询"></a>三、基本SQL查询</h4><p>​    SELECT        [DISTINCT（用来消除重复元组）] target-list</p>
<p>​    FROM          relation-list</p>
<p>​    WHERE        qualification（结果应该满足的条件）</p>
<p>例表：</p>
<p>R：水手预定船的信息表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sid（水手编号）</th>
<th>bid（船编号）</th>
<th>day（预定船日期）</th>
</tr>
</thead>
<tbody>
<tr>
<td>22</td>
<td>101</td>
<td>10/10/96</td>
</tr>
<tr>
<td>58</td>
<td>103</td>
<td>11/12/96</td>
</tr>
</tbody>
</table>
</div>
<p>B：船的信息表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>bid</th>
<th>bname</th>
<th>color</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>tiger</td>
<td>red</td>
</tr>
<tr>
<td>103</td>
<td>lion</td>
<td>green</td>
</tr>
<tr>
<td>105</td>
<td>hero</td>
<td>blue</td>
</tr>
</tbody>
</table>
</div>
<p>S：水手基本信息表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sid</th>
<th>sname</th>
<th>rating</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>22</td>
<td>Dustin</td>
<td>7</td>
<td>45.0</td>
</tr>
<tr>
<td>31</td>
<td>Ludder</td>
<td>8</td>
<td>55.5</td>
</tr>
<tr>
<td>58</td>
<td>Rusty</td>
<td>10</td>
<td>35.0</td>
</tr>
</tbody>
</table>
</div>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">嵌套查询实例1：查询订了103号船的水手
SELECT S.name
FROM Sailors
WHERE EXISTS（SELECT *
                FROM Reserves R
                WHERE R.bid=103 AND S.sid=R.sid）
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">嵌套查询实例2：查询比名字叫Horatio水手级别高的所有人
SELECT *
FROM Sailors S
WHERE S.rating > ANY（SELECT S2.rating
                        FROM Sailors S2
                        WHERE S2.sname='Horatio'）
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">嵌套查询实例3：查询订了所有船的水手(利用否定之否定，即没有一条船没有订过的水手)
SELECT S.name
FROM Sailors S
WHERE NOT EXISTS（SELECT B.bid
                 FROM Boats B
                 WHERE NOT EXISTS(SELECT R.bid
                                 FROM Reserves R
                                 WHERE R.bid=B.bid
                                 AND R.sid=S.sid))
</code></pre>
<h4 id="四、聚集函数运算"><a href="#四、聚集函数运算" class="headerlink" title="四、聚集函数运算"></a>四、聚集函数运算</h4><h5 id="（一）函数说明"><a href="#（一）函数说明" class="headerlink" title="（一）函数说明"></a>（一）函数说明</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(*)</td>
<td>统计关系内有多少元组</td>
</tr>
<tr>
<td>COUNT([DISTINCT] A)</td>
<td>计算关系中属性A有多少个不同的值</td>
</tr>
<tr>
<td>SUM([DISTINCT] A)</td>
<td>在A属性上的不同的值做求和</td>
</tr>
<tr>
<td>AVG([DISTINCT] A)</td>
<td>在A的属性上的不同的值做平均值</td>
</tr>
<tr>
<td>MAX(A)</td>
<td>求A的属性上的所有值中的最大值</td>
</tr>
<tr>
<td>MIN(A)</td>
<td>求A的属性上的所有值中的最小值</td>
</tr>
</tbody>
</table>
</div>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例1：查询所有叫Bob的水手有多少个不同的级别
SELECT COUNT(DISTINCT S.rating)
FROM Sailors S
WHERE S.sname='Bob'
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例2：查询所有级别为10的水手的不同年龄的平均值（不是所有水手的年龄平均值）
SELECT AVG(DISTINCT S.age)
FROM Sailors S
WHERE S.rating=10
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例3：查询最大级别水手的名单
SELECT S.sname
FROM Sailors S
WHERE S.rating=(SELECT MAX(S2.rating)
               FROM Sailors S2)
</code></pre>
<h5 id="（二）关键字"><a href="#（二）关键字" class="headerlink" title="（二）关键字"></a>（二）关键字</h5><h6 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="1.GROUP BY"></a>1.GROUP BY</h6><p>​        对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p>
<p>​        在使用group by的SQL语句中，select中返回的字段，必须包含在group by语句的后面，作为分组的依据；且这些字段须包含在聚合函数中。</p>
<h6 id="2-HAVING"><a href="#2-HAVING" class="headerlink" title="2.HAVING"></a>2.HAVING</h6><p>​        用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p>
<p>（1）having只能用于group by（分组统计语句中）；<br>（2）where 是用于在初始表中筛选查询，having用于在where和group by 结果分组中查询；<br>（3）having 子句中的每一个元素也必须出现在select列表中；<br>（4）having语句可以使用聚合函数，而where不使用。</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例1：每个年龄18岁以上的级别中最年轻的水手的年龄及其级别，且每个级别的大于18岁的水手有两名以上
SELECT S.rating,MIN(S.age) As minage
FROM Sailors S
WHERE S.age >= 18
GROUP BY S.rating
HAVING COUNT(*) > 1
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例2：每个年龄18岁以上的级别中最年轻的水手的年龄及其级别，且每个级别的水手有两名以上（嵌套）
SELECT S.rating,MIN(S.age)
FROM Sailors S
WHERE S.age >= 18
GROUP BY S.rating
HAVING 1 < (SELECT COUNT(*)
           FROM Sailors S2
           WHERE S2.rating = S.rating)
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">例3：查询水手年龄平均值最低的级别（利用Temp）
SELECT Temp.rating
FROM (SELECT S.rating,AVG(S.age) As avgage
     FROM Sailors S
     GROUP BY S.rating) As Temp
WHERE Temp.avgage = (SELECT MIN(Temp.abgage)
                    FROM Temp)
</code></pre>
<h4 id="五、空值"><a href="#五、空值" class="headerlink" title="五、空值"></a>五、空值</h4><p>当值不可用或者缺值时，引用空值（表示不知道，并非为0）</p>
<p>布尔条件：真，假，空</p>
<h5 id="（一）CAST表达式"><a href="#（一）CAST表达式" class="headerlink" title="（一）CAST表达式"></a>（一）CAST表达式</h5><h6 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h6><p>​        函数调用时实现实参与形参的匹配；</p>
<p>​        改变计算的精度；</p>
<p>​        给空值赋予一个数据类型。</p>
<h6 id="2-参数"><a href="#2-参数" class="headerlink" title="2.参数"></a>2.参数</h6><p>​        expression：任何有效的SQServer表达式。</p>
<p>​        AS：用于分隔两个参数，在AS之前的是要处理的数据，在AS之后是要转换的数据类型。</p>
<p>​        data_type：目标系统所提供的数据类型，包括bigint和sql_variant，不能使用用户定义的数据类型。</p>
<p><img src="/2020/03/18/shu-ju-ku-xi-tong-de-yong-hu-jie-kou-yi-ji-sql-yu-yan/D:/blog\Hexo\source\_posts\数据库系统的用户接口以及SQL语言\图片一.png" alt></p>
<h5 id="（二）CASE表达式"><a href="#（二）CASE表达式" class="headerlink" title="（二）CASE表达式"></a>（二）CASE表达式</h5><p>用于区分情况，在有条件分歧的时候使用它。</p>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 简单 CASE表达式
CASE 列(或表达式)
     WHEN <匹配值1> THEN <表达式>
     WHEN <匹配值2> THEN <表达式>
     ......
     ELSE <表达式>
END

-- 搜索 CASE表达式
CASE WHEN <判断表达式> THEN <表达式>
     WHEN <判断表达式> THEN <表达式>
     WHEN <判断表达式> THEN <表达式>
     ......
     ELSE <表达式>
END
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：新建表Machines(serialno,type,year,hours_used,accidents)
-- 查找链锯设备的故障时间在总故障时间里占得比率
SELECT sum(CASE
                  WHEN type='chain saw' THEN accidents
                  ELSE 0e0
          END)/sum(accidents)
FROM Machines;
</code></pre>
<pre class=" language-lang-mysql"><code class="language-lang-mysql">-- 例：求每种类型的设备出故障的比率
SELECT type,CASE
                WHEN sum(hours_used)>0 THEN
                     sum(accidents)/sum(hours_used)
                ELSE NULL
            END AS accident_rate
FROM Machines
GROUP BY type;
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux权限与正则表达式</title>
    <url>/2020/03/17/linux-ji-chu-er/</url>
    <content><![CDATA[<h4 id="一、用户user"><a href="#一、用户user" class="headerlink" title="一、用户user"></a>一、用户user</h4><h5 id="（一）令牌-token-identity"><a href="#（一）令牌-token-identity" class="headerlink" title="（一）令牌 token , identity"></a>（一）令牌 token , identity</h5><h5 id="（二）Linux用户：Username-UID"><a href="#（二）Linux用户：Username-UID" class="headerlink" title="（二）Linux用户：Username/UID"></a>（二）Linux用户：Username/UID</h5><a id="more"></a>
<p>​    管理员：root，0</p>
<p>​    普通用户：1-65535</p>
<p>​        系统用户：1-499（centos6）,1-999（centos7）——对守护进程获取资源进行权限分配</p>
<p>​        登录用户：500+（centos6），1000+（centos7）——交互式登录</p>
<h4 id="二、组group"><a href="#二、组group" class="headerlink" title="二、组group"></a>二、组group</h4><h5 id="（一）Linux组：Groupname-GID"><a href="#（一）Linux组：Groupname-GID" class="headerlink" title="（一）Linux组：Groupname/GID"></a>（一）Linux组：Groupname/GID</h5><p>​    1.管理员组：root，0</p>
<p>​    2.普通组：</p>
<p>​            系统组：1-499（centos6）,1-999（centos7）</p>
<p>​            普通组：500+（centos6），1000+（centos7）</p>
<h5 id="（二）Linux组的类别"><a href="#（二）Linux组的类别" class="headerlink" title="（二）Linux组的类别"></a>（二）Linux组的类别</h5><p>​    1.用户的主要组：用户必须属于一个且只有一个主组；</p>
<p>​                               组名同用户名，且仅包含一个用户，私有组。</p>
<p>​    2.用户的附加组：一个用户可以属于零个或多个辅助组。</p>
<h5 id="（三）Linux用户和组的主要配置文件"><a href="#（三）Linux用户和组的主要配置文件" class="headerlink" title="（三）Linux用户和组的主要配置文件"></a>（三）Linux用户和组的主要配置文件</h5><div class="table-container">
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/passwd</td>
<td>用户及其属性信息</td>
</tr>
<tr>
<td>/etc/group</td>
<td>组及其属性信息</td>
</tr>
<tr>
<td>/etc/shadow</td>
<td>用户密码及其相关属性</td>
</tr>
<tr>
<td>/etc/gshadow</td>
<td>组密码及其相关属性</td>
</tr>
</tbody>
</table>
</div>
<h6 id="passwd文件格式："><a href="#passwd文件格式：" class="headerlink" title="passwd文件格式："></a>passwd文件格式：</h6><p>1.login name：登录用名；</p>
<p>2.passwd：密码；</p>
<p>3.UID：用户身份编号；</p>
<p>4.GID：登录默认所在组编号；</p>
<p>5.GECOS：用户全名或注释；</p>
<p>6.home directory：用户主目录；</p>
<p>7.shell：用户默认使用shell。</p>
<h5 id="（四）group文件格式"><a href="#（四）group文件格式" class="headerlink" title="（四）group文件格式"></a>（四）group文件格式</h5><p>1.群组名称：就是群组名称；</p>
<p>2.群组密码：通常不需要设定，密码是记录在/etc/shadow</p>
<p>3.GID：就是群组的GID；</p>
<p>4.以当前组为附加组的用户列表（分隔符为逗号）</p>
<h4 id="三、用户和组管理命令"><a href="#三、用户和组管理命令" class="headerlink" title="三、用户和组管理命令"></a>三、用户和组管理命令</h4><p>1.用户管理命令：useradd（创建）；usermod（修改）；userdel（删除）</p>
<p>2.组账号维护命令：groupadd；groupmod；groupdel</p>
<p>3.切换身份：su username（不改变目录环境）</p>
<p>​                      su - username</p>
<p>​                      退回原来身份：exit</p>
<p>4.修改用户密码：passwd [OPTIONS] username</p>
<p>   修改组密码：gpasswd [OPTIONS] group</p>
<h4 id="四、文件权限"><a href="#四、文件权限" class="headerlink" title="四、文件权限"></a>四、文件权限</h4><h5 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h5><p><img src="/2020/03/17/linux-ji-chu-er/图片一.png" alt></p>
<p>​    r：读权限；w：写权限；x：执行权限</p>
<h5 id="（二）文件属性操作"><a href="#（二）文件属性操作" class="headerlink" title="（二）文件属性操作"></a>（二）文件属性操作</h5><p>​    chown：设置文件的所有者；</p>
<p>​    chgrp：设置文件的属组信息；</p>
<p>​    chmod：修改文件权限</p>
<h5 id="（三）默认权限"><a href="#（三）默认权限" class="headerlink" title="（三）默认权限"></a>（三）默认权限</h5><p>​    1.umask值：可以用来保留在创建文件权限；</p>
<p>​    2.非特权用户umask是002；root的umask是022；</p>
<p>​    3.全局设置：/etc/bashrc    用户设置：~/.bashrc。</p>
<h5 id="（四）特殊权限"><a href="#（四）特殊权限" class="headerlink" title="（四）特殊权限"></a>（四）特殊权限</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUID</td>
<td>当s这个标志出现在<strong>文件所有者的x权限上</strong>时，例如文件权限状态“-rwsr-xr-x”，此时就称为 Set UID，简称为SUID的特殊权限。</td>
<td>（1）SUID权限仅对<strong>二进制程序</strong>有效；（2）执行者对于该程序需要<strong>具有x的可执行权限</strong>；（3）本权限仅在<strong>执行该程序的过程中</strong>有效；（4）执行者将具有该程序所有者的权限。</td>
</tr>
<tr>
<td>SGID</td>
<td>当s标志出现在文件所有者的x权限时称为SUID，那么s出现在用户组的x权限时称为SGID。</td>
<td>（1）SGID对二进制程序有用；（2）程序执行者对该程序需具备x权限；（3）执行者在执行过程中会获得该程序用户组的支持；（4）一旦<strong>某目录</strong>被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组。</td>
</tr>
<tr>
<td>SBIT</td>
<td>SBIT目前只对目录有效。</td>
<td>（1）当用户对此目录具有w和x权限时，即具有<strong>写入权限</strong>时；（2）当用户在该目录下创建新文件或目录时，<strong>仅有自己和root</strong>才有权力删除。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（五）访问控制列表"><a href="#（五）访问控制列表" class="headerlink" title="（五）访问控制列表"></a>（五）访问控制列表</h5><p>​    1.ACL：Access Control List，实现灵活的权限管理；</p>
<p>​    2.除了文件的所有者，所属组和其他人，可以对更多的用户设置权限；</p>
<p>​    3.CentOS7默认创建的xfs和ext4文件系统具有ACL功能；</p>
<p>​    4.ACL生效顺序：所有者，自定义用户，自定义组，其他人</p>
<h4 id="五、文件查看"><a href="#五、文件查看" class="headerlink" title="五、文件查看"></a>五、文件查看</h4><h5 id="（一）文件查看命令"><a href="#（一）文件查看命令" class="headerlink" title="（一）文件查看命令"></a>（一）文件查看命令</h5><p>​        cat，tac，rev</p>
<h5 id="（二）分页查看文件内容"><a href="#（二）分页查看文件内容" class="headerlink" title="（二）分页查看文件内容"></a>（二）分页查看文件内容</h5><p>​        more：分页查看文件；-d：显示翻页及退出提示；</p>
<p>​        less：一页一页地查看文件或STDIN输出；</p>
<h5 id="（三）显示文本前或后行内容"><a href="#（三）显示文本前或后行内容" class="headerlink" title="（三）显示文本前或后行内容"></a>（三）显示文本前或后行内容</h5><p>​        head：-c #:指定获取前#字节；-n #:指定获取前#行（默认前十行）；-#:指定行数</p>
<p>​        tail：-f:跟踪显示文件fd新追加的内容，常用日志监控；</p>
<p>​        tailf：类似tail -f，当文件不增长时并不访问文件。</p>
<h5 id="（四）文本处理"><a href="#（四）文本处理" class="headerlink" title="（四）文本处理"></a>（四）文本处理</h5><p>​        grep：文本过滤（模式：pattern）工具</p>
<p>​        sed：stream editor，文本编辑工具</p>
<p>​        awk：Linux上的实现gawk，文本报告生成器。</p>
<h4 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h4><h5 id="（一）REGEXP"><a href="#（一）REGEXP" class="headerlink" title="（一）REGEXP"></a>（一）REGEXP</h5><p>由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能。</p>
<h5 id="（二）程序支持"><a href="#（二）程序支持" class="headerlink" title="（二）程序支持"></a>（二）程序支持</h5><p>grep    sed    awk    vim    less    ngnix    varnish等。</p>
<h5 id="（三）分类"><a href="#（三）分类" class="headerlink" title="（三）分类"></a>（三）分类</h5><p>基本正则表达式：BRE</p>
<p>扩展正则表达式：ERE</p>
<h5 id="（四）正则表达式引擎"><a href="#（四）正则表达式引擎" class="headerlink" title="（四）正则表达式引擎"></a>（四）正则表达式引擎</h5><p>采用不同算法，检查处理正则表达式的软件模式    PCRE（Perl Compatible Expressions）</p>
<h5 id="（五）元字符分类"><a href="#（五）元字符分类" class="headerlink" title="（五）元字符分类"></a>（五）元字符分类</h5><h6 id="1-字符通配"><a href="#1-字符通配" class="headerlink" title="1.字符通配"></a>1.字符通配</h6><p>“ . “：匹配任意单个字符</p>
<p>“ []”：匹配指定范围内的任意单个字符</p>
<p>“ ^”：匹配指定范围外的任意单个字符</p>
<p>[:digit:]：数字</p>
<p>[:alpha:]：字母</p>
<p>[:alnum:]：数字和字母</p>
<p>[[:digit:]]：匹配任意数字，</p>
<p>[[:lower:]]：匹配小写字母，</p>
<p>[[:upper:]]：匹配大写字母</p>
<h6 id="2-匹配次数"><a href="#2-匹配次数" class="headerlink" title="2.匹配次数"></a>2.匹配次数</h6><p><em>（星）：匹配 </em> 前面字符任意次数</p>
<p>.*:匹配任意长度的任意字符</p>
<p>\？：匹配前面的字符0次或1次</p>
<p>\ *：匹配一次或者多次</p>
<p>\ {m,n\ }：匹配 其前面的字符至少 m 次，至多 n 次</p>
<p>\ {0,n\ }：匹配至多n次</p>
<p>\ {m,\ }：至少m次</p>
<h6 id="3-位置锚定"><a href="#3-位置锚定" class="headerlink" title="3.位置锚定"></a>3.位置锚定</h6><p>^：行首锚定，用于模式的最左侧</p>
<p>$：行尾锚定，用于模式的最右侧</p>
<p>^$：空行</p>
<p>^ [[:space:]]*$：空行或包括空白字符的行</p>
<p>词首锚定：\ &lt; 或 \b，用于单词模式的左侧</p>
<p>词尾锚定：\ &gt; 或 \b，用于单词模式的右侧</p>
<p>匹配完整单词：\ &lt;索要匹配的单词\ &gt;</p>
<h6 id="4-分组"><a href="#4-分组" class="headerlink" title="4.分组"></a>4.分组</h6><p> \ (\ )：将一个或者多个字符捆绑在一起，当做一个整体进行处理</p>
<p> \（xy\）\ (zd\ )ab\1：把xy当做第一组，把zd当做第二组，取第一组</p>
<p> \1：引用第一个分组</p>
<pre><code>#查看分区利用率
[root@localhost ~]# df -h |grep &quot;^/dev/sd&quot; |grep -o &#39;[[:digit:]]\+%&#39; |grep -o &#39;[[:digit:]]\+&#39;
</code></pre><h5 id="（六）egrep及扩展的正则表达式（基本不用加-）"><a href="#（六）egrep及扩展的正则表达式（基本不用加-）" class="headerlink" title="（六）egrep及扩展的正则表达式（基本不用加 \）"></a>（六）egrep及扩展的正则表达式（基本不用加 \）</h5><p>egrep = grep = -E</p>
<p>egrep [OPTIONS] PATTERN [FILE]</p>
<p>字符匹配：    . 任意单个字符</p>
<p>​                        [] 指定范围的字符</p>
<p>​                        <sup><a href="#fn_" id="reffn_"></a></sup> 不在指定范围的字符</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据模型</title>
    <url>/2020/03/15/shu-ju-mo-xing/</url>
    <content><![CDATA[<h4 id="一、层次模型"><a href="#一、层次模型" class="headerlink" title="一、层次模型"></a>一、层次模型</h4><h5 id="（一）PCR关系（Parent-Child-relationship）："><a href="#（一）PCR关系（Parent-Child-relationship）：" class="headerlink" title="（一）PCR关系（Parent-Child relationship）："></a>（一）PCR关系（Parent-Child relationship）：</h5><p>现实世界中的一对多的关系，是层次模型最基本的数据关系，例如：</p>
<a id="more"></a>
<pre class="mermaid">graph TB;
　　院系-->班级;
　　院系-->教研组;
　　班级-->学生1;
　　班级-->学生n;
　　教研组-->老师1;
　　教研组-->老师n;</pre>

<h5 id="（二）虚记录"><a href="#（二）虚记录" class="headerlink" title="（二）虚记录"></a>（二）虚记录</h5><p>为了避免数据的冗余，又维持数据PCR结构，引入虚记录概念。</p>
<p>例：student-v通过指针指向真正的student：</p>
<pre class="mermaid">graph LR   
    course-v-.->course
    student-v-.->student
    course-->student-v
    student-->course-v</pre>

<h4 id="二、网状数据模型"><a href="#二、网状数据模型" class="headerlink" title="二、网状数据模型"></a>二、网状数据模型</h4><h5 id="（一）基本结构："><a href="#（一）基本结构：" class="headerlink" title="（一）基本结构："></a>（一）基本结构：</h5><p>系（set）表示现实世界中一对多的关系。</p>
<p>主记录（1）——&gt; 属记录（n）</p>
<p>每个系可以是多个系的主记录，也可以是多个系的属记录，交织成复杂的网状结构。</p>
<pre class="mermaid">graph TB   
    Parts-1-->|m|LINK-M
    Supplier-1-->|n|LINK-M
    Project-1-->|p|LINK-M
    S-1-->|SL|LINK-N
    C-1-->|CL|LINK-N</pre>

<p>（查询时遍历链表）</p>
<h4 id="三、关系模型"><a href="#三、关系模型" class="headerlink" title="三、关系模型"></a>三、关系模型</h4><h5 id="（一）基本结构：-1"><a href="#（一）基本结构：-1" class="headerlink" title="（一）基本结构："></a>（一）基本结构：</h5><p>表（table），将现实世界实体中的所有关系由表来表示：</p>
<p>（1）基于数学集合论，具有更高层次；</p>
<p>（2）底层实现及编程细节都被屏蔽掉，概念简单清除，容易理解；</p>
<p>（3）建立新的代数体系——关系代数；</p>
<p>（4）可以定义<strong>非过程化</strong>的查询语言——SQL；</p>
<p>（5）软连接</p>
<h5 id="（二）属性和域"><a href="#（二）属性和域" class="headerlink" title="（二）属性和域"></a>（二）属性和域</h5><p>1.表的为一个属性都为原子不能再分的，每一个属性的合法取值范围成为域；</p>
<p>2.表中允许NULL（表示未知）；</p>
<h5 id="（三）关系和元组"><a href="#（三）关系和元组" class="headerlink" title="（三）关系和元组"></a>（三）关系和元组</h5><p>1.假设有关系R，属性为A<sub>1</sub>,A<sub>2</sub>,…A<sub>n</sub>，其对应的值域为D<sub>1</sub>,D<sub>2</sub>,…D<sub>n</sub>，n称为目，那么关系R可以表示为</p>
<script type="math/tex; mode=display">
R=（A_1/D_1,A_2/D_2,...A_n/D_n）或者R=(A_1,A_2,...A_n)</script><p>r 称为关系 R 的实例，r 由 m 个元组（tuple）组成。</p>
<p>2.表里的每一行称为记录，即元组t</p>
<script type="math/tex; mode=display">
t \in D_1\times D_2\times ,...,\times D_n, 1\leq i\leq n</script><script type="math/tex; mode=display">
r \subseteq D_1\times D_2\times ,...,\times D_n, 1\leq i\leq n</script><h5 id="（四）组键"><a href="#（四）组键" class="headerlink" title="（四）组键"></a>（四）组键</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>候选键</td>
<td style="text-align:left">总有某一个或者某一组属性的值可以唯一的决定这条元组的其他属性的值，且这组属性的子集没有此特性，把这样的属性或属性组称为候选键</td>
</tr>
<tr>
<td>超键</td>
<td style="text-align:left">在关系中能唯一标识元组的属性或属性集称为关键模式为超键，与候选键相比可能有多余属性</td>
</tr>
<tr>
<td>主键</td>
<td style="text-align:left">用户选作元组标识的候选键称为主键。一般不加说明，键就是指主键（主键不能为空）</td>
</tr>
<tr>
<td>全键</td>
<td style="text-align:left">关系模型的所有属性组是这个关系模式的候选键</td>
</tr>
<tr>
<td>外键</td>
<td style="text-align:left">关系模式R1中的某属性集不是自己的主键，而是关系模式R2的主键，则该属性集称为是关系模式R1的外键</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（五）关系代数"><a href="#（五）关系代数" class="headerlink" title="（五）关系代数"></a>（五）关系代数</h5><p>五种基本的关系代数运算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
<th>作用</th>
<th>运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>并</td>
<td>∪</td>
<td>关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S</td>
<td>R∪S = {t\</td>
<td>t∈R∨t∈S}</td>
</tr>
<tr>
<td>差</td>
<td>−</td>
<td>关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S</td>
<td>R−S = {t\</td>
<td>t∈R∨t∉S}</td>
</tr>
<tr>
<td>广义笛卡尔积</td>
<td>×</td>
<td>两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S</td>
<td>R×S = {t\</td>
<td>t =&lt; (t<sup>n</sup>,t<sup>m</sup>)∧t<sup>n</sup>∈R∧t<sup>m</sup>∈S}</td>
</tr>
<tr>
<td>投影</td>
<td>π</td>
<td>投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作π<sub>A</sub>(R)</td>
<td>π<sub>A</sub>(R) = {t[A]\</td>
<td>t∈R}</td>
</tr>
<tr>
<td>选择</td>
<td>σ</td>
<td>选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 σ<sub>F</sub>(R)</td>
<td>σ<sub>F</sub>(R) = {t\</td>
<td>t∈R∧F(t)=True}</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（六）关系连接"><a href="#（六）关系连接" class="headerlink" title="（六）关系连接"></a>（六）关系连接</h5><h6 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h6><p>也称为等值连接，是最早的一种连接。还可以被称为普通连接或者<a href="http://baike.baidu.com/item/自然连接" target="_blank" rel="noopener">自然连接</a>，内连接是从结果表中删除与其他被<a href="http://baike.baidu.com/item/连接表" target="_blank" rel="noopener">连接表</a>中没有匹配行的所有行，所以内连接可能会丢失信息。WHERE子句中设置的消除笛卡尔积的条件就是使用了等值判断的方式进行的。</p>
<h6 id="2-外连接"><a href="#2-外连接" class="headerlink" title="2.外连接"></a>2.外连接</h6><p>内连接中只能够显示等值满足条件的，如果不满住条件的无法显示，如果希望可以显示特定表的全部数据，就用外链接：外连接分为三种：左外连接，右外连接，全外连接。</p>
<p>（1）左外链接：左关系属性=右关系属性（+），放在等号的右边表示左连接；意思就是显示左边表中没有显示的信息；</p>
<p>（2）右外链接：左关系属性（+）= 右关系属性，放在等号的左边表示右连接；意思就是显示右边表中没有显示的信息。</p>
<h4 id="四、ER图"><a href="#四、ER图" class="headerlink" title="四、ER图"></a>四、ER图</h4><h5 id="（一）ER图的实体：数据模型中的数据对象"><a href="#（一）ER图的实体：数据模型中的数据对象" class="headerlink" title="（一）ER图的实体：数据模型中的数据对象"></a>（一）ER图的实体：数据模型中的数据对象</h5><h6 id="1-弱实体："><a href="#1-弱实体：" class="headerlink" title="1.弱实体："></a>1.弱实体：</h6><p>一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如上图的学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p>
<h6 id="2-复合实体："><a href="#2-复合实体：" class="headerlink" title="2.复合实体："></a>2.复合实体：</h6><p>复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示。</p>
<h5 id="（二）ER图的属性：数据对象所具有的属性"><a href="#（二）ER图的属性：数据对象所具有的属性" class="headerlink" title="（二）ER图的属性：数据对象所具有的属性"></a>（二）ER图的属性：数据对象所具有的属性</h5><p>例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p>
<h5 id="（三）ER图的关系：数据对象与数据对象之间的联系"><a href="#（三）ER图的关系：数据对象与数据对象之间的联系" class="headerlink" title="（三）ER图的关系：数据对象与数据对象之间的联系"></a>（三）ER图的关系：数据对象与数据对象之间的联系</h5><p>1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p>
<p>1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p>
<p>多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p>
<h5 id="（四）工具：Processon"><a href="#（四）工具：Processon" class="headerlink" title="（四）工具：Processon"></a>（四）工具：<a href="https://www.processon.com/login" target="_blank" rel="noopener">Processon</a></h5>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux磁盘与文件</title>
    <url>/2020/03/08/linux-ji-chu/</url>
    <content><![CDATA[<h4 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h4><h5 id="（一）OS：Operating-System，通用目的的软件程序"><a href="#（一）OS：Operating-System，通用目的的软件程序" class="headerlink" title="（一）OS：Operating System，通用目的的软件程序"></a>（一）OS：Operating System，通用目的的软件程序</h5><p>硬件驱动；进程管理；内存管理；网络管理；安全管理；文件管理。</p>
<a id="more"></a>
<pre class="mermaid">graph TB;
　　用户-->应用软件;
　　应用软件-->用户;
　　应用软件-->操作系统;
　　操作系统-->应用软件;
　　硬件-->操作系统;
　　操作系统-->硬件;</pre>

<h5 id="（二）OS分类："><a href="#（二）OS分类：" class="headerlink" title="（二）OS分类："></a>（二）OS分类：</h5><p>服务器OS：RHEL，CentOS，Windows Server，AIX；</p>
<p>桌面OS：Windows 10，Windows 7，Mac OS，Fedora；</p>
<p>移动设备OS：Andriod,IOS,YunOS</p>
<h4 id="二、开发接口标准"><a href="#二、开发接口标准" class="headerlink" title="二、开发接口标准"></a>二、开发接口标准</h4><h5 id="（一）ABI："><a href="#（一）ABI：" class="headerlink" title="（一）ABI："></a>（一）ABI：</h5><p>ABI描述了应用程序与OS之间的底层接口，允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行；</p>
<h5 id="（二）API："><a href="#（二）API：" class="headerlink" title="（二）API："></a>（二）API：</h5><p>API定义了源码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译；</p>
<h5 id="（三）POSIX："><a href="#（三）POSIX：" class="headerlink" title="（三）POSIX："></a>（三）POSIX：</h5><p>IEEE在操作系统上定义的一系列API标准；</p>
<p>POSIX兼容的程序可以在其他POSIX操作系统编译执行；</p>
<h5 id="（四）运行程序格式："><a href="#（四）运行程序格式：" class="headerlink" title="（四）运行程序格式："></a>（四）运行程序格式：</h5><p>Windows：EXE，.dll(dynamic link library)，.lib</p>
<p>Linux：ELF，.so(shared object)，.a</p>
<h4 id="三、用户和内核空间"><a href="#三、用户和内核空间" class="headerlink" title="三、用户和内核空间"></a>三、用户和内核空间</h4><h5 id="（一）用户空间：User-space"><a href="#（一）用户空间：User-space" class="headerlink" title="（一）用户空间：User space"></a>（一）用户空间：User space</h5><p>用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃，内核也不受影响；只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（system call），才能向内核发出指令。</p>
<h5 id="（二）内核空间：Kernel-space"><a href="#（二）内核空间：Kernel-space" class="headerlink" title="（二）内核空间：Kernel space"></a>（二）内核空间：Kernel space</h5><p>是Linux内核的运行空间；可以执行任意命令，调用系统的一切资源。</p>
<h4 id="四、Linux哲学思想"><a href="#四、Linux哲学思想" class="headerlink" title="四、Linux哲学思想"></a>四、Linux哲学思想</h4><p>1.一切都是一个文件（包括硬件）；</p>
<p>2.小型，单一用途的程序；</p>
<p>3.链接程序。共同完成复杂的任务；</p>
<p>4.避免令人困惑的用户界面；</p>
<p>5.配置数据存储在文本中。</p>
<h4 id="五、Linux文件与磁盘"><a href="#五、Linux文件与磁盘" class="headerlink" title="五、Linux文件与磁盘"></a>五、Linux文件与磁盘</h4><pre class="mermaid">graph TD
    B["/(根目录)"]
    B-->C(tmp);
    B-->D(usr);
    B-->E(etc-存放相关配置文件);
    B-->F(boot-启动文件);
    B-->G(bin-二进制程序);
    B-->H(...);</pre>

<h5 id="（一）挂载概念："><a href="#（一）挂载概念：" class="headerlink" title="（一）挂载概念："></a>（一）挂载概念：</h5><p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”（即通过访问目录名到其关联的分区），此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”。</p>
<h6 id="1-挂载"><a href="#1-挂载" class="headerlink" title="1.挂载"></a>1.挂载</h6><p>根文件系统外通过关联至根文件系统上的某个目录来实现访问；</p>
<h6 id="2-挂载点"><a href="#2-挂载点" class="headerlink" title="2.挂载点"></a>2.挂载点</h6><p>mount_point，用于作为另一个文件系统的访问入口：</p>
<ul>
<li>事先存在；</li>
<li>应该使用未被或不会被其它进程使用到的目录；</li>
<li>挂载点下原有的文件将会被隐藏； </li>
</ul>
<h4 id="六、什么是shell"><a href="#六、什么是shell" class="headerlink" title="六、什么是shell"></a>六、什么是shell</h4><ul>
<li>Shell是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行；</li>
<li>Shell也被称为Linux的命令解释器；</li>
<li>Shell是一种高级程序设计语言。</li>
</ul>
<h4 id="七、执行命令"><a href="#七、执行命令" class="headerlink" title="七、执行命令"></a>七、执行命令</h4><h5 id="（一）内部命令"><a href="#（一）内部命令" class="headerlink" title="（一）内部命令"></a>（一）内部命令</h5><p>由shell自带的，而且通过某命令形式提供</p>
<ul>
<li>help 内部命令列表；</li>
<li>enable cmd  启用内部命令；</li>
<li>enable -n cmd 禁用内部命令；</li>
<li>enable -n 查看所有禁用的内部命令；</li>
</ul>
<h5 id="（二）外部命令"><a href="#（二）外部命令" class="headerlink" title="（二）外部命令"></a>（二）外部命令</h5><p>在文件系统路径下有对应的可执行程序文件</p>
<ul>
<li>查看路径：which -a |—skip-alias；whereis；</li>
</ul>
<h5 id="（三）命令别名"><a href="#（三）命令别名" class="headerlink" title="（三）命令别名"></a>（三）命令别名</h5><p>显示当前shell进程所有可用的命令别名：alias</p>
<p>例如：将 “cd /etc/sysconfig/network-scripts/“ 用  “cdnet” 命令替代 </p>
<pre><code>#永久添加命令别名需更改相关配置文件,在文件中添加alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;
#仅对当前用户有效：~/.bashrc
#对所有用户有效：/etc/bashrc
[root@localhost ~]# nano .bashrc
 .bashrc

# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
</code></pre><ul>
<li>编辑配置给出的新配置不会立即生效</li>
<li>bash进程重新读取配置文件   .  /path/to/config_file</li>
<li>撤销别名：unalias</li>
<li>如果别名同原名令同名，执行原名令可使用 \ALIASNAME</li>
</ul>
<h4 id="八、文件系统"><a href="#八、文件系统" class="headerlink" title="八、文件系统"></a>八、文件系统</h4><p>1.文件和目录被组织成一个单根倒置树结构</p>
<p>2.文件系统从根目录下开始，用“/”表示</p>
<p>3.根文件系统（rootfs）：root filesystem</p>
<p>4.文件名称区分大小写</p>
<h4 id="九、把输出和错误重定向到文件"><a href="#九、把输出和错误重定向到文件" class="headerlink" title="九、把输出和错误重定向到文件"></a>九、把输出和错误重定向到文件</h4><p>1.STDOUT和STDERR可以被重定向到文件</p>
<p>命令  操作符号  文件名</p>
<p>支持的操作符号包括：&gt;  把STDOUT重定向到文件</p>
<p>​                                      2&gt;  把STDERR重定向到文件</p>
<p>​                                      &amp;&gt;  把STDOUT和STDERR一起重定向到文件</p>
<p>2.&gt; 文件内容会被覆盖</p>
<p>set -C  禁止将内容覆盖已有文件，但可追加</p>
<p>\&lt;| file  强制覆盖</p>
<p>set +C  允许覆盖</p>
<p>3.&lt;&lt; 原有内容基础上，追加内容 </p>
<h4 id="十、从文件中导入STDIN"><a href="#十、从文件中导入STDIN" class="headerlink" title="十、从文件中导入STDIN"></a>十、从文件中导入STDIN</h4><p>1.使用 &lt; 来重定向标准输入</p>
<p>2.某些命令能够接受从文件中导入的STDIN</p>
<pre><code>tr &#39;a-z&#39; &#39;A-Z&#39;&lt; /etc/issue
</code></pre><p>该命令会把/etc/issue中的小写字符都转换成大写字符</p>
<p>3.</p>
<pre><code>tr -d abc &lt; /etc/fstab
</code></pre><p>删除fstab文件中的所有abc中任意字符</p>
<p>4.使用 &gt; 来重定向标准输出</p>
<pre><code>cat &gt; file
mage
abc
</code></pre><p>按Ctrl+d离开，可以使用文件来代替键盘的输入</p>
<h4 id="十一、管道"><a href="#十一、管道" class="headerlink" title="十一、管道"></a>十一、管道</h4><p>管道（使用符号“|”表示）用来连接命令：命令1|命令2|命令3|…</p>
<ul>
<li>将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的TSDIN</li>
<li>STDERR默认不能通过管道转发，可利用2&gt;&amp;1或|&amp;实现</li>
<li>最后一个命令会在当前shell进程的子shell进程中执行</li>
<li>组合多种工具的功能</li>
</ul>
<pre><code>例：ls |tr &#39;a-z&#39; &#39;A-Z&#39;
</code></pre><pre><code>#将who指令的标准输出显示到屏幕的同时重定向追加到who.out文件
[root@localhost ~]# who | tee -a who.out
root     tty1         2020-03-09 17:51
root     pts/0        2020-03-11 00:37 (10.0.2.2)
[root@localhost ~]# cat who.out
root     tty1         2020-03-09 17:51
root     pts/0        2020-03-11 00:37 (10.0.2.2)
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PID算法学习</title>
    <url>/2020/03/05/pid-suan-fa-xue-xi/</url>
    <content><![CDATA[<h4 id="一、常规位式控制算法"><a href="#一、常规位式控制算法" class="headerlink" title="一、常规位式控制算法"></a>一、常规位式控制算法</h4><p><div id="flowchart-0" class="flow-chart"></div></p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.输出信号单一，一般只有两种状态：高电平和低电平；</p>
<p>2.常规位式算法输出信号OUT的依据：Pv &lt; Sv ——&gt; High、Pv &gt;= Sv ——&gt; Low；</p>
<p>3.只考虑控制对象当前的状态值。</p>
<a id="more"></a>
<h4 id="二、PID控制算法"><a href="#二、PID控制算法" class="headerlink" title="二、PID控制算法"></a>二、PID控制算法</h4><pre class="mermaid">graph LR;
　　用户设定-->|Sv|偏差E=Sv-Pv;
　　偏差E=Sv-Pv-->历史偏差;
　　偏差E=Sv-Pv-->当前偏差;
　　偏差E=Sv-Pv-->最近偏差;
　　历史偏差-->+;
　　当前偏差-->+;
　　最近偏差-->+;
　　+-->|OUT|可控硅;
　　220V-->可控硅;
　　可控硅-->负载;
　　220V-->负载;
　　负载-->传感器;
　　传感器-->|Pv当前值|偏差E=Sv-Pv;</pre>

<p>从开机以来，传感器的所有采样点的数据序列</p>
<script type="math/tex; mode=display">
x_1,x_2,x_3······x_{k-2},x_{k-1},x_k</script><p>历史偏差序列</p>
<script type="math/tex; mode=display">
E_1,E_2,E_3......E_{k-2},E_{k-1},E_k</script><script type="math/tex; mode=display">
E_k = S_v-x_k\left\{
\begin{array}{rcl}
>0       &      & {当前未达标}\\
=0    &      & {正好达标}\\
<0    &      & {当前已超标}
\end{array} \right.</script><h5 id="一-PID比例控制"><a href="#一-PID比例控制" class="headerlink" title="(一)PID比例控制"></a>(一)PID比例控制</h5><script type="math/tex; mode=display">
OUT=K_p*E_k</script><p>通过调整输出PWM的脉宽侧面调整负载的功率，根据当前偏差大小输出比例信号。</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>一旦传感器回来的信号与设定值相等，输出信号就等于零，负载处于失控状态，也就是说整个系统工作时总是存在误差。</p>
<script type="math/tex; mode=display">
P_{OUT}=K_p*E_k+OUT_0</script><h5 id="二-PID积分控制"><a href="#二-PID积分控制" class="headerlink" title="(二)PID积分控制"></a>(二)PID积分控制</h5><script type="math/tex; mode=display">
S_k=E_1+E_2+E_3......E_{k-2}+E_{k-1}+E_k\left\{
\begin{array}{rcl}
>0       &      & {过去的大多数时间未达标}\\
=0    &      & {}\\
<0    &      & {过去的大多数时间已超标}
\end{array} \right.</script><script type="math/tex; mode=display">
I_{OUT}=K_p*S_k+OUT_0</script><h5 id="三-PID微分控制"><a href="#三-PID微分控制" class="headerlink" title="(三)PID微分控制"></a>(三)PID微分控制</h5><p>将最近两次的偏差相减：</p>
<script type="math/tex; mode=display">
D_k=E_k-E_{k-1}\left\{
\begin{array}{rcl}
>0       &      & {偏差有增大的趋势}\\
=0    &      & {偏差不变}\\
<0    &      & {偏差有减小的趋势}
\end{array} \right.</script><script type="math/tex; mode=display">
D_{OUT}=k_p*D_k+OUT_0</script><h4 id="三、PID算法的数学模型"><a href="#三、PID算法的数学模型" class="headerlink" title="三、PID算法的数学模型"></a>三、PID算法的数学模型</h4><script type="math/tex; mode=display">
\begin{align}
PID_{OUT}&=P_{OUT}+I_{OUT}+D_{OUT} \\
&=(K_p*E_k+OUT_0)+(K_p*S_k+OUT_0)+(K_p*D_k+OUT_0) \\
&=K_p*(E_k+S_k+D_k)
\end{align}</script><h4 id="四、基于单片机的PID算法"><a href="#四、基于单片机的PID算法" class="headerlink" title="四、基于单片机的PID算法"></a>四、基于单片机的PID算法</h4><h5 id="1-Sk的处理"><a href="#1-Sk的处理" class="headerlink" title="1.Sk的处理"></a>1.S<sub>k</sub>的处理</h5><script type="math/tex; mode=display">
S_k=\frac{1}{T_i}\sum^{n}_{k=0}E_k*T</script><p>T：采样周期（计算周期）</p>
<p>T<sub>i</sub> ：积分常数（积分时间：I<sub>OUT</sub>和P<sub>OUT</sub>共同作用的时间）</p>
<p>由于积分项的存在，在输出值第一次达到设定值前偏差均为正数，累积后作用很大，会出现过冲现象。</p>
<h5 id="2-Dk的处理"><a href="#2-Dk的处理" class="headerlink" title="2.Dk的处理"></a>2.D<sub>k</sub>的处理</h5><script type="math/tex; mode=display">
D_k=T_d(\frac{E_k-E_{k-1}}{T})</script><p>T<sub>d</sub>：微分常数（P<sub>OUT</sub>和D<sub>OUT</sub>共同作用的时间）</p>
<h6 id="单片机中的PID算法表达式——位置式PID"><a href="#单片机中的PID算法表达式——位置式PID" class="headerlink" title="单片机中的PID算法表达式——位置式PID"></a>单片机中的PID算法表达式——位置式PID</h6><script type="math/tex; mode=display">
OUT=K_p*E_k+[K_p*(\frac{T}{T_i})*\sum^{n}_{k=0}E_k]+[K_p*(\frac{T_d}{T})*(E_k-E_{k-1})]+OUT_0</script><h6 id="增量式PID：计算出的是控制量的增加值"><a href="#增量式PID：计算出的是控制量的增加值" class="headerlink" title="增量式PID：计算出的是控制量的增加值"></a>增量式PID：计算出的是控制量的增加值</h6><script type="math/tex; mode=display">
\begin{align}
\Delta OUT&=OUT_k-OUT_{k-1}\\
&=K_p*(E_k-E_{k-1})+K_p*\frac{T}{T_i}*E_k+K_p*\frac{T_d}{T}*(E_k-2E_{k-1}+E_{k-2})
\end{align}</script><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 用户设置Sv
e=>end: End:>http://www.google.com
op1=>operation: 位式控制算法输出out
op2=>operation: 执行部件|current
op3=>operation: 控制对象（具有一定惯性）
op4=>operation: 传感器输出当前值Pv

st->op1(right)->op2(right)->op3->op4(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY矩阵灯</title>
    <url>/2019/10/18/diy-ju-zhen-deng/</url>
    <content><![CDATA[<h4 id="用树莓派或Arduino制造LED矩阵彩灯"><a href="#用树莓派或Arduino制造LED矩阵彩灯" class="headerlink" title="用树莓派或Arduino制造LED矩阵彩灯"></a>用树莓派或Arduino制造LED矩阵彩灯</h4><p>笔者在树莓派网站发现了个简单有意思的DIY的小玩意，就自己动手做了一个，于此分享一下，点击下方 ↓ 链接即可了解相关内容：</p>
<a id="more"></a>
<p><a href="https://shumeipai.nxez.com/2019/04/10/led-matrix-cylinder.html" target="_blank" rel="noopener">树莓派实验室</a></p>
<p><a href="https://tutorials-raspberrypi.com/connect-control-raspberry-pi-ws2812-rgb-led-strips/" target="_blank" rel="noopener">树莓派连接并控制SW2812 RGB LED</a></p>
<p>这是笔者做的成品图片，将外壳由原帖的木质贴面改为3D打印的光敏树脂，效果也不错，顶盖是用切割剩下的椴木板所裁成的</p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片1.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片2.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片3.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片4.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片5.png" alt></p>
<p><img src="/2019/10/18/diy-ju-zhen-deng/图片6.png" alt></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx应用监控</title>
    <url>/2019/08/27/nginx-ying-yong-jian-kong/</url>
    <content><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，同时也提供了IMAP/POP3/SMTP服务，是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3)代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上其并发能力确实在同类型的网页服务器中表现较好。</p>
<a id="more"></a>
<h4 id="一、安装Nginx"><a href="#一、安装Nginx" class="headerlink" title="一、安装Nginx"></a>一、安装Nginx</h4><pre><code>#安装Nginx所需的依赖
[root@localhost ~]# yum install -y gcc glibc gcc-c++ pcre-devel openssl-devel
#安装Nginx
[root@localhost ~]# cd /usr/local/src
[root@localhost src]# wget http://nginx.org/download/nginx-1.16.1.tar.gz
#解压
[root@localhost src]# tar zxf nginx-1.16.1.tar.gz
[root@localhost src]# ls
nginx-1.16.1  nginx-1.16.1.tar.gz
#查看相关文件
[root@localhost src]# cd nginx-1.16.1
[root@localhost nginx-1.16.1]# ls
auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  man  README  src
</code></pre><p>注：configure是Shell脚本，执行它的作用是生成Makefile（使用Make工具编译C程序，而Make工具需要依赖Makefile）</p>
<pre><code>#创建用户
[root@localhost nginx-1.16.1]# useradd -s /sbin/nologin -M www
#执行脚本
[root@localhost nginx-1.16.1]# ./configure --prefix=/usr/local/ngnix-1.16.1 --user=www --group=www --with-http_ssl_module --with-http_stub_status_module
#之后再查看目录下文件会发现Makefile文件
</code></pre><pre><code>#编译并将生成的文件拷贝到指定的地方
[root@localhost nginx-1.16.1]# make &amp;&amp; make install
#创建软链接
[root@localhost nginx-1.16.1]# cd
[root@localhost ~]# ln -s /usr/local/ngnix-1.16.1/ /usr/local/ngnix
</code></pre><h4 id="二、启动Ngnix服务"><a href="#二、启动Ngnix服务" class="headerlink" title="二、启动Ngnix服务"></a>二、启动Ngnix服务</h4><pre><code>#查看86端口有没有被占用
[root@localhost ~]# netstat -ntlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1178/sshd           
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1281/master         
tcp6       0      0 :::22                   :::*                    LISTEN      1178/sshd           
tcp6       0      0 ::1:25                  :::*                    LISTEN      1281/master 
#启动服务前测试文件
[root@localhost ~]# /usr/local/ngnix/sbin/nginx -t
nginx: the configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf test is successful
#启动服务
[root@localhost ~]# /usr/local/ngnix/sbin/nginx
</code></pre><h4 id="三、配置Nginx"><a href="#三、配置Nginx" class="headerlink" title="三、配置Nginx"></a>三、配置Nginx</h4><pre><code>[root@localhost ~]# cd /usr/local/ngnix/conf/
[root@localhost conf]# vim nginx.conf
...
#在一个服务后加nginx-status
server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location /nginx-status {
            stub_status on;
            access_log  off;
            allow 172.16.137.0/24;
            deny all;
        }
...
#保存后检测文件是否出错
[root@localhost conf]# /usr/local/ngnix/sbin/nginx -t
nginx: the configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/ngnix-1.16.1/conf/nginx.conf test is successful
# 重启服务
[root@localhost conf]# /usr/local/ngnix/sbin/nginx -s reload
#访问
[root@localhost conf]# curl 172.16.137.128/nginx-status
Active connections: 1 
server accepts handled requests
 2 2 2 
Reading: 0 Writing: 1 Waiting: 0 
#活动链接数1
#成功创建链接次数2  成功创建握手次数2  成功的请求次数2
#当前读取的客户端header的数量0  当前返回给客户端header的数量1  长链接状态下已经处理等待下一次请求的值0
</code></pre><p>在本机浏览器也可访问，如图所示：</p>
<p><img src="/2019/08/27/nginx-ying-yong-jian-kong/图片一.png" alt></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机使用VMware tools与主机共享文件</title>
    <url>/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/</url>
    <content><![CDATA[<h4 id="一、VMware-Tools介绍"><a href="#一、VMware-Tools介绍" class="headerlink" title="一、VMware Tools介绍"></a>一、VMware Tools介绍</h4><p>VMware Tools是VMware虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是VMware提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。</p>
<a id="more"></a>
<p>只有在VMware虚拟机中安装好了VMware Tools，才能实现主机与虚拟机之间的文件共享，同时可支持自由拖拽的功能，鼠标也可在虚拟机与主机之间自由移动（不用再按ctrl+alt），且虚拟机屏幕也可实现全屏化。</p>
<h4 id="二、安装VMware-Tools"><a href="#二、安装VMware-Tools" class="headerlink" title="二、安装VMware Tools"></a>二、安装VMware Tools</h4><p>1.选择虚拟机界面左上角的虚拟机—&gt;重新安装VMware Tools选项。</p>
<p>2.进入CentOS系统</p>
<pre><code>#挂载CD
[root@localhost ~]# mount /dev/cdrom /media
mount: /dev/sr0 写保护，将以只读方式挂载

#查看安装的VMwareTools版本
[root@localhost ~]# cd /media
[root@localhost media]# ls
manifest.txt     VMwareTools-10.3.10-12406962.tar.gz  vmware-tools-upgrader-64
run_upgrader.sh  vmware-tools-upgrader-32

#将安装文件拷贝、解压
[root@localhost media]# cp /media/VMwareTools-10.3.10-12406962.tar.gz /tmp/
[root@localhost media]# cd /tmp
[root@localhost tmp]# tar -zxf VMwareTools-10.3.10-12406962.tar.gz

#安装
[root@localhost tmp]# cd vmware-tools-distrib/
[root@localhost vmware-tools-distrib]# ./vmware-install.pl
#之后一路回车，即可安装完毕
</code></pre><p>3.安装可能会出现内核位置不确定的问题</p>
<pre><code>The path &quot;&quot; is not a valid path to the 3.10.0-957.el7.x86_64 kernel headers.
Would you like to change it? [yes] 

INPUT: [yes]  default

Enter the path to the kernel header files for the 3.10.0-957.el7.x86_64 
kernel? 

INPUT: []  default
</code></pre><p>解决方法为指定版本重新安装内核</p>
<pre><code>[root@localhost vmware-tools-distrib]# yum install &quot;kernel-devel-uname-r == $(uname -r)&quot;
#然后重新安装
[root@localhost vmware-tools-distrib]# ./vmware-install.pl
</code></pre><h4 id="三、使用VMware-Tools共享文件"><a href="#三、使用VMware-Tools共享文件" class="headerlink" title="三、使用VMware Tools共享文件"></a>三、使用VMware Tools共享文件</h4><p>在主机新建一个文件夹存放于虚拟机共享的文件</p>
<p>在虚拟机界面设置中启用共享文件夹，然后将新建的共享文件夹添加进去</p>
<p><img src="/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/图片一.png" alt></p>
<p>在主机文件夹中新建一个test.txt文件</p>
<p><img src="/2019/08/26/xu-ni-ji-shi-yong-vmware-tools-yu-zhu-ji-gong-xiang-wen-jian/图片二.png" alt></p>
<p>在虚拟机中查看</p>
<pre><code>[root@localhost ~]# cd /mnt/hgfs/虚拟机共享
[root@localhost 虚拟机共享]# ls
test.txt
</code></pre>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>多维监控体系</title>
    <url>/2019/08/22/duo-wei-jian-kong-ti-xi/</url>
    <content><![CDATA[<h4 id="一、监控概述"><a href="#一、监控概述" class="headerlink" title="一、监控概述"></a>一、监控概述</h4><h6 id="一、监控对象："><a href="#一、监控对象：" class="headerlink" title="一、监控对象："></a>一、监控对象：</h6><p>1.监控对象的理解：CPU是怎么工作的，以及工作原理；<br>2.监控对象的指标：CPU的使用率、CPU的负载、CPU个数;<br>3.确定性能基准线：怎么样才算故障？CPU负载多少算高？</p>
<a id="more"></a>
<h6 id="二、监控范围："><a href="#二、监控范围：" class="headerlink" title="二、监控范围："></a>二、监控范围：</h6><p>1.硬件监控：服务器的硬件故障；<br>2.操作系统监控：CPU、内存、IO、进程；<br>3.应用服务监控；<br>4.业务监控。</p>
<h4 id="二、硬件监控"><a href="#二、硬件监控" class="headerlink" title="二、硬件监控"></a>二、硬件监控</h4><h6 id="一、服务器监控：IPMI"><a href="#一、服务器监控：IPMI" class="headerlink" title="一、服务器监控：IPMI"></a>一、服务器监控：IPMI</h6><p>IPMI是一种智能化远程接口标准，Linux就可以使用IPMI实现对服务器的远程监控，IPMI依赖于BMC控制器（一种嵌入式微控制器），</p>
<p>使用ipmitool实现在Linux下对硬件的监控和控制。</p>
<p>使用ipmitool的条件：硬件和操作系统要支持。（虚拟机无法执行IPMI，可在物理机尝试，不执行关机命令即可）</p>
<pre><code>#安装工具
[root@localhost ~]# yum install -y OpenIPMI ipmitool
#启动
[root@localhost ~]# systemctl start ipmi
</code></pre><p>使用IPMI有两种方式：1.本地调用；2.远程调用（通过IP地址，用户名和密码）</p>
<h6 id="二、路由器和交换机监控：SNMP"><a href="#二、路由器和交换机监控：SNMP" class="headerlink" title="二、路由器和交换机监控：SNMP"></a>二、路由器和交换机监控：SNMP</h6><pre><code>[root@localhost ~]# yum install -y net-snmp net-snmp-utils
[root@localhost ~]# cd /etc/snmp
[root@localhost snmp]# ls
snmpd.conf  snmptrapd.conf
[root@localhost snmp]# mv snmpd.conf snmpd.conf.bak
[root@localhost snmp]# vim snmpd.conf
#添加如下内容
rocommunity zzulyt（名称，自己起的团体名） 172.16.137.128（指要收集的机器的IP）
[root@localhost snmp]# ll
总用量 28
-rw-r--r-- 1 root root    34 8月  19 20:08 snmpd.conf
-rw------- 1 root root 18861 7月  30 01:29 snmpd.conf.bak
-rw------- 1 root root   220 7月  30 01:29 snmptrapd.conf
#启动服务
[root@localhost snmp]# systemctl start snmpd
#查看snmp监听的161端口
[root@localhost snmp]# netstat -nulp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
udp        0      0 0.0.0.0:69              0.0.0.0:*                           917/xinetd          
udp        0      0 0.0.0.0:161             0.0.0.0:*                           2711/snmpd
</code></pre><h4 id="三、SNMP系统的管理信息库（MIB）与OID"><a href="#三、SNMP系统的管理信息库（MIB）与OID" class="headerlink" title="三、SNMP系统的管理信息库（MIB）与OID"></a>三、SNMP系统的管理信息库（MIB）与OID</h4><p> 1.任何一个被管理的资源都表示成一个对象，称为被管理的对象。MIB是被管理对象的集合。它定义了被管理对象的一系列属性：对象的名称、对象的访问权限和对象的数据类型等。每个SNMP设备（Agent）都有自己的MIB。MIB也可以看作是NMS（网管系统）和Agent之间的沟通桥梁。它们之间的关系如图所示：</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片一.png" alt></p>
<p> 2.MIB文件中的变量使用的名字取自ISO和ITU管理的对象标识符（object identifier）名字空间。它是一种分级树的结构。</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片二.png" alt></p>
<p> 3.OID(对象标识符)：是SNMP代理提供的具有唯一标识的键值。【MIB（管理信息基）提供数字化OID到可读文本的映射】。</p>
<p>OID可用数字格式表达：<br>长这样“.1.3.6.1.2.1.1.2.0”  子树 1 -&gt; 3 -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 1 -&gt; 1 -&gt; 2</p>
<pre><code>#OID:1.3.6.1.2.1.1.3.0--&gt;监控时间
[root@localhost snmp]# snmpget -v2c -c zzulyt 172.16.137.128 1.3.6.1.2.1.1.3.0
DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (28036) 0:04:40.36
#OID:1.3.6.1.4.1.2021.10.1.3.1--&gt;Load 5
[root@localhost snmp]# snmpget -v2c -c zzulyt 172.16.137.128 1.3.6.1.4.1.2021.10.1.3.1
UCD-SNMP-MIB::laLoad.1 = STRING: 0.01
</code></pre><h4 id="四、CPU监控"><a href="#四、CPU监控" class="headerlink" title="四、CPU监控"></a>四、CPU监控</h4><h5 id="1-CPU三个重要的概念"><a href="#1-CPU三个重要的概念" class="headerlink" title="1.CPU三个重要的概念"></a>1.CPU三个重要的概念</h5><p>上下文切换：CPU调度器实施的进程的切换过程；</p>
<p>运行队列（负载）：负载可以理解为运行队列里单位时间内的排队线程的平均数，（负载只是一个参考值，负载高未必系统繁忙）；</p>
<p>使用率：指运行的程序占用的CPU资源，表示你的机器在某个时间点的运行程序的情况。</p>
<h5 id="2-确定服务类型"><a href="#2-确定服务类型" class="headerlink" title="2.确定服务类型"></a>2.确定服务类型</h5><p>IO密集型——数据库<br>CPU密集型——web、mail</p>
<h5 id="3-确定性能基准线"><a href="#3-确定性能基准线" class="headerlink" title="3.确定性能基准线"></a>3.确定性能基准线</h5><p>运行队列：1-3线程；1CPU；4核；负载不超过12（经验值）</p>
<p>CPU使用：65%-70%的用户态利用率<br>                   30%-35%的内核利用率<br>                   0%-5%的空闲利用率</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片三.png" alt></p>
<h5 id="4-监控工具"><a href="#4-监控工具" class="headerlink" title="4.监控工具"></a>4.监控工具</h5><p>（1）top</p>
<pre><code>[root@localhost ~]# top
top - 13:09:07 up 17:02,  3 users,  load average: 0.04, 0.03, 0.05
Tasks: 105 total,   1 running, 104 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :   999696 total,   145684 free,   161652 used,   692360 buff/cache
KiB Swap:  2097148 total,  2095184 free,     1964 used.   659484 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                    
     1 root      20   0  125364   3404   2092 S  0.0  0.3   0:09.59 systemd                                    
     2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd                                   
     3 root      20   0       0      0      0 S  0.0  0.0   0:01.58 ksoftirqd/0                                
     5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H                               
     7 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0                                
     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh                                     
     9 root      20   0       0      0      0 S  0.0  0.0   0:04.28 rcu_sched                                  
    10 root      rt   0       0      0      0 S  0.0  0.0   0:00.82 watchdog/0
</code></pre><p>top命令中       P—&gt;按CPU使用率排序<br>                         M—&gt;按内存使用率排序</p>
<p>（2）安装sysstat，使用vmstat或mpstat工具</p>
<pre><code>[root@localhost ~]# yum install -y sysstat
#每一秒显示一次监控信息，显示10次
[root@localhost ~]# vmstat 1 10
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0   1964 141160      0 696360    0    0    16    15   51   49  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   76   83  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   85   92  1  0 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   92   90  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   96   96  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   89   90  0  1 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   88   84  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0   82   81  0  0 100  0  0
 0  0   1964 141160      0 696376    0    0     0     0  106  110  0  1 99  0  0
 0  0   1964 141160      0 696376    0    0     0     0   83   79  0  0 100  0  0
#每一秒显示一次监控信息，显示5次 
[root@localhost ~]# mpstat 1 5
Linux 3.10.0-693.el7.x86_64 (localhost.localdomain)     2019年08月22日     _x86_64_    (1 CPU)

13时56分36秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13时56分37秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分38秒  all    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00
13时56分39秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分40秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13时56分41秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间:  all    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
</code></pre><h4 id="五、内存监控"><a href="#五、内存监控" class="headerlink" title="五、内存监控"></a>五、内存监控</h4><h5 id="vmstat显示的参数说明"><a href="#vmstat显示的参数说明" class="headerlink" title="vmstat显示的参数说明"></a>vmstat显示的参数说明</h5><p>swpd:已使用的交换分区的大小<br>free：可用的物理内存的大小<br>si：从磁盘交换到内存的交换页数量，单位：KB/秒<br>so：从内存交换到磁盘的交换页数量，单位：KB/秒<br>bi：每秒从块设备接收到的块数，单位：块/秒 也就是读块设备<br>bo：每秒发送到块设备的块数，单位：块/秒  也就是写块设备<br>in：每秒的中断数，包括时钟中断。与cs一般同步增长。in和cs两值越大，会看到由内核消耗的CPU时间（sy）也会越大<br>cs：每秒的环境（上下文）切换次数<br>us：用户CPU时间(非内核进程占用时间)（单位为百分比）。 us的值比较高时，说明用户进程消耗的CPU时间多<br>sy：系统使用的CPU时间（单位为百分比）。sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。<br>id：空闲的CPU的时间(百分比)，在Linux 2.5.41之前，这部分包含IO等待时间。<br>wa：等待IO的CPU时间，在Linux 2.5.41之前，这个值为0 .这个指标意味着CPU在等待硬盘读写操作的时间，用百分比表示。wait越大则机器io性能就越差。说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）<br>st：针对虚拟技术，如果st不为0，说明本来分配给本机的CPU时间被其他虚拟机偷走了</p>
<h4 id="六、系统监控"><a href="#六、系统监控" class="headerlink" title="六、系统监控"></a>六、系统监控</h4><h5 id="一、硬盘监控"><a href="#一、硬盘监控" class="headerlink" title="一、硬盘监控"></a>一、硬盘监控</h5><p>通过iotop工具监控硬盘</p>
<pre><code>[root@localhost ~]# yum install iotop
[root@localhost ~]# iotop
Total DISK READ :    0.00 B/s | Total DISK WRITE :       0.00 B/s
Actual DISK READ:    0.00 B/s | Actual DISK WRITE:       0.00 B/s
......
</code></pre><h5 id="二、网络监控"><a href="#二、网络监控" class="headerlink" title="二、网络监控"></a>二、网络监控</h5><p>通过iftop监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等。</p>
<pre><code>[root@localhost ~]# yum install iftop
[root@localhost ~]# iftop -n
</code></pre><p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片四.png" alt></p>
<h5 id="三、利用nmon监控并分析数据"><a href="#三、利用nmon监控并分析数据" class="headerlink" title="三、利用nmon监控并分析数据"></a>三、利用nmon监控并分析数据</h5><p>1.去官网下载nmon的二进制文件</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片五.png" alt></p>
<p>2.将文件共享给虚拟机的系统</p>
<pre><code>[root@localhost ~]# cd /mnt/hgfs/虚拟机共享
[root@localhost 虚拟机共享]# chmod +x nmon16e_x86_rhel71
[root@localhost 虚拟机共享]# ./nmon16e_x86_rhel71
</code></pre><p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片六.png" alt></p>
<p>3.主机下载nomn_analyzer</p>
<p>下载后的文件夹里包含：</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片七.png" alt></p>
<p>4.将检测结果生成Excel文件</p>
<p>在虚拟机系统中输入监控并将结果生成文件的命令</p>
<pre><code>[root@localhost 虚拟机共享]# ./nmon16e_x86_rhel71 -c 10 -s 10 -f
#检查发现多了一个nmon文件，190826表示年月日，1542表示时分
[root@localhost 虚拟机共享]# ls
localhost_190826_1542.nmon  nmon16e_x86_rhel71
</code></pre><p>在主机打开nomn_analyzer文件夹中的nmon analyser v61文件，点击Analyze nmon data</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片八.png" alt></p>
<p>选择共享文件夹中的nmon文件，即可生成图表</p>
<p><img src="/2019/08/22/duo-wei-jian-kong-ti-xi/图片九.png" alt></p>
<p>（底部的表格栏即为监控的参数名称）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware中centos在NAT模式下配置静态IP</title>
    <url>/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/</url>
    <content><![CDATA[<h4 id="一、VMware的配置"><a href="#一、VMware的配置" class="headerlink" title="一、VMware的配置"></a>一、VMware的配置</h4><p>1.虚拟机设置中网络适配器设置为NAT模式</p>
<a id="more"></a>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片1.png" alt></p>
<p>2.点击左上角的编辑—&gt;虚拟网络编辑器，win10系统下更改需要管理员权限</p>
<p>取消DHCP前的对号，然后进入NAT设置，记下子网IP、子网掩码和网关</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片2.png" alt></p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片3.png" alt></p>
<h4 id="二、查看本机VMnet8网段（虚拟机网关与VMnet8-ip必须要在同一网段）"><a href="#二、查看本机VMnet8网段（虚拟机网关与VMnet8-ip必须要在同一网段）" class="headerlink" title="二、查看本机VMnet8网段（虚拟机网关与VMnet8 ip必须要在同一网段）"></a>二、查看本机VMnet8网段（虚拟机网关与VMnet8 ip必须要在同一网段）</h4><p>在cmd命令行下，输入ipconfig查看</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片4.png" alt></p>
<h4 id="三、配置CentOS7相关文件"><a href="#三、配置CentOS7相关文件" class="headerlink" title="三、配置CentOS7相关文件"></a>三、配置CentOS7相关文件</h4><p>1.修改配置文件</p>
<pre><code>[root@localhost ~]# cd /etc/sysconfig/network-scripts
#先查看该目录下相关配置文件名称，有的是ifcfg-ent0,有的是ifcfg-ens33
[root@localhost network-scripts]# vim ifcfg-ens33
TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
BOOTPROTO=&quot;dhcp&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;7d2dd01c-42fc-4ab6-857b-394690430e9f&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
</code></pre><p>在文件底部添加</p>
<pre><code>NM_CONTROLLED=no
BOOTPROTO=static #设置为静态
IPADDR=172.16.137.128 #自己选择的IP，遵循网络段设置0-255任取
NETMASK=255.255.255.0 #子网掩码，在VMware里看到的
GATEWAY=172.16.137.2 #网关，在NAT设置里看到的
DNS1=172.16.137.2
</code></pre><p>保存退出</p>
<p>2.查看网关</p>
<pre><code>[root@localhost ~]# cd /etc
[root@localhost etc]# cat resolv.conf
# Generated by NetworkManager
search localdomain
nameserver 172.16.137.2 #查看网关是否一致
</code></pre><p>3.重启网络服务</p>
<pre><code>[root@localhost ~]# service network restart
</code></pre><p>4.查看IP，并ping外网测试</p>
<p><img src="/2019/08/16/vmware-zai-nat-mo-shi-xia-pei-zhi-jing-tai-ip/图片5.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>cobbler部署并自动化安装系统</title>
    <url>/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/</url>
    <content><![CDATA[<h4 id="一、安装部署"><a href="#一、安装部署" class="headerlink" title="一、安装部署"></a>一、安装部署</h4><p>1.可以去阿里巴巴开源镜像站寻找所需镜像源（epel—&gt;epel-release-latest-7.noarch.rpm），复制其链接</p>
<a id="more"></a>
<pre><code>[root@localhost ~]# rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
</code></pre><p>2.安装所需软件包</p>
<pre><code>[root@localhost ~]# yum install -y httpd dhcp tftp cobbler cobbler-web pykickstart
[root@localhost kickstarts]# yum install xinetd -y
</code></pre><p>3.查看安装情况</p>
<pre><code>[root@localhost ~]# cd /etc/httpd/conf.d/
#可看到cobbler的相关文件
[root@localhost conf.d]# ll
总用量 36
-rw-r--r--. 1 root root 2926 7月  30 01:18 autoindex.conf
-rw-r--r--. 1 root root 1087 11月 27 2018 cobbler.conf
-rw-r--r--. 1 root root 1165 11月 27 2018 cobbler_web.conf
-rw-r--r--. 1 root root  366 7月  30 01:19 README
-rw-r--r--. 1 root root 9443 7月  29 23:15 ssl.conf
-rw-r--r--. 1 root root 1252 7月  29 23:15 userdir.conf
-rw-r--r--. 1 root root  824 7月  29 23:15 welcome.conf
</code></pre><h4 id="二、启动进程"><a href="#二、启动进程" class="headerlink" title="二、启动进程"></a>二、启动进程</h4><pre><code>[root@localhost ~]# systemctl start httpd
[root@localhost ~]# systemctl start cobblerd
[root@localhost kickstarts]# systemctl start xinetd
[root@localhost ~]# cobbler check
</code></pre><p>新装的系统在运行cobbler check命令后会报错，如图所示</p>
<p><img src="/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/图片一.png" alt></p>
<p>解决方法如下：</p>
<pre><code>[root@localhost ~]# getenforce
Enforcing
[root@localhost ~]# setenforce 0
[root@localhost ~]# getenforce
Permissive
[root@localhost ~]# service httpd restart
Redirecting to /bin/systemctl restart httpd.service
</code></pre><p>再次查看，所列条数便是接下来的需要做的配置步骤</p>
<pre><code>[root@localhost ~]# cobbler check
The following are potential configuration items that you may want to fix:

1 : The &#39;server&#39; field in /etc/cobbler/settings must be set to something other than localhost, or kickstarting features will not work.  This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it.
2 : For PXE to be functional, the &#39;next_server&#39; field in /etc/cobbler/settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.
3 : SELinux is enabled. Please review the following wiki page for details on ensuring cobbler works correctly in your SELinux environment:
    https://github.com/cobbler/cobbler/wiki/Selinux
4 : change &#39;disable&#39; to &#39;no&#39; in /etc/xinetd.d/tftp
5 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run &#39;cobbler get-loaders&#39; to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The &#39;cobbler get-loaders&#39; command is the easiest way to resolve these requirements.
6 : enable and start rsyncd.service with systemctl
7 : debmirror package is not installed, it will be required to manage debian deployments and repositories
8 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to &#39;cobbler&#39; and should be changed, try: &quot;openssl passwd -1 -salt &#39;random-phrase-here&#39; &#39;your-password-here&#39;&quot; to generate new one
9 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them

Restart cobblerd and then run &#39;cobbler sync&#39; to apply changes.
</code></pre><h4 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h4><p>1.更改vim etc/cobbler/settings文件中的server，将其改成自己的IP</p>
<pre><code>[root@localhost ~]# vim /etc/cobbler/settings
#需要更改的部分在文件的第272行和384行
</code></pre><p>2.将文件中的disable原来的yes改为no</p>
<pre><code>[root@localhost ~]# vim /etc/xinetd.d/tftp

# default: off
# description: The tftp server serves files using the trivial file transfer \
#       protocol.  The tftp protocol is often used to boot diskless \
#       workstations, download configuration files to network-aware printers, \
#       and to start the installation process for some operating systems.
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
}
</code></pre><p>3.开启进程，使文件生效</p>
<pre><code>[root@localhost ~]# systemctl start rsyncd
[root@localhost ~]# cobbler get-loaders
</code></pre><p>4.设置密码</p>
<pre><code>#命令格式：
[root@localhost ~]# openssl passwd -1 -salt &#39;random-phrase-here&#39; &#39;your-password-here&#39;
#将密码部分填入，命令即可为：
[root@localhost ~]# openssl passwd -1 -salt &#39;cobler&#39; &#39;cobler&#39;
#将生成的密码全部复制下来
$1$cobler$XJnisBweZJlhL651HxAM00
[root@localhost ~]# vim /etc/cobbler/settings
#将密码粘贴到文件的第101行
101 default_password_crypted: &quot;$1$cobler$XJnisBweZJlhL651HxAM00&quot;
#242行的0改为1
242 manage_dhcp: 1
[root@localhost ~]# systemctl restart cobblerd
[root@localhost ~]# cobbler check
</code></pre><p>5.配置dhcp文件</p>
<pre><code>[root@localhost ~]# vim /etc/cobbler/dhcp.template
#将自己服务器的子网，网关，DNS改入
subnet 10.0.2.0 netmask 255.255.255.0 {
     option routers             10.0.2.15;
     option domain-name-servers 10.0.2.15;
     option subnet-mask         255.255.255.0;
     range dynamic-bootp        10.0.2.100 10.0.2.254;
     default-lease-time         21600;
     max-lease-time             43200;
     next-server                $next_server;
     class &quot;pxeclients&quot; {
          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;
#保存后重启服务，使之生效
[root@localhost ~]# systemctl restart cobblerd
[root@localhost ~]# cobbler sync
#可查看更改是否生效
[root@localhost ~]# cat /etc/dhcp/dhcpd.conf
subnet 10.0.2.0 netmask 255.255.255.0 {
     option routers             10.0.2.15;
     option domain-name-servers 10.0.2.15;
     option subnet-mask         255.255.255.0;
     range dynamic-bootp        10.0.2.100 10.0.2.254;
     default-lease-time         21600;
     max-lease-time             43200;
     next-server                10.0.2.15;
</code></pre><h4 id="四、配置kickstart相关服务"><a href="#四、配置kickstart相关服务" class="headerlink" title="四、配置kickstart相关服务"></a>四、配置kickstart相关服务</h4><p>1.磁盘挂载</p>
<pre><code>[root@localhost ~]# mount /dev/cdrom /mnt
mount: /dev/sr0 写保护，将以只读方式挂载
（挂载光盘）
#此步骤要等待一段时间
[root@localhost ~]# cobbler import --path=/mnt/ --name=CentOS-7-x86_64 --arch=x86_64
task started: 2019-08-12_212801_import
task started (id=Media import, time=Mon Aug 12 21:28:01 2019)
Found a candidate signature: breed=redhat, version=rhel6
Found a candidate signature: breed=redhat, version=rhel7
Found a matching signature: breed=redhat, version=rhel7
Adding distros from path /var/www/cobbler/ks_mirror/CentOS-7-x86_64:
creating new distro: CentOS-7-x86_64
trying symlink: /var/www/cobbler/ks_mirror/CentOS-7-x86_64 -&gt; /var/www/cobbler/links/CentOS-7-x86_64
creating new profile: CentOS-7-x86_64
associating repos
checking for rsync repo(s)
checking for rhn repo(s)
checking for yum repo(s)
starting descent into /var/www/cobbler/ks_mirror/CentOS-7-x86_64 for CentOS-7-x86_64
processing repo at : /var/www/cobbler/ks_mirror/CentOS-7-x86_64
need to process repo/comps: /var/www/cobbler/ks_mirror/CentOS-7-x86_64
looking for /var/www/cobbler/ks_mirror/CentOS-7-x86_64/repodata/*comps*.xml
Keeping repodata as-is :/var/www/cobbler/ks_mirror/CentOS-7-x86_64/repodata
*** TASK COMPLETE ***
</code></pre><p>2.可查看完成情况，可发现清单已出现 CentOS-7-x86_64</p>
<pre><code>[root@localhost ~]# cobbler profile list
   CentOS-7-x86_64
</code></pre><p>3.使用自己的kickstarts文件</p>
<pre><code>[root@localhost ~]# cd /var/lib/cobbler/kickstarts
[root@localhost kickstarts]# vim CentOS-7-x86_64.cfg
#将如下内容添至文件中
install
url --url=$tree  
text
lang en_US.UTF-8
keyboard us
zerombr
bootloader --location=mbr 
# Network information
$SNIPPET(&#39;network_config&#39;)
timezone --utc Asia/Shanghai
authconfig --enableshadow --passalgo=sha512
rootpw  --iscrypted $default_password_crypted
clearpart --all --initlabel
part /boot --fstype xfs --size 500  
part swap --size 2000
part / --fstype xfs --size 20000 
part /data --fstype xfs --size 30000 
firstboot --disable
selinux --disabled
firewall --disabled
logging --level=info
reboot
%pre
$SNIPPET(&#39;log_ks_pre&#39;)
$SNIPPET(&#39;kickstart_start&#39;)
$SNIPPET(&#39;pre_install_network_config&#39;)
# Enable installation monitoring
$SNIPPET(&#39;pre_anamon&#39;)
%end
%packages
@base
@compat-libraries
@debugging
@development
tree
nmap
sysstat
lrzsz
dos2unix
telnet
iptraf
ncurses-devel
openssl-devel
zlib-devel
OpenIPMI-tools
screen
%end
%post
systemctl disable postfix.service
%end
#保存后配置路径，如下指令
[root@localhost kickstarts]# cobbler profile edit --name=CentOS-7-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
</code></pre><p>4.CentOS7系统安装时使网卡为eth0需要加内核参数，可通过profile加内核参数</p>
<pre><code>[root@localhost kickstarts]# cobbler profile edit --name=CentOS-7-x86_64 --kopts=&#39;net.ifnames=0 biosdevname=0&#39;
[root@localhost kickstarts]# cobbler profile report
[root@localhost kickstarts]# cobbler sync
#以上命令使输出时清空重新生成一遍，使文件生效
[root@localhost kickstarts]# start xinetd
#开启tftp服务，如果自动安装时进程卡在tftp，可以尝试关闭防火墙
</code></pre><h4 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h4><p>1.VMvare上直接新建一个虚拟机，进入后选择相应系统即可自动安装</p>
<p><img src="/2019/08/12/cobbler-bu-shu-bing-zi-dong-hua-an-zhuang-xi-tong/图片二.png" alt></p>
<p>2.Virtualbox上则先需在管理&gt;&gt;主机网络管理器中，禁止启用DHCP服务，避免发生重复，之后即可新建，启动后自动安装系统。</p>
<h4 id="六、自动化重装"><a href="#六、自动化重装" class="headerlink" title="六、自动化重装"></a>六、自动化重装</h4><pre><code>#使用该工具实现自动化重装
[root@localhost ~]# yum install -y koan
#查看该服务器下可以重装的系统
[root@localhost ~]# koan --server=10.0.2.15 --list=profiles
- looking for Cobbler at http://10.0.2.15:80/cobbler_api
CentOS-7-x86_64
#--profile后指定想重装成的系统
[root@localhost ~]# koan --replace-self --server=10.0.2.15 --profile=CentOS-7-x86_64
</code></pre><p>重启即可将现系统重装为设定系统</p>
<h4 id="七、自定义yum源"><a href="#七、自定义yum源" class="headerlink" title="七、自定义yum源"></a>七、自定义yum源</h4><pre><code>#启动相关服务
[root@localhost ~]# systemctl start httpd.service 
[root@localhost ~]# systemctl start cobblerd.service
#添加源
[root@localhost ~]# cobbler repo add --name=openstack-mitaka --mirror=https://mirrors.aliyun.com/centos/7.6.1810/cloud/x86_64/openstack-stein/ --arch=x86_64 --breed=yum
#进行同步
[root@localhost ~]# cobbler reposync
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下PXE+Kickstart+DHCP+TFTP+HTTP无人值守安装系统</title>
    <url>/2019/08/11/zi-dong-hua-yun-wei/</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="（一）什么是PXE"><a href="#（一）什么是PXE" class="headerlink" title="（一）什么是PXE"></a>（一）什么是PXE</h5><p>​        PXE(Pre boot Execution Environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP ( trivial file transfer protocol )或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机，内存中执行，由这个启动软件包完成终端基本软件设置，从而引导预先安装在服务器中的终端操作系统。</p>
<a id="more"></a>
<p>​        严格来说，PXE并不是一种安装方式 ，而是种引导方式。 进行PXE安装的必要条件是在要安装的计算机中必须包含个PXE支持的网卡(NIC)， 即网卡中必须要有PXE Client。PXE 协议可以使计算机通过网络启动。此协议分为Client端和Server端，而PXE Client则在网卡的ROM中。当计算机引导时，BIOS把PXE Client调入内存中执行，然后由PXE Client将放置在远端的文件通过网络下载到本地运行。运行PXE协议需要设置DHCP服务器和TFTP服务器。DHCP 服务器会给PXE<br>Client (将要安装系统的主机)分配个IP地址，由于是给PXE Client分配IP地址，所以在配置DHCP服务器时需要增加相应的PXE设置。此外，在PXE Client的ROM中，已经存在了TFTP Client，那么它就可以通过TFTP协议到TFTP Server上下载所需的文件了。</p>
<h5 id="（二）PXE工作过程"><a href="#（二）PXE工作过程" class="headerlink" title="（二）PXE工作过程"></a>（二）PXE工作过程</h5><p>​        1.PXE方便通过网络大批量地操作系统的部署。PXE client当按下电源键选择从PXE网络启动，通过广播找到DHCP服务器索取IP；</p>
<p>​        2.DHCP服务器返回分配给客户机的IP以及PXE文件的放置位置(该文件一般是放在一台TFTP服务器上) ;</p>
<p>​        3.PXE Client向本网络中的TFTP服务器索取pxelinux.0文件;</p>
<p>​        4.PXE Client取得pxelinux.0文件后之执行该文件;</p>
<p>​        5.根据nxelinux 0的执行结里诵过TFTP服务器加载内核和文件系统；</p>
<p>​        6.进入安装画面，此时可以通过选择HTTP、FTP、NFS方式之一进行安装。</p>
<h5 id="（三）环境准备说明"><a href="#（三）环境准备说明" class="headerlink" title="（三）环境准备说明"></a>（三）环境准备说明</h5><p>​        PXE服务器：CentOS7基于virtualbox的虚拟机</p>
<p>​        IP：10.0.2.15</p>
<pre class=" language-lang-linux"><code class="language-lang-linux">#可通过如下命令查询DNS
[root@localhost ~]# cat /etc/resolv.conf
</code></pre>
<p>​        DNS：114.114.114.114</p>
<p>​        在tftp服务器上要首先由PXE的安装信息，配置服务及安装软件包如下;DHCP；tftp；http；sysliinux（通过yum安装）</p>
<pre><code>[root@localhost ~]# yum install  dhcp tftp tftp-server syslinux httpd -y
#生成ks.cfg文件需要system-config-kickstart工具
[root@localhost ~]# yum install system-config-kickstart -y
#此工具依赖于X Windows，所以需安装X Windows和Desktop
[root@localhost ~]# yum groupinstall &quot;X Windows System&quot;
[root@localhost ~]# yum groupinstall Desktop
#重启系统
[root@localhost ~]# reboot
</code></pre><h4 id="二、基于httpd搭建本地安装源"><a href="#二、基于httpd搭建本地安装源" class="headerlink" title="二、基于httpd搭建本地安装源"></a>二、基于httpd搭建本地安装源</h4><h5 id="（一）挂载光盘"><a href="#（一）挂载光盘" class="headerlink" title="（一）挂载光盘"></a>（一）挂载光盘</h5><pre><code>#挂载CentOS7光盘
[root@localhost ~]# mkdir /media/cdrom
[root@localhost ~]# mount /dev/cdrom /media/cdrom
[root@localhost ~]# mkdir -pv /var/www/html/centos/7/x86_64
#绑定挂载到http默认目录下
[root@localhost ~]#mount --bind /media/cdrom /var/www/html/centos/7/x86_64
</code></pre><h5 id="（二）kickstart-ks-cfg配置文件"><a href="#（二）kickstart-ks-cfg配置文件" class="headerlink" title="（二）kickstart ks.cfg配置文件"></a>（二）kickstart ks.cfg配置文件</h5><pre><code>[root@localhost ~]# cd /var/www/html;mkdir ks
[root@localhost ~]# vim anaconda-ks.cfg
#version=DEVEL
# System authorization information
auth --enableshadow --passalgo=sha512
# Use CDROM installation media
#cdrom
# Install OS instead of upgrade
install
# Use network installation
url --url=http://（自己的IP地址，如：10.0.2.15）/centos/7/x86_64
# Use graphical install
graphical
# Run the Setup Agent on first boot
firstboot --enable
#ignoredisk --only-use=sda
# Keyboard layouts
keyboard --vckeymap=cn --xlayouts=&#39;cn&#39;
# System language
lang zh_CN.UTF-8

# Network information
network  --bootproto=dhcp --device=enp0s3 --onboot=off --ipv6=auto
network  --hostname=localhost.pkey.cn

# Root password
rootpw --iscrypted $1$lSeSXuy.$7HmGY9vVxEGEGB98qTUuv1
# System timezone
timezone Asia/Shanghai --isUtc
# System bootloader configuration
bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda
autopart --type=lvm
# Partition clearing information
clearpart --none --initlabel

%packages
@^minimal
@core
kexec-tools
vim
wget
httpd
%end
%addon com_redhat_kdump --enable --reserve-mb=&#39;auto&#39;
%end
selinux --disabled     #禁用selinux
reboot        #安装完重启系统
</code></pre><h5 id="（三）配置启动"><a href="#（三）配置启动" class="headerlink" title="（三）配置启动"></a>（三）配置启动</h5><pre><code>[root@localhost ~]# systemctl start httpd
[root@localhost ~]# systemctl enable httpd
</code></pre><h5 id="（四）查看当前服务状态"><a href="#（四）查看当前服务状态" class="headerlink" title="（四）查看当前服务状态"></a>（四）查看当前服务状态</h5><pre><code>[root@localhost ~]# systemctl status httpd.service
</code></pre><p> <img src="/2019/08/11/zi-dong-hua-yun-wei/图片一.png" alt></p>
<h4 id="三、配置DHCP服务"><a href="#三、配置DHCP服务" class="headerlink" title="三、配置DHCP服务"></a>三、配置DHCP服务</h4><h5 id="（一）配置dhcp服务"><a href="#（一）配置dhcp服务" class="headerlink" title="（一）配置dhcp服务"></a>（一）配置dhcp服务</h5><p>dhcp配置文件在/etc/dhcp/目录下,默认的配置文件没有,但我们可以在帮助文件中找到模板示例文件加以修改，帮助文件的位置为 /usr/share/doc/dhcp*/dhcpd.conf.sample，也可以自己新建一个dhcpd.conf文件，写入</p>
<pre><code>[root@localhost ~]# vim /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
option domain-name &quot;pkey.cn&quot;;
option domain-name-servers 114.114.114.114;    #写入网关
default-lease-time 600;
max-lease-time 7200;
log-facility local7;
subnet 10.0.2.0 netmask 255.255.255.0 {
    range dynamic-bootp 10.0.2.110 10.0.2.120;
    option routers 10.0.2.1;
    next-server 10.0.2.254;    #tftp server也是本机,可以分开
  filename &quot;pxelinux.0&quot;;               #引导文件
}
</code></pre><h5 id="（二）启动与查看"><a href="#（二）启动与查看" class="headerlink" title="（二）启动与查看"></a>（二）启动与查看</h5><pre><code>[root@localhost ~]# systemctl start dhcpd
[root@localhost ~]# systemctl enable dhcpd
#查看监听情况
[root@localhost ~]# ss -tunl
Netid  State      Recv-Q Send-Q    Local Address:Port                   Peer Address:Port              
udp    UNCONN     0      0                     *:67                                *:*                 
udp    UNCONN     0      0                     *:68                                *:*                 
udp    UNCONN     0      0             127.0.0.1:323                               *:*                 
udp    UNCONN     0      0                    :::69                               :::*
</code></pre><h5 id="（三）查看当前服务状态"><a href="#（三）查看当前服务状态" class="headerlink" title="（三）查看当前服务状态"></a>（三）查看当前服务状态</h5><pre><code>[root@localhost ~]# systemctl status httpd.service
</code></pre><p><img src="/2019/08/11/zi-dong-hua-yun-wei/图片二.png" alt=" "></p>
<h4 id="四、配置tftp服务"><a href="#四、配置tftp服务" class="headerlink" title="四、配置tftp服务"></a>四、配置tftp服务</h4><p>安装好tftp-server软件包后 默认的数据根目录是/var/lib/tftpboot/ 无须修改,只需要复制一些软件引导文件进来即可</p>
<p><strong>1、相关文件准备</strong></p>
<pre><code>##引导文件
[root@localhost ~]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/  
#内核文件
[root@localhost ~]# cp /media/cdrom/images/pxeboot/{vmlinuz,initrd.img} /var/lib/tftpboot
#引导菜单
[root@localhost ~]# cp /usr/share/syslinux/{chain.c32,mboot.c32,menu.c32,memdisk} /var/lib/tftpboot
#制件引导默认文件
[root@localhost ~]# mkdir -pv /var/lib/tftpboot/pxelinux.cfg
#在/var/lib/tftpboot/pxelinux.cfg目录下
[root@localhost pxelinux.cfg]# cat default 
default menu.c32
   prompt 5
   timeout 30
   MENU TITLE CentOS 7 PXE Menu

   LABEL linux
   MENU LABEL Install CentOS 7 x86_64
   KERNEL vmlinuz
   APPEND initrd=initrd.img inst.repo=http://（自己的IP）/centos/7/x86_64 ks=http://（自己的IP）/ks/ks.cfg
</code></pre><p><strong>2、启动配置开机自启</strong></p>
<pre><code>[root@localhost]# systemctl enable tftp
[root@localhost]# systemctl start tftp
</code></pre><p><strong>3、tftp测试</strong></p>
<pre><code>#查看/var/lib/tftpboot/的目录文件结构
[root@localhost tftpboot]# tree -L 2
.
├── chain.c32
├── initrd.img
├── mboot.c32
├── memdisk
├── menu.c32
├── pxelinux.0
├── pxelinux.cfg
│   └── default
└── vmlinuz

1 directory, 8 files
</code></pre><pre><code>[root@localhost ~]# cd /var/lib/tpm
[root@localhost tpm]# pwd;ls
/var/lib/tpm
[root@localhost tpm]# tftp 10.0.2.15
tftp&gt; get vmlinuz
tftp&gt; quit
[root@localhost tpm]# pwd;ls
/var/lib/tpm
vmlinuz
</code></pre><h5 id="五、PEX无人值守安装测试"><a href="#五、PEX无人值守安装测试" class="headerlink" title="五、PEX无人值守安装测试"></a>五、PEX无人值守安装测试</h5><p><strong>（一）修改virtualbox网络</strong><br>管理—&gt;全局设定—&gt;网络—&gt;”仅主机(Host-Only)网络” —&gt;双击vboxnet0 —&gt;把virtualbox自带的仅主机网络的DHCP服务关掉</p>
<p><strong>（二）新建虚拟机</strong><br>和用cdrom安装虚拟的唯一区别是不用挂载镜像,只需要修改新的虚拟机的网络类型为”仅主机(Host-Only)网络”</p>
<p>开机—&gt;按F12选择LAN启动</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络运维</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机三级嵌入式学习笔记</title>
    <url>/2019/08/10/ji-suan-ji-san-ji-qian-ru-shi-xue-xi-bi-ji/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​        笔者在大一下学期一时冲动，直接跳过计算机二级报名考计算机三级嵌入式。没错，我觉得我冲动了，当时想着接触一下嵌入式，学点皮毛也好，考个证下来就更好了，结果，看书做题，发现，我高估自己了喔。</p>
<a id="more"></a>
<p>​        八十块钱报名费极大可能打水漂，但看完书还是认认真真的把题库刷一遍吧，前面八十分基本全是概念啊，全是啊，我滴天，孩子最不擅长的就是背这些balabala的，哭了，孩子快哭了啊！！！太难啦！！！</p>
<p>​        做过题记一下笔记吧，加深些印象也好，呜呜呜~</p>
<h4 id="大致提纲"><a href="#大致提纲" class="headerlink" title="大致提纲"></a>大致提纲</h4><h5 id="一、嵌入式系统概论"><a href="#一、嵌入式系统概论" class="headerlink" title="一、嵌入式系统概论"></a>一、嵌入式系统概论</h5><h6 id="1-嵌入式系统及其应用"><a href="#1-嵌入式系统及其应用" class="headerlink" title="1.嵌入式系统及其应用"></a>1.嵌入式系统及其应用</h6><p>​        （1）嵌入式系统介绍及其特性：</p>
<p>​                专用性；隐蔽性；资源受限；高可靠性；实时性；软件固化。</p>
<p>​        （2）嵌入式系统的应用</p>
<p>​        （3）嵌入式系统的逻辑组成：</p>
<p>​                软硬件两部分：硬件主体是中央处理器和存储器，它们通过输入/输出（I/O）接口和输入/输出设备与外部世界联系，并借助总线相互连接，这些硬件连同嵌入式软件一同构成完整的嵌入式系统。</p>
<p>​        （4）嵌入式处理芯片：</p>
<p>​                嵌入式系统的CPU一般具有四个特点：支持实时处理；低功耗；结构可扩展；集成了测试电路。</p>
<p>​        （5）目前嵌入式处理芯片类型：</p>
<p>​                微处理器（MCU）；数字信号处理器（DSP）；微控制器（单片机）；片上系统（SoC）。</p>
<p>​        （6）嵌入式系统的多种分类方法</p>
<p>​                可以按用途分类；按实时性分类；按产品形态分类；按系统的复杂程度分类。</p>
<p>​        （7）SoC芯片的介绍</p>
<p>​        （8）IP核及其复用</p>
<p>​                软核；固核；硬核。</p>
<h6 id="2-嵌入式系统与数字媒体"><a href="#2-嵌入式系统与数字媒体" class="headerlink" title="2.嵌入式系统与数字媒体"></a>2.嵌入式系统与数字媒体</h6><p>​        （1）数字（电子）文本</p>
<p>​        （2）数字图像</p>
<p>​        （3）数字音频与数字视频</p>
<h6 id="3-数字通信与计算机网络"><a href="#3-数字通信与计算机网络" class="headerlink" title="3.数字通信与计算机网络"></a>3.数字通信与计算机网络</h6><p>​        （1）数字通信：</p>
<p>​                模拟通信与数字通信；有线与无线通信。</p>
<p>​                调制与解调技术；多路复用技术；交换技术。</p>
<p>​        （2）计算机网络</p>
<p>​        （3）互联网</p>
<h5 id="二、嵌入式处理器"><a href="#二、嵌入式处理器" class="headerlink" title="二、嵌入式处理器"></a>二、嵌入式处理器</h5><h6 id="1-嵌入式处理器概述："><a href="#1-嵌入式处理器概述：" class="headerlink" title="1.嵌入式处理器概述："></a>1.嵌入式处理器概述：</h6><p>​        （1）嵌入式处理器的结构类型</p>
<p>​                嵌入式处理器的体系结构按<u>指令集</u>可分为两大类：复杂指令集结构（CISC）及精简指令集结构（RISC）。进一步细分，按<u>存储机制</u>分为冯.诺依曼结构和哈佛结构；按<u>字长</u>分为8位、16位、32位和64位结构；按<u>不同内核系列</u>又可分为51、AVR、PIC、MSP430、MIPS、PowerPC、MC68K、ColdFire、ARM等。</p>
<p>​        （2）ARM处理器概述</p>
<p>​                主要特点：单周期操作；只使用加载、存储（Load/Store）指令访问内存；指令长度固定为32位长；三地址指令格式；指令流水线技术；低功耗设计。</p>
<h6 id="2-典型ARM处理器介绍"><a href="#2-典型ARM处理器介绍" class="headerlink" title="2.典型ARM处理器介绍"></a>2.典型ARM处理器介绍</h6><p>​        （1）ARM处理器的分类：</p>
<p>​                经典ARM处理器（T表示支持Thumb指令集，D表示支持片上调试，M表示具有快速的64位乘法，I表示提供片内在线仿真，-S表示该处理器以IP软核的形式提供授权）、ARM Cortex嵌入式处理器（Cortex -M）、ARM Cortex实时嵌入式处理器（Cortex -R）、ARM Cortex应用处理器（Cortex -A）以及ARM Cortex专家处理器。</p>
<h6 id="3-ARM处理器体系结构"><a href="#3-ARM处理器体系结构" class="headerlink" title="3.ARM处理器体系结构"></a>3.ARM处理器体系结构</h6><p>​        （1）ARM处理器工作状态：</p>
<p>​                    ARM状态；Thumb状态及Thumb-2状态；调试状态。</p>
<p>​        （2）ARM处理器的工作模式：</p>
<p>​                用户模式（User）；快速中断模式（FIQ）；外部中断模式（IRQ）；管理模式（SVC）；中止模式（ABT）；未定义指令模式（UND）；系统模式（SYS）。</p>
<p>​        （3）ARM异常种类及优先级</p>
<p>​                复位RESET（1）；未定义的指令UND（6）；软件中断SWI（6）；指令预取中止PABT（5）；数据访问中止DABT（2）；外部中断请求IRQ（4）；快速中断请求FIQ（3）。</p>
<p>​        （4）ARM处理器中的MMU（内存管理单元）；MPU（存储器保护单元）。</p>
<h6 id="4-ARM处理器指令集"><a href="#4-ARM处理器指令集" class="headerlink" title="4.ARM处理器指令集"></a>4.ARM处理器指令集</h6><p>​    （太多了，不好记，这部分我还是回去看资料吧。。。ε=(´ο｀*)))唉）</p>
<h6 id="5-ARM汇编语言程序设计"><a href="#5-ARM汇编语言程序设计" class="headerlink" title="5.ARM汇编语言程序设计"></a>5.ARM汇编语言程序设计</h6><h5 id="三、嵌入式系统硬件组成"><a href="#三、嵌入式系统硬件组成" class="headerlink" title="三、嵌入式系统硬件组成"></a>三、嵌入式系统硬件组成</h5><h6 id="1-嵌入式最小硬件系统"><a href="#1-嵌入式最小硬件系统" class="headerlink" title="1.嵌入式最小硬件系统"></a>1.嵌入式最小硬件系统</h6><p>​                电源电路；时钟电路；复位电路；JTAG测试接口。</p>
<h6 id="2-嵌入式处理芯片"><a href="#2-嵌入式处理芯片" class="headerlink" title="2.嵌入式处理芯片"></a>2.嵌入式处理芯片</h6><p>​        （1）ARM的AMBA总线体系结构及标准</p>
<p>​        （2）基于ARM内核的嵌入式芯片的硬件组成</p>
<p>​                存储器及控制器；中断控制器；DMA控制器；电源管理与时钟控制器；GPIO端口；定时计数组件；模拟通道组件；互联通信组件。</p>
<h6 id="3-嵌入式系统的存储器"><a href="#3-嵌入式系统的存储器" class="headerlink" title="3.嵌入式系统的存储器"></a>3.嵌入式系统的存储器</h6><p>​                随机存取存储器；只读存储器；铁电存储器；磁性存储器。</p>
<h6 id="4-I-O接口及常用的I-O设备"><a href="#4-I-O接口及常用的I-O设备" class="headerlink" title="4.I/O接口及常用的I/O设备"></a>4.I/O接口及常用的I/O设备</h6><p>​                通用I/O接口GPIO；集成电路互连总线接口I²C；串行外设接口SPI；串行异步通信接口UART；通用串行总线USB；高清多媒体接口HDMI；常用简单输入设备；常用简单输出设备。</p>
<h6 id="5-ARM内核典型嵌入式处理芯片"><a href="#5-ARM内核典型嵌入式处理芯片" class="headerlink" title="5.ARM内核典型嵌入式处理芯片"></a>5.ARM内核典型嵌入式处理芯片</h6><h6 id="6-嵌入式系统外部通信接口"><a href="#6-嵌入式系统外部通信接口" class="headerlink" title="6.嵌入式系统外部通信接口"></a>6.嵌入式系统外部通信接口</h6><p>​                基于UART的RS-232/RS-485接口；CAN总线接口；以太网通信接口；常用无线通信接口。</p>
<h5 id="四、嵌入式系统软件"><a href="#四、嵌入式系统软件" class="headerlink" title="四、嵌入式系统软件"></a>四、嵌入式系统软件</h5><h6 id="1-嵌入式系统的软件组成"><a href="#1-嵌入式系统的软件组成" class="headerlink" title="1.嵌入式系统的软件组成"></a>1.嵌入式系统的软件组成</h6><p>​    （1）嵌入式软件的特点：</p>
<p>​                软件与硬件一体化；软件代码时空效率要求高；软件可裁剪，尽可能去除冗余；软件应用环境复杂，安全性和可靠性要求高；软件开发难度大；软件面向用户、面向商品、面向应用，受限于功能和具体应用环境；软件产业高度分散；软件具有较长的生命周期。</p>
<p>​    （2）嵌入式软件的软件结构:</p>
<p>​                简单的轮询结构；带中断的轮询结构；监控式操作系统+应用软件的结构；通用嵌入式操作系统+应用软件的结构。</p>
<p>​    （3）硬件抽象层与板级支持包</p>
<p>​    （4）引导加载程序</p>
<p>​                引导加载程序的概念和功能；嵌入式操作系统的加载方式；引导加载程序的执行过程；U-Boot简介。</p>
<p>​    （5）嵌入式系统的设备驱动设备</p>
<h6 id="2-嵌入式操作系统"><a href="#2-嵌入式操作系统" class="headerlink" title="2.嵌入式操作系统"></a>2.嵌入式操作系统</h6><p>​        （1）实时系统与实时操作系统</p>
<p>​                实时系统：硬实时任务；软实时任务；准实时任务。</p>
<p>​                实时操作系统：事件驱动；多级中断嵌套处理；细粒度的任务优先级控制；实时抢占式调度。</p>
<p>​                实时操作系统的实时性指标：中断延迟时间；任务切换时间；任务抢占时间。</p>
<p>​        （2）嵌入式操作系统概述</p>
<p>​                嵌入式操作系统的特点和分类</p>
<p>​                嵌入式操作系统的内核结构：单内核和微内核。</p>
<p>​                常用嵌入式操作系统简介。</p>
<h6 id="3-uC-OS嵌入式操作系统"><a href="#3-uC-OS嵌入式操作系统" class="headerlink" title="3.uC/OS嵌入式操作系统"></a>3.uC/OS嵌入式操作系统</h6><p>​        （1）uC/OS操作系统概述</p>
<p>​                uC/OS-Ⅱ内核大致可以划分为任务调度、任务管理、时间管理、任务间同步与通信以及内存管理、系统管理等模块。系统管理又包括系统初始化、系统启动、中断管理、时钟中断及事件处理等部分。</p>
<p>​        （2）uC/OS-Ⅱ的任务及其管理</p>
<p>​                任务的程序代码；任务堆栈；任务控制块。</p>
<p>​        （3）uC/OS-Ⅱ的系统服务</p>
<p>​                uC/OS-Ⅱ的任务管理服务；uC/OS-Ⅱ的时钟节拍与时间管理服务；uC/OS-Ⅱ的任务间通信与同步服务。</p>
<p>​        （4）uC/OS-Ⅲ操作系统的改进与提高</p>
<p>​                时间片轮转调度；内核对象的数量无限制；任务消息和任务信号；优先级的时钟节拍处理；可针对的时钟节拍处理；可针对处理器体系结构进行优化；时间戳；增强的内置性能测试功能。</p>
<h5 id="五、嵌入式系统的开发"><a href="#五、嵌入式系统的开发" class="headerlink" title="五、嵌入式系统的开发"></a>五、嵌入式系统的开发</h5><h6 id="1-开发嵌入式系统的基础知识"><a href="#1-开发嵌入式系统的基础知识" class="headerlink" title="1.开发嵌入式系统的基础知识"></a>1.开发嵌入式系统的基础知识</h6><p>​        （1）嵌入式系统的开发过程</p>
<p>​                需求分析与规格说明；系统设计；构件设计；系统集成与测试。</p>
<p>​        （2）嵌入式系统的开发特点</p>
<p>​                使用宿主机-目标机的开发架构；与底层硬件控制程序的关系密切；软硬件资源受限制；需要固化程序。</p>
<p>​        （3）嵌入式系统的调试</p>
<p>​                在线仿真器；片上调试技术-JTAG；驻留监控软件调试；指令集模拟器。</p>
<h6 id="2-系统开发工具软件"><a href="#2-系统开发工具软件" class="headerlink" title="2.系统开发工具软件"></a>2.系统开发工具软件</h6><p>​        （1）ADS1.2工具软件</p>
<p>​        （2）RVDS</p>
<p>​        （3）GNU</p>
<p>​                是一种常用于开发基于Linux操作系统的嵌入式软件的工具套件简称。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>​        本篇文章为看完资料书做的大致提纲，梳理知识点与思路，为之后刷题做个铺垫，然鹅好像仍然没有记住多少。。。这知识它不进脑子呀。。。</p>
<p>​        </p>
<p>​        </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装配置看门狗</title>
    <url>/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/</url>
    <content><![CDATA[<h3 id="看门狗——让树莓派永不死机"><a href="#看门狗——让树莓派永不死机" class="headerlink" title="看门狗——让树莓派永不死机"></a>看门狗——让树莓派永不死机</h3><p>当利用树莓派做一些需要长期待机的应用时，会遇到的一个问题就是树莓派会因为过热而死机，需要重启树莓派，然后再次开启树莓派上的应用，watchdog（看门狗）这款软件可以帮我们解决这样的麻烦，来实现树莓派永不死机的功能。</p>
<a id="more"></a>
<p>1.树莓派本身自带了看门狗模块，因此，我们需在命令行中输入下列命令打开配置文件</p>
<pre><code>sudo modprobe bcm2708_wdog
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片一.png" alt></p>
<pre><code>sudo nano /etc/modules
</code></pre><p>2.在配置文件中添加一行”bcm2708_wdog”，添加完成后，按快捷键Ctrl+O进行保存，按快捷键Ctrl+X退出编辑</p>
<p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片二.png" alt></p>
<p>3.输入命令安装看门狗软件</p>
<pre><code>sudo apt-get install chkconfig watchdog
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片三.png" alt></p>
<p>4.输入命令打开看门狗配置文件</p>
<pre><code>sudo nano /etc/watchdog.conf
</code></pre><p>找到”#watchdog-device = /dev/watchdog“一行内容，将“#”去掉</p>
<p>之后便可以自行设定树莓派重启的条件</p>
<p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片四.png" alt></p>
<pre><code>//用于设定CPU温度重启条件
temperature-device=/sys/class/thermal/thermal_zone0/temp
//最大温度为80度，超过80度就会引起重启
max-temperature = 80000
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片五.png" alt></p>
<pre><code>//1分钟最多进程为24个，超过即重启
max-load-1=24
//5分钟最多进程为18个，超过即重启
max-load-5=18
//15分钟最多进程为12个，超过即重启
max-load-15=12
</code></pre><p>完成配置后，按快捷键Ctrl+O进行保存，按快捷键Ctrl+X退出编辑</p>
<p>5.配置看门狗程序，开机自动运行</p>
<pre><code>chkconfig watchdog on
</code></pre><p>6.启动看门狗</p>
<pre><code>sudo /etc/init.d/watchdog start
</code></pre><p><img src="/2019/08/04/shu-mei-pai-an-zhuang-pei-zhi-kan-men-gou/图片六.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell在IP可查且可ping通外网的情况连接不上VirtualBox的解决方法</title>
    <url>/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/</url>
    <content><![CDATA[<p>​    笔者在学习Linux的过程中，经常会遇到xshell连接不上虚拟机的情况，而在使用VirtualBox的时候遇到过一次，IP地址可查，在虚拟机中ping外网也能ping通，但xshell却连接不上的情况。</p>
<a id="more"></a>
<p>​    在网上搜索说是物理机连接虚拟机的网卡配置不对 ：VMware Virtual Ethernet Adapter for VMnet8 ；要将该网卡IP设置为和虚拟机服务器IP在同一个网段，但尝试后仍无效果，后请教大佬得以解决。</p>
<p>​    解决方法如下：</p>
<p>1.进入设置界面</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片一.png" alt></p>
<p>2.进入网络设置，并点击高级选项</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片二.png" alt></p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片三.png" alt></p>
<p>3.按照如下配置，进行转换</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片五.png" alt></p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片四.png" alt></p>
<p>4.登录xshell，配置主机IP</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片六.png" alt></p>
<p>然后即可连接到虚拟机上</p>
<p><img src="/2019/07/14/xshell-lian-jie-bu-shang-virtualbox-de-jie-jue-fang-fa/图片七.png" alt></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>数码雨</title>
    <url>/2019/07/10/shu-ma-yu/</url>
    <content><![CDATA[<h3 id="有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果"><a href="#有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果" class="headerlink" title="有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果"></a>有意思的Linux命令：cmatrix在CentOS终端实现数码雨效果</h3><p>闲言少叙，命令如下</p>
<a id="more"></a>
<p>1.yum -y install wget</p>
<p>2.wget <a href="https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz" target="_blank" rel="noopener">https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz</a></p>
<p>3.tar xvf cmatrix-1.2a.tar.gz</p>
<p>4.跳转到cmatrix-1.2a目录下</p>
<p>命令为 cd cmatrix-1.2a</p>
<p>5.yum install ncurses-devel</p>
<p>（过程中会出现    “Is this ok [y/d/N]: ”</p>
<p>（ 输入”y”,敲回车即可</p>
<p>6.yum -y install gcc</p>
<p>7.yum -y install gcc-c++</p>
<p>8.yum install make</p>
<p>9.输入命令 “./configure &amp;&amp; make &amp;&amp; make install”</p>
<p>（尤其注意，该命令以“.”开头，不要输入错误）</p>
<p>10.输入cmatrix，即可看到数码雨的情景</p>
<p><img src="/2019/07/10/shu-ma-yu/图片一.png" alt></p>
<h4 id="cmatrix常用命令如下"><a href="#cmatrix常用命令如下" class="headerlink" title="cmatrix常用命令如下:"></a>cmatrix常用命令如下:</h4><p>cmatrix-a :异步滚动（默认）</p>
<p>cmatrix-b :随机粗体</p>
<p>cmatrix-B :全部粗体</p>
<p>cmatrix-o :使用旧风格滚动</p>
<p>cmatrix-x :X window 模式</p>
<p>cmatrix-V :显示版本信息</p>
<p>cmatrix-u :刷新频率，0-9，也就是滚动的快慢</p>
<p>cmatrix-C :显示的颜色，支持green(默认),red,blue,white,yellow,cyan</p>
<p><img src="/2019/07/10/shu-ma-yu/图片二.png" alt></p>
<h5 id="骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。"><a href="#骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。" class="headerlink" title="骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。"></a>骇客帝国既视感有木有，但也还蛮现实的，毕竟，这个命令除了装B没啥用。。。</h5>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC数模转换的学习</title>
    <url>/2019/07/09/adc-shu-mo-zhuan-huan/</url>
    <content><![CDATA[<h3 id="一、什么是ADC"><a href="#一、什么是ADC" class="headerlink" title="一、什么是ADC"></a>一、什么是ADC</h3><p>Analog-to-Digital Converter的缩写。</p>
<p>指模/数转换器或者模拟/数字转换器。是指将连续变量的模拟信号转换为离散的数字信号的器件。</p>
<p>典型的模拟数字转换器将模拟信号转换为表示一定比例电压值的数字信号。</p>
<a id="more"></a>
<h3 id="二、STM32F10x的ADC特点"><a href="#二、STM32F10x的ADC特点" class="headerlink" title="二、STM32F10x的ADC特点"></a>二、STM32F10x的ADC特点</h3><p>1.12位逐次逼近型的模拟数字转换器；</p>
<p>2.最多带3个ADC控制器；</p>
<p>3.最多支持18个通道，可最多测量16个外部和2个内部信号源；</p>
<p>4.支持单次和连续转换模式； </p>
<p>5.转换结束，注入转换结束，和发生模拟看门狗事件时产生中断；</p>
<p>6.通道0到通道n的自动扫描模式；</p>
<p>7.自动校准；</p>
<p>8.采样间隔可以按通道编程；</p>
<p>9.规则通道和注入通道均有外部触发选项； </p>
<p>10.转换结果支持左对齐或右对齐方式存储在16位数据寄存器 ADC转换时间：最大转换速率 1us。（最大转换速度为1MHz，在ADCCLK=14M，采样周期为1.5个ADC时钟下得到。）； </p>
<p>11.ADC供电要求：2.4V-3.6V；</p>
<p>12.ADC输入范围：VREF- ≤  VIN  ≤  VREF+</p>
<h3 id="三、STM32通道组"><a href="#三、STM32通道组" class="headerlink" title="三、STM32通道组"></a>三、STM32通道组</h3><h5 id="规则通道组：相当正常运行的程序。最多16个通道。"><a href="#规则通道组：相当正常运行的程序。最多16个通道。" class="headerlink" title="规则通道组：相当正常运行的程序。最多16个通道。"></a>规则通道组：相当正常运行的程序。最多16个通道。</h5><p>规则通道和它的转换顺序在ADC_SQRx寄存器中选择，规则组转换的总数应写入ADC_SQR1寄存器的L[3:0]中</p>
<h5 id="注入通道组：相当于中断。最多4个通道。"><a href="#注入通道组：相当于中断。最多4个通道。" class="headerlink" title="注入通道组：相当于中断。最多4个通道。"></a>注入通道组：相当于中断。最多4个通道。</h5><p>注入组和它的转换顺序在ADC_JSQR寄存器中选择。注入组     里转化的总数应写入ADC_JSQR寄存器的L[1:0]中</p>
<p><img src="/2019/07/09/adc-shu-mo-zhuan-huan/guize.png" alt></p>
<p><img src="/2019/07/09/adc-shu-mo-zhuan-huan/zhuru.png" alt></p>
<h3 id="四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。"><a href="#四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。" class="headerlink" title="四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。"></a>四、STM32F1的ADC的各通道可以单次，连续，扫描或者间断模式执行。</h3><h4 id="ADC单通道："><a href="#ADC单通道：" class="headerlink" title="ADC单通道："></a>ADC单通道：</h4><p>要求进行一次ADC转换：配置为单次模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，就停止转换。</p>
<p>要求进行连续ADC转换：配置为连续模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，接着进行下一次转换，不断连续。</p>
<h4 id="ADC多通道："><a href="#ADC多通道：" class="headerlink" title="ADC多通道："></a>ADC多通道：</h4><p>要求进行一次ADC转换：配置为单次模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，就停止转换。</p>
<p>要求进行连续ADC转换：配置为连续模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，接着进行下一次转换，不断连续。</p>
<p>（扫描模式只在多通道的条件下有效，来使得各个通道按照配置循序依次转换。而单次模式无论在单通道还是多通道下只对这些或者这个通道进行一次转换，连续模式无论是在单通道还是多通道下都对这些或者这个通道不断进行连续的转换。 ）</p>
<h3 id="五、ADC中断"><a href="#五、ADC中断" class="headerlink" title="五、ADC中断"></a>五、ADC中断</h3><p>规则和注入组转换结束时能产生中断。它们都有独立的中断使能位。</p>
<h3 id="六、配置函数选讲"><a href="#六、配置函数选讲" class="headerlink" title="六、配置函数选讲"></a>六、配置函数选讲</h3><h5 id="（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入"><a href="#（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入" class="headerlink" title="（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入"></a>（1）开启PA口时钟和ADC1时钟，设置PA1为模拟输入</h5><h5 id="GPIO-Init"><a href="#GPIO-Init" class="headerlink" title="GPIO_Init();"></a>GPIO_Init();</h5><h5 id="APB2PeriphClockCmd"><a href="#APB2PeriphClockCmd" class="headerlink" title="APB2PeriphClockCmd();"></a>APB2PeriphClockCmd();</h5><p>其中设置分频因子时需注意：</p>
<p>RCC_ADCCLKConfig(RCC_PCLK2_Div6); </p>
<p>//设置 ADC 分频因子 6<br>//APB2的时钟为72M,而72M/6=12,ADC 最大时间不能超过 14M</p>
<h5 id="（2）ADC-规则通道配置函数"><a href="#（2）ADC-规则通道配置函数" class="headerlink" title="（2）ADC 规则通道配置函数"></a>（2）ADC 规则通道配置函数</h5><h5 id="ADC-RegularChannelConfig-ADC1-ADC-Channel-1-1-ADC-SampleTime-239Cycles5"><a href="#ADC-RegularChannelConfig-ADC1-ADC-Channel-1-1-ADC-SampleTime-239Cycles5" class="headerlink" title="ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1,                   ADC_SampleTime_239Cycles5 );"></a>ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1,                   ADC_SampleTime_239Cycles5 );</h5><p>ADC1的通道1，第三个1是指ADC1的通道1在规则序列中序号为1，即第一个转换，最后一个参数表示采样周期为239.5</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN基础知识介绍</title>
    <url>/2019/05/03/can-xue-xi-bi-ji/</url>
    <content><![CDATA[<h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><p>CAN是控制器局域网络(Controller Area Network, CAN)的简称，已成为汽车计算机控制系统和嵌入式工业控制局域网的标准总线。</p>
<a id="more"></a>
<h4 id="一、CAN协议的特点"><a href="#一、CAN协议的特点" class="headerlink" title="一、CAN协议的特点"></a>一、CAN协议的特点</h4><p>1.多主控制</p>
<p>2.系统柔软性</p>
<p>3.速度快，距离远</p>
<p>4.具有错误检测，错误通知和错误恢复功能</p>
<p>5.故障封闭功能</p>
<p>6.连接节点多</p>
<h4 id="二、物理层特征"><a href="#二、物理层特征" class="headerlink" title="二、物理层特征"></a>二、物理层特征</h4><p>显性电平对应逻辑：0（CAN_H和CAN_L之差为2V左右）</p>
<p>隐性电平对应逻辑：1（CAN_H和CAN_L之差为0V）</p>
<p>【在CAN总线的起止端都有一个120欧姆的中断电阻，来做阻抗匹配，以减少回波辐射】</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片1.png" alt="逻辑电平"></p>
<h4 id="三、数据帧（7个段）"><a href="#三、数据帧（7个段）" class="headerlink" title="三、数据帧（7个段）"></a>三、数据帧（7个段）</h4><p><img src="/2019/05/03/can-xue-xi-bi-ji/图片2.png" alt="数据帧"></p>
<p>1.帧起始：表示数据帧开始的段</p>
<p>2.仲裁段：表示该帧优先级的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片3.png" alt="仲裁段"></p>
<p>3.控制段：表示数据的字节数及保留位的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片4.png" alt="控制段"></p>
<p>4.数据段：数据的内容，一帧可发送0~8个字节的数据</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片5.png" alt="数据段"></p>
<p>5.CRC段：检查帧的传输错误的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片6.png" alt="CRC段"></p>
<p>6.ACK段：表示确认正常接收的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片7.png" alt="ACK段"></p>
<p>7.帧结束：表示数据帧结束的段</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片8.png" alt="帧结束"></p>
<p>（ ID：11位，高位在前，低位在后，基本ID禁止高7位都为隐性，即不能：ID=1111111xxxx ）</p>
<h4 id="四、总线仲裁"><a href="#四、总线仲裁" class="headerlink" title="四、总线仲裁"></a>四、总线仲裁</h4><p>1.总线空闲时，最先发送的单元获得发送优先权，一旦发送，其他单元无法抢占</p>
<p>2.如果有多个单元同时发送，则连续输出显性电平多的单元，具有较高优先级</p>
<h4 id="五、位时序"><a href="#五、位时序" class="headerlink" title="五、位时序"></a>五、位时序</h4><p>可根据位时序设置波特率</p>
<p><img src="/2019/05/03/can-xue-xi-bi-ji/图片9.png" alt="位时序"></p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>一直觉得通信啥的很玄学，其实还是没能熟练掌握最基本的规则。说玄也玄，但万物有因，了解好通信的基础知识，以后出现问题，才好追根溯源，然后好好解决。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的生命周期和作用域</title>
    <url>/2019/05/03/c-yu-yan-de-sheng-ming-zhou-qi-he-zuo-yong-yu/</url>
    <content><![CDATA[<p>生命周期：是一个变量存在的周期。</p>
<p>作用域：是一个变量可以被引用的范围。最常见的如：{}、static修饰符等等。</p>
<a id="more"></a>
<h3 id="（1）全局变量："><a href="#（1）全局变量：" class="headerlink" title="（1）全局变量："></a>（1）全局变量：</h3><p>作用域：全局作用域（只需要在一个源文件中定义，就可以作用于所有的源文件）；</p>
<p>生命周期：程序运行期一直存在；</p>
<p>引用方法：其他文件如果要使用，必须用extern 关键字声明要引用的全局变量；</p>
<p>内存分布：全局（静态存储区）。</p>
<p>注意：如果再两个文件中都定义了相同名字的全局变量，则连接错误：变量重定义。</p>
<h3 id="（2）全局静态变量："><a href="#（2）全局静态变量：" class="headerlink" title="（2）全局静态变量："></a>（2）全局静态变量：</h3><p>生命周期：程序运行期一直存在；</p>
<p>作用域：文件作用域（只在被定义的文件中可见：static的一个作用就是隐藏）</p>
<p>内存分布：全局（静态存储区）。</p>
<p>定义方法：static关键字，const关键字（注意C/C++意义不同）</p>
<p>注意：只要文件不相互包含，两个不同的文件中是可以定义完全相同的两个全局静态变量的。</p>
<h3 id="（3）静态局部变量："><a href="#（3）静态局部变量：" class="headerlink" title="（3）静态局部变量："></a>（3）静态局部变量：</h3><p>生命周期：程序运行期一直存在；（超过其作用域便无法被引用）</p>
<p>作用域：局部作用域（只在局部作用于可见）</p>
<p>内存分布：全局（静态存储区）。</p>
<p>定义方法：局部作用域中用static定义。</p>
<p>注意：只被初始化一次，多线程中需要加锁保护。</p>
<h3 id="（4）局部变量："><a href="#（4）局部变量：" class="headerlink" title="（4）局部变量："></a>（4）局部变量：</h3><p>生命周期：程序运行处局部作用域 即被销毁。</p>
<p>作用域：局部作用域（只在局部作用于可见）</p>
<p>内存分布：栈区</p>
<p>定义方法：在局部作用域中用auto指示符定义，可省略auto</p>
<pre class=" language-lang-c"><code class="language-lang-c">static int c =  1;//全局初始化去（静态全局变量）
int a = 0; //全局初始化区(全局变量)
char  *p1; //全局未初始化区（全局变量）

int main(int argc, char const *argv[])
{
    int b;//存放于栈区（局部变量）
    char s[] = "abc";//s存放于栈区（局部变量）
    char *p2 ;//栈（局部变量）
    char *p3 = "123456";//p3存放于栈区(局部变量);“123456”存放区文字常量区

    static int c = 0;// c存放于全局初始化区（静态局部变量）
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);//分配得来的10和20字节的区域在堆区；
                            //变量p1、p2指向堆区分配的内存

    strcpy(p1, "123456");//“123456”存放区文字常量区
    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/05/03/test/</url>
    <content><![CDATA[<h3 id="Hello-world！"><a href="#Hello-world！" class="headerlink" title="Hello world！"></a>Hello world！</h3><p>第一篇博客佛系的向世界问好</p>
<a id="more"></a>
<p>老羊头以后会好好经营自己的小破站</p>
<p>Hello world！</p>
<p><img src="/2019/05/03/test/timg1.jpg" alt="你想输入的替代文字"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
